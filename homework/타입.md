## lodash

## 타입스크립트의 이해
### if + return 보다는 switch
```ts
const toastNodes5 = toasts.map((toast) => {
  switch (toast.type) {
    case ToastType.AFTER_SAVED:
      return (
        <div key={toast.createdAt}>
          <AfterSavedToast />
        </div>
      );
    case ToastType.AFTER_PUBLISHED:
      return (
        <div key={toast.createdAt}>
          <AfterPublishedToast />
        </div>
      );
    case ToastType.AFTER_RESTORE:
      return (
        <div key={toast.createdAt}>
          <AfterRestoredToast />
        </div>
      );
    default:
      return neverExpected(toast.type);
  }
});
```
### optional 보다는 union type 사용
```ts
type Result1<T> = {
  data?: T;
  error?: Error;
  loading: boolean;
};

declare function getResult1(): Result1<string>;

const r1 = getResult1();
r1.data; // string | undefined
r1.error; // Error | undefined
r1.loading; // boolean

if (r1.data) {
  r1.error; // Error | undefined
  r1.loading; // boolean
}
```
이렇게도 할 수 있지만 
```ts
type Result2<T> =
  | { loading: true }
  | { data: T; loading: false }
  | { error: Error; loading: false };

declare function getResult2(): Result2<string>;

const r2 = getResult2();

r2.data; // error! Property 'data' does not exist on type 'Result2<string>'. Property 'data' does not exist on type '{ loading: true; }'.
r2.error; // error! Property 'error' does not exist on type 'Result2<string>'. Property 'error' does not exist on type '{ loading: true; }'.
r2.loading; // boolean

if ('data' in r2) {
  r2.error; // error! Property 'error' does not exist on type '{ data: string; loading: false; }'.
  r2.loading; // false
}
```

이렇게 할 수 있다. 
### Mapped Types readonly
```ts
interface IPerson {
  name: string;
  age: number;
}

type ReadonlyPerson = Readonly<IPerson>;

const person: ReadonlyPerson = Object.freeze<IPerson>({
  name: "Mark",
  age: 38,
});

person.name = "Hanna"; // error!
person.age = 27; // error!
```
Readonly 등은 타입스크립트에서 지원하는 Mapped Types이다. 

### readonly와 const 차이
```ts
const weekdays: ReadonlyArray<string> = [
  'Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday',
];

weekdays[0]; // readonly string[]
weekdays[0] = 'Fancyday'; // error! Index signature in type 'readonly string[]' only permits reading.
const weekdays = [
  'Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday',
] as const;

weekdays[0]; // "Sunday"
weekdays[0] = 'Fancyday'; // error! Cannot assign to '0' because it is a read-only property.]

```

### 오버로딩
```ts
function shuffle2<T extends string | any[]>(
  value: T,
): T extends string ? string : T;
function shuffle2(value: any) {
  if (typeof value === 'string')
    return value
      .split('')
      .sort(() => Math.random() - 0.5)
      .join('');
  return value.sort(() => Math.random() - 0.5);
}

// function shuffle2<"Hello, Mark!">(value: "Hello, Mark!"): string
shuffle2('Hello, Mark!');

// function shuffle2<string[]>(value: string[]): string[]
shuffle2(['Hello', 'Mark', 'long', 'time', 'no', 'see']);

// function shuffle2<number[]>(value: number[]): number[]
shuffle2([1, 2, 3, 4, 5]);

// error! Argument of type 'number' is not assignable to parameter of type 'string | any[]'.
shuffle2(1);
```
셔플함수를 통해 리턴하는 값이 string | any[]를 string 또는 any로 설정하게 한다. 
```ts
function shuffle3(value: string): string;
function shuffle3<T>(value: T[]): T[];
function shuffle3(value: string | any[]): string | any[] {
  if (typeof value === 'string')
    return value
      .split('')
      .sort(() => Math.random() - 0.5)
      .join('');
  return value.sort(() => Math.random() - 0.5);
}

shuffle3('Hello, Mark!');
shuffle3(['Hello', 'Mark', 'long', 'time', 'no', 'see']);
shuffle3([1, 2, 3, 4, 5]);
```
이렇게 할 수도 있지만 이처럼 오버로딩으로 할 수 있다.본디 오버로딩은 이름은 다르고 시그니쳐만 다른 것을 뜻하는데 타입스크립트의 오버로딩은 로직구현을 설정, 타이핑만 도와주는 것. 

### 내장 conditional types
```ts
// type NonNullable<T> = T extends null | undefined ? never : T;
type NonNullabled = NonNullable<string | number | null | undefined>;
```
타입스크립트에 내장된 헬퍼함수를 이용할 수 있다 
### 함수의 리턴타입 알아내기
```ts
function plus1(seed: number): number {
  return seed + 1;
}

type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : any;

type Id = MyReturnType<typeof plus1>;

lookupEntity(plus1(10));

function lookupEntity(id: Id) {
  // query DB for entity by ID
}
```
제네릭 부분에 `<T extends (...args: any) => any>`가 있는 것은 "함수여야" 한다는 제약사항을 의미한다. `<typeof plus1>` 컴파일 타이밍의 타입은 return 할 당시의 type를 의미한다. 따라서 결과적으로 Id는 number가 된다. 
### infer
```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
const promises = [Promise.resolve('Mark'), Promise.resolve(38)];

type Expected = UnpackPromise<typeof promises>; // string | number
```
Promise에 있는 인자값을 뽑아 낼 수 있다. 
### Flatten 
```ts
type Flatten<T> = T extends any[]
  ? T[number]
  : T extends object
  ? T[keyof T]
  : T;


const numbers = [1, 2, 3];
type NumbersArrayFlattened = Flatten<typeof numbers>;
// 1. number[]
// 2. number

const person = {
  name: 'Mark',
  age: 38
};
                             
type SomeObjectFlattened = Flatten<typeof person>;
// 1. keyof T --> "id" | "name"
// 2. T["id" | "name"] --> T["id"] | T["name"] --> number | string

const isMale = true;
type SomeBooleanFlattened = Flatten<typeof isMale>;
// true
```
삼항연산자를 통해 단계적으로 설정되는 것을 잘보자.
### ArrayFilter
```ts
type ArrayFilter<T> = T extends any[] ? T : never;

type StringsOrNumbers = ArrayFilter<string | number | string[] | number[]>;

// 1. string | number | string[] | number[]
// 2. never | never | string[] | number[]
// 3. string[] | number[]
```
`T extends any[]` Array타입, 왼쪽에서 부터 필터링되면서 최종적으로 3번이 됨. 
### 인자에 따른 조건부 컨테이너 변환 
```ts
type Item3<T> = {
  id: T extends string | number ? T : never;
  container: T extends string
    ? StringContainer
    : T extends number
    ? NumberContainer
    : never;
};

const item3: Item3<boolean> = {
  id: true, // Type 'boolean' is not assignable to type 'never'.
  container: null, // Type 'null' is not assignable to type 'never'.
};
```
요구사항 : Item<T> T 가 string 이면 StringContainer, T 가 number 면 NumberContainer 아니면 사용 불가를 하기 위해 위와 같은 코드. `T extends string`는 T가 string이면 이라는 뜻. 상속이라 생각하지 말자. 

### !와 ?
 - ! : Nullable, null과 undefine를 혀용, 초기화하지 않아도 됨. 
 - ? : Optional, 필수값이 아님.  

### Type Guard
타입스크립트의 꽃
```ts
class NegativeNumberError extends Error {}

function getNumber(value: number): number | NegativeNumberError {
  if (value < 0) return new NegativeNumberError();

  return value;
}

function main() {
  const num = getNumber(-10);

  if (num instanceof NegativeNumberError) {
    return;
  }

  num; // number
}
```
알아서 몇가지 중 배제되는 것을 파악해서 타입을 추론해준다.
```ts
interface Admin {
  id: string;
  role: string:
}

interface User {
  id: string;
  email: string;
}

function redirect(user: Admin | User) {
  if("role" in user) {
    routeToAdminPage(user.role);
  } else {
    routeToHomePage(user.email);
  }
}
```
또한 프로퍼티를 체크해서 해주면서 분기로직에 도움을 준다. 
```ts
interface IMachine {
  type: string;
}

class Car implements IMachine {
  type: 'CAR';
  wheel: number;
}

class Boat implements IMachine {
  type: 'BOAT';
  motor: number;
}

function getWhellOrMotor(machine: Car | Boat): number {
  if (machine.type === 'CAR') {
    return machine.wheel;
  } else {
    return machine.motor;
  }
}
```
### extends와 implements의 차이
 - extends : The new class is a child. It gets benefits coming with inheritance. It has all properties, methods as its parent. It can override some of these and implement new, but the parent stuff is already included.
 - implements means: The new class can be treated as the same "shape", while it is not a child. It could be passed to any method where the Person is required, regardless of having different parent than Person

### 타입추론
```ts
const m = [new Rhino(), new Elephant(), new Snake()]; // (Rhino | Elephant | Snake)[]
const n = [new Animal(), new Rhino(), new Elephant(), new Snake()]; // Animal[]
const o: Animal[] = [new Rhino(), new Elephant(), new Snake()]; // Animal[]
```
명시적으로 선언하지 않으면 유니온타입이 된다. 
### 서브타입과 슈퍼타입 
```ts
// sub2 타입은 sup2 타입의 서브 타입이다.
let sub2: number[] = [1];
let sup2: object = sub2;
sub2 = sup2; // error! Type '{}' is missing the following properties from type 'number[]': length, pop, push, concat, and 16 more.

// sub5 타입은 sup5 타입의 서브 타입이다.
let sub5: never = 0 as never;
let sup5: number = sub5;
sub5 = sup5; // error! Type 'number' is not assignable to type 'never'.

class Person {}
class Developer extends Person {
  coding() {}
}
class StartupDeveloper extends Developer {
  burning() {}
}

function tellme(f: (d: Developer) => Developer) {}

// Developer => Developer 에다가 Developer => Developer 를 할당하는 경우
tellme(function dToD(d: Developer): Developer {
  return new Developer();
});

// Developer => Developer 에다가 Person => Developer 를 할당하는 경우
tellme(function pToD(d: Person): Developer {
  return new Developer();
});

// Developer => Developer 에다가 StartipDeveloper => Developer 를 할당하는 경우
tellme(function sToD(d: StartupDeveloper): Developer {
  return new Developer();
});

never은 모든 타입이 가지고 있는 클래스
같거나 서브타입인 경우에 할당이 가능하다. (공변)
같거나 슈퍼타입인 경우에 함수 인자로 가능하다. (반병)
```
### .tsx 
ts는 js와 같은 타입스크립트 코드로만 이루어진 경우에 붙고, 여기에 x가 붙으면 ui 컴포넌트라는 뜻이 된다.
### 클래스
```ts
interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

class Student {
    fullName: string;
    constructor(public firstName: string, public middleInitial: string, public lastName: string) {
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    }
}

const user: User = new UserAccount("Murphy", 1);
구조가 같으면 이렇게 클래스로 선언한 값을 인터페이스에 넣을 수 있다.
public과 private필드를 적용할 수 있다. 

class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // 오류: 'name'은 비공개로 선언되어 있습니다;
```
### 제네릭(Generics)
```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;

제네릭은 타입에 변수를 제공하는 방법 
이해
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3]; // 제네릭

항등함수
function  doSomething < T > ( arg : T ) :  T  { 
    return  arg ; 
}

### declare
```ts
declare function pad(s: string, n: number, direction: "left" | "right"): string;
pad("hi", 10, "left");
```
### Contextual typing
```ts
declare function map<T, U>(ts: T[], f: (t: T) => U): U[];

### readonly
```ts
interface Rx {
  readonly x: number;
} 
readonly와 const 중에 어떤 것을 사용할 지 기억하기 가장 쉬운 방법은 변수와 프로퍼티중 어디에 사용할지 질문해 보는 것입니다. 변수는 const를 사용하고 프로퍼티는 readonly를 사용합니다
```
### enum
```ts
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
enum을 하게 되면 기본적으로 0, 1, 2로 설정이 되지만
enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
이렇게 바꿀 수도 있다. 
```
### Type assertions 
```ts
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
let strLength: number = (someValue as string).length;
JSX와 사용할 때는 as만 허용, 어떠한 타입을 강제적으로 단언한다.
as const를 하게 되면 readonly가 된다. 

var foo = <foo>bar;
var foo = bar as foo;
위와 동일한 뜻이다. 
```
### function types 
```ts
interface SearchFunc {
    (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
}
```
### indexable types
```ts
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // 오류!
```

### extending interfaces
```ts
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
```
### hybrid types
```ts
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = (function (start: number) { }) as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

### 공통타입변환 
```ts
 - Partial<T>
 - Readonly<T>
 - Record<K,T>
 - Pick<T,K>
 - Omit<T,K>
 - Exclude<T,U>
 - Extract<T,U>
 - NonNullable<T>
 - Parameters<T>
 - ConstructorParameters<T>
 - ReturnType<T>
 - InstanceType<T>
 - Required<T>
 - ThisParameterType
 - OmitThisParameter
 - ThisType<T>
```
### JSX와 타입
```ts
interface PropsType {
  children: JSX.Element
  name: string
}

class Component extends React.Component<PropsType, {}> {
  render() {
    return (
      <h2>
        {this.props.children}
      </h2>
    )
  }
}

// 성공
<Component name="foo">
  <h1>Hello World</h1>
</Component>

// 오류 : 자식은 JSX.Element의 배열이 아닌 JSX.Element 타입입니다.
<Component name="bar">
  <h1>Hello World</h1>
  <h2>Hello World</h2>
</Component>

// 오류 : 자식은 JSX.Element의 배열이나 문자열이 아닌 JSX.Element 타입입니다.
<Component name="baz">
  <h1>Hello</h1>
  World
</Component>
```
### .d.ts 파일 
TypeScript 3.7에서, TypeScript는 JSDoc 구문을 사용한 JavaScript에서 .d.ts 파일을 생성할 수 있게 되었습니다.

즉 프로젝트를 TypeScript에 이식하거나(porting) 코드베이스에 .d.ts 파일을 유지하지 않고도 TypeScript 기반 편집기의 환경을 유지할 수 있습니다. TypeScript는 대부분의 JSDoc 태그를 지원하며, 참조에서 찾을 수 있습니다.
