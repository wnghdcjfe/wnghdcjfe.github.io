
## redux-thunk
```js
// 액션 타입
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

// 액션 생성 함수
export const increase = () => ({ type: INCREASE });
export const decrease = () => ({ type: DECREASE });

// getState를 쓰지 않는다면 굳이 파라미터로 받아올 필요 없습니다.
export const increaseAsync = () => dispatch => {
  setTimeout(() => dispatch(increase()), 1000);
};
export const decreaseAsync = () => dispatch => {
  setTimeout(() => dispatch(decrease()), 1000);
};

// 초깃값 (상태가 객체가 아니라 그냥 숫자여도 상관 없습니다.)
const initialState = 0;

export default function counter(state = initialState, action) {
  switch (action.type) {
    case INCREASE:
      return state + 1;
    case DECREASE:
      return state - 1;
    default:
      return state;
  }
}
```
이렇게 type, type에 따른 액션 생성함수, 초기값, 타입에 따른 state설정을 지정해 둔뒤 
```js
import React from 'react';
import Counter from '../components/Counter';
import { useSelector, useDispatch } from 'react-redux';
import { increaseAsync, decreaseAsync } from '../modules/counter';

function CounterContainer() {
  const number = useSelector(state => state.counter);
  const dispatch = useDispatch();

  const onIncrease = () => {
    dispatch(increaseAsync());
  };
  const onDecrease = () => {
    dispatch(decreaseAsync());
  };

  return (
    <Counter number={number} onIncrease={onIncrease} onDecrease={onDecrease} />
  );
}

export default CounterContainer;
```
위와 같이 쓰면 된다. 
## 커버로스 commands
 - kinit : 커버로스 티켓을 받고 캐싱하는 명령어
 - klist : keytab 파일에 보관된 키를 볼 수 있다. 
 - kpasswd : 커버로스 비밀번호 수정
 - krb5 : 커버로스 구성파일, `/etc/krb5/krb5.conf` 보통 여기서 볼 수 있다. 

## 하둡 : 분산캐시(distributed cache)
### 분산캐시(distributed cache)
분산 파일 시스템 (HDFS)과 같은 분산 파일 시스템은 많은 컴퓨터의 하드 디스크에 큰 파일 (또는 그 이상)을 저장할 수있는 아키텍처, 파일의 일부들을 다른 컴퓨터 등에 보관되며 분산 캐시는 작업이 실행되는 동안 모든 컴퓨터에 동일한 입력 파일을 제공하는 수단이며 컴퓨터 메모리에 로드됨. 작업이 끝나면 사라지는 휘발성인 특징 
### 매퍼 
입력을 담당함, 매퍼 > 버퍼 > spill > 파일 등... 의 구조를 가짐. 
맵의 출력은 일단 메모리 버퍼에 보관하고 조건에 따라 파일로 내려감. 

### 맵리듀스
하둡 맵리듀스의 구성요소는 다음과 같다. 
 - 태스크 (Task) : 맵퍼나 리듀서가 수행하는 단위 작업 (맵 태스크, 리듀스 태스크)맵 혹은 리듀스를 수행하기 위한 정보를 가지고 있음 
 - 맵퍼 (Mapper)  :3 단계: 맵 (Map), 컴바인 (Combine), 파티션 (Partition) 
 - 리듀서 (Reducer) :셔플/정렬 (Shuffle/Sort), 리듀스(Reduce) / 맵리듀스는 여러 노드에 태스크를 분배하는 방법으로 각 노드 프로세스 데이터는 가능한 경우, 해당 노드에 저장됩니다. 맵리듀스 태스크는 맵(Map)과 리듀스(Reduce) 총 두단계로 구성됩니다. 간단한 예를 들면 fork-join의 개념을 들 수 있습니다. 큰 작업에 대해 fork로 분할하고 또다시 fork로 분할합니다. 작은 작업을 다시 join하게 됩니다. 하둡에서는 큰 데이터가 들어왔을 때 64MB단위 블럭으로 분할합니다. 각각 블럭에 대한 연산을 한다.

맵작업의 예는 다음과 같다. 구글에는 많은 텍스트 파일이 존재. Word1, Word2, Word3... 텍스트 안에 단어가 몇 번 나왔는가하는 것을 계산하는 작업을 수행하게 됨 즉, 텍스트파일을 64MB 단위로 잘라내어 각 블럭에 대해서 특정 단어가 몇번 출현했는지를 계산하는 것이 후, Map 작업을 수행한 각각의 블럭의 결과 정보를 합치는 작업(Reduce)를 수행하게 되는 방식. 하둡에서는 계산시, 큰 파일을 블럭단위로 나누고 모든 블럭은 같은 Map 작업을 수행하고 이후 Reduce 작업을 수행하게 된다.   

## FE : 공부 - 지속가능한 코드작성과 성능향상법강의(3/5)
틈틈히 FE관련 강의를 듣는 중이다. [링크](https://www.fastcampus.co.kr/dev_red_ktg)
 - 모든 기술 html, js, css의 플랫폼 web 브라우저
 - html4보다 html5가 사용자 친화적으로 만들어져
 - 크로스브라우징 : 사용자가 꼭 필요한 정보만을 받을 수만 있으면 되며 브라우저마다 다 맞출 필요는 없다. 예를 들어 비디오태그가 지원되지 않는 브라우저는 a태그를 놓아 file을 다운로드 받게 만들어야 한다. 
 - 보통은 js로 html의 API(notification api)를 호출하는 것을 많이 한다. 
 - 브라우저는 table태그를 한번에 표현하기 때문에 table태그가 많으면 흰 화면을 보는 시간이 많아 진다. 
 - CSS의 논리적프로퍼티와 값, inline과 block의 경우 inline은 텍스트 쓰기방향, block은 텍스트 쓰기 방향에 수직이다. 즉 어떠한 글자(한국어, 중국어)에 따라 CSS를 통해 자동적으로 반영됨. 예를 들어 border-top-width라고 했을 때 border-block-start-width이런식으로 할 수 있음. 예를 들어 다국적 서비스를 한다고 했을 때 이를 사용해야 함. 
 - 수도클래스, :hover, :visited, :focus, :is() 등이 있음. 
 - margin collapsing, 수직 인접한 두 마진이 더 큰 쪽으로 병합되는 현상
 - commonJS(require)는 종국에 가 ESM(import $ from "jquery") 방식으로 변환될 것. 
 - ES6부터는 연도를 표기하는데 보통 ES6라고 하면 ES6와 그 이후를 의미함.
 - 이벤트루프, 자바스크립트 동시성(concurrency) 처리 모델의 기본 원리, UI업데이트, 사용자 이벤트도 모두 같은 스레드에서 처리, 메세지 큐안에 있는 함수가 너무 오래걸릴 경우 이벤트루프가 메시지큐를 확인하지 않아서 버버벅 거리는 현상발생(아닌거 같은데... 보통 메세지큐에서 마감이 되었을 때 이벤트루프로 올라가고 내부코드가 while(q.empty) 이런식으로 알고 있는데... )
