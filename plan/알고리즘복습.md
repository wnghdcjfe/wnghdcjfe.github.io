
힘든일의 연속이다. 마음이 강해져야 한다.


종만북 복습과 카카오 기출복습입니다. 10번만에 대회 알고리즘 전반적으로 복습하는 것이며 10번의 포스팅이 될 것같습니다.


최소공배수

a * (b /gcd(a, b))로 큰 값을 미리 나눠서 오버플로우를 피할 수 있다.


사전적 정렬

string a = "abc";

string b = "acd";

lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());

true, false 로 그 앞에 있는지를 반환한다.


스캐폴딩

뼈대같은 코드


더해지더라도 괜찮은 int 형 최대값 987654321


문제 - 백준


14613번 : 처음의 dp를 1로 설정. i - 1, j로부터 생각해보자.

이기는 경우 : dp[i][j + 50] += dp[i - 1][j] * W

지 경우 : dp[i][j - 50] += dp[i - 1][j] * L

이기는 경우 : dp[i][j] += dp[i - 1][j] * D


1915번 : dp에는 최솟값만이 담긴다. 대각선 위, 위, 왼쪽을 보고 누적된 DP의 최솟값을 통해 지금의 DP를 만든다.

d[i][j] = min(min(d[i - 1][j - 1], d[i - 1][j]), d[i][j - 1]) + 1;


카카오기출

추석 트래픽

1. 시간 파싱 - 밀리세컨드로 통일

2. start = end - gap + 1

3. sort(start)

4. 이 start - 1000으로부터 추가하고 있는 end가 걸치는 지를 생각. y > start - 1000, y에는 end 지점을 놓는다.


컬러링북

1. 문제를 잘보자

2. BFS


브라이언의 고민

ㅇㅂㅇ..


4단고음

*++라는 형태를 만들어야 한다. *의 stack, +의 stack을 이용하면 된다. n 부터 시작해서 1로 가면서 n % 3 == 0이라면 나누는 식 Or n - 1 *를 할 때마다 +의 stack을 삭제시켜주어야 한다. 탐색이 불가능한 경우. +의 stack이 40이 넘어가는 경우이다. pow(3, 20) 이면 int의 최대 범위를 초과한다. 그 경우도 생각해주면 된다. 
 