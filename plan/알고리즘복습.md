
힘든일의 연속이다. 마음이 강해져야 한다.


## 공지
프로그래머스는 테스트하기가 어렵다. 

## 최소공배수
a * (b /gcd(a, b))로 큰 값을 미리 나눠서 오버플로우를 피할 수 있다.

## 사전적 정렬
string a = "abc";
string b = "acd";
lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
true, false 로 그 앞에 있는지를 반환한다.

  
# 문제 - 백준

## 14613번 : 처음의 dp를 1로 설정. i - 1, j로부터 생각해보자.

지금의 상태의확률 : 그 이전의 상태 * 지금의 확률

이기는 경우 : dp[i][j + 50] += dp[i - 1][j] * W
지는 경우 : dp[i][j - 50] += dp[i - 1][j] * L
이기는 경우 : dp[i][j] += dp[i - 1][j] * D


## 1915번 : dp에는 최솟값만이 담긴다. 대각선 위, 위, 왼쪽을 보고 누적된 DP의 최솟값을 통해 지금의 DP를 만든다.
d[i][j] = min(min(d[i - 1][j - 1], d[i - 1][j]), d[i][j - 1]) + 1;

# 카카오기출

## 추석 트래픽
1. 시간 파싱 - 밀리세컨드로 통일
2. start = end - gap + 1
3. sort(start)
4. 이 start - 1000으로부터 추가하고 있는 end가 걸치는 지를 생각. y > start - 1000, y에는 end 지점을 놓는다.


## 컬러링북
1. 문제를 잘보자
2. BFS

## 4단고음
1. *++라는 형태를 만들어야 한다.
2. n 부터 시작해서 1로 가면서 n % 3 == 0이라면 나눈다. *이 발생 == +의 stack을 2개 제거 / 그외에는 +의 stack을 증가 + n - 1
3. 탐색불가한 경우 : +의 stack이 40이 넘어가는 경우이다. pow(3, 20) 이면 int의 최대 범위를 초과한다. 그 경우도 생각해주면 된다. 
4. n == 1일 때 종료 return 1

## 보행자 천국
https://programmers.co.kr/learn/courses/30/lessons/1832
1. 반복적 동적계획법으로 한다. 
2. dp[y][x] = dp[y - 1][x] or dp[y][x - 1]이라는 등의 관계에 집중한다. 
3. 아래, 왼쪽 방향에 따라 배열 2개를 준비하면 된다. 

## 캠핑
https://programmers.co.kr/learn/courses/30/lessons/1833
1. x좌표끼리 Or y좌표끼리는 같지 않는다. 
2. 모조리 다 구해준다. for k = j ~ 0 중 i ~ k ~ j가 있다면 false

## 신비로운 유적탐험[복습필요]

## 단체사진찍기
https://programmers.co.kr/learn/courses/30/lessons/1835
1. map<char, int> pos;을 이용해서 하면 된다. 
2. 초기값들을 vector에다가 담아 놓고 next_permutation통해 돌려가며 하면 된다. 
3. 어차피 8!밖에 되지 않는다! 

## 리틀프렌즈 사천성
https://programmers.co.kr/learn/courses/30/lessons/1836
알파벳 순서대로 BFS를 연속해서 하면 되는데 아직은 잘 모름. 

## GPS
https://programmers.co.kr/learn/courses/30/lessons/1837
플로이드와샬인줄 알았는데 DP.. 

## 몸짱 트레이너[복습필요]
https://programmers.co.kr/learn/courses/30/lessons/1838
...

## 튜브의 소개팅[복습필요]
https://programmers.co.kr/learn/courses/30/lessons/1839
(m - 1) * 54 괄호처리하는 것을 주의하자. 
 
## 뉴스 클러스터링 
1. Set 그리고 정수변환을 신경쓰자. 
```js
const lower = str => str.toLowerCase();
const init = str => {
    let a = []
    const pattern = /[a-z]{2}/;  
    for (let i = 0; i < str.length - 1; i++) {
        //const partial_str = str[i] + str[i + 1]  
        const partial_str = str.substr(i, 2)
        if(pattern.test(partial_str)){ 
            a.push(partial_str) 
        } 
    }   
    return a;
}

function solution(str1, str2) {
    str1 = init(lower(str1))
    str2 = init(lower(str2)) 
    const _set = new Set([...str1, ...str2])
    let union =0; 
    let intersection = 0; 
    _set.forEach(item =>{
        const has1 = str1.filter(x => x === item).length; 
        const has2 = str2.filter(x => x === item).length; 
        union += Math.max(has1, has2)
        intersection +=  Math.min(has1, has2)
    })
    return union === 0 ? 65536 : ~~(intersection / union * 65536)   
}
```

## 셔틀버스
https://programmers.co.kr/learn/courses/30/lessons/17678
1. 09:40 ... 09:50 이라는 예외사항도 있다. 
2. 시간 sort는 반드시 변환을 해서 하자. 

## 프렌즈 4블록
https://programmers.co.kr/learn/courses/30/lessons/17679?language=javascript
1. 90도 회전
```js
for(let i = 0; i < cols; i++){
    for(let j = 0; j < rows; j++){ 
        matrix[i][j] = board[rows - j - 1][i];
    }
} 
```
2. 매트릭스 생성과 string 처리
```js
board = board.map(line =>line.split(""))
let matrix = Array.from(new Array(cols), () => Array.from(new Array(rows), () => 0)); 
```