# 1일차 
### 운영체제 의미
 - 운영 체제는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
 - 컴퓨터 자원을 효율적으로 관리하기 위한 시스템, 한정된 메모리 공간을 효율적으로 분배하는 참된 일꾼
 - 운영체제는 하드웨어와 소프트웨어를 관리하는 소프트웨어 전체
 이러한 운영체제는 어느 기기에서 어떠한 형태로도 나타날 수 있습니다. 비단 PC용 윈도우즈만이 운영체제가 아니고, MP3 플레이어를 켜면 전원이 들어와 장치를 깨우고 사용자의 명령에 따라 음악을 재생하는 동작들을 관리하는 것들도 전부 운영 체제라 할 수 있습니다. 단, 이런식으로 전자기기에 공장 출고시 설치되며 애플리케이션 설치를 통한 기능 추가를 할 수 없는 것은 보통 펌웨어(firmware)라고 부릅니다. 

### 운영체제의 역할
1. CPU 스케줄링
CPU를 어떤 프로세스에게 주는 것을 결정하는 것, CPU 소유권에 따라 해당 프로세스의 인스트럭션이 가능합니다.  
2. 메모리관리
한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는가를 관리 하는 것입니다. 
3. 디스크 파일 관리
디스크 파일을 어떻게 보관하는지에 대한 것입니다. 
4. I/O디바이스 관리
입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할까에 대한 것입니다. 

이외에도 프로세스관리, 프로세스의 생성과 삭제, 자원 할당 및 반환 등을 운영체제가 관리합니다. 
이 때 운영체제는 **인터럽트**에 의해 움직입니다.  
 - 인터럽트 : 마이크로 프로세서가 device관련 / 예외발생 처리요청이 들어오면 처리를 할 수 있게 해주는 것

## 컴퓨터 시스템 구조
CPU, DMA, Timer, Modebit, Device Controller로 이루어져 있습니다. 
### CPU
메모리, I/O 디바이스의 작게 설정되어있는 메모리인 로컬 버퍼에 접근하여 일을 합니다. 
 - 일이란 본인의 메모리주소에 맞는 딱 자기 할일만 하는 **인스터럭션**만 실행하는 것을 말합니다. 

프로세스(프로그램)가 요청할 때 메모리만 읽어들이면서 실행을 하는데 저 멀리 있는 I/O 디바이스에 요청을 할 때는 좀 다릅니다. 
이때는 새로이 인터럽트 라인을 설게 후 순차적인 인터럽트 실행을 중지하고 OS에 제어권을 주어서 OS에 **시스템 콜**을 요청해 원하는 디바이스로 향해 작은 로컬버퍼에 접근,원하는 요청을 합니다. 
 - 인스트럭션 : CPU에서 메모리를 통해 기계어를 읽는 것  

### 시스템콜
운영체제가 커널에 접근하기 위한 인터페이스이자 사용자 프로그램이 운영체제의 서비스를 받기 위해서 커널함수를 호출하는 것을 말합니다. 
 - 사용자프로그램이 I/O요청(**Trap**)이 들어오면 무조건 OS통해서 요청을 수행하게 되는데 이 때 커널함수를 통해 수행합니다. 
**Trap**발동시의 과정
1.인터럽트 벡터로 이동하여 제어권이 **인터럽트 벡터**가 가리키는 **인터럽트 서비스 루틴**으로 이동합니다. 
2. 올바른 I/O요청인지 확인 후 I/O 를 수행합니다. 
3. 그 이후 CPU의 제어권을 다음 명령으로 옮깁니다. 
 - 수행하는 과정에서 사용자모드와 커널모드(모니터모드)가 번갈아가면서 작동되는데 예를 들어 fs.readFile 이라는 함수가 작동되면 사용자모드에서 함수가 작동되고 파일을 읽을 때는 커널모드로 들어가서 읽고 다시 사용자모드로 돌아가서 그 밑의 로직을 수행하게 되는 것입니다. 
```
fs.readFile >> 
        유저모드 >>  >> 
=============시스템콜================
        커널모드   >> 
```
- 인터럽트 벡터 : 인터럽트 주소의 특정위치   
- 커널 : 운영체제의 핵심부분이자 보안, 자원관리, 추상화를 담당합니다.  

### DMA 컨트롤러, Direct Memory Access
메모리는 CPU만이 접근이 가능하고 하는 일도 많습니다. 
그렇기 때문에 CPU에게만 너무 많은 인터럽트요청이 들어오기 때문에 도와주는 일꾼인 DMA 컨트롤러를 두고 있습니다. 
 - 이 때, CPU와 DMA컨트롤러의 메모리 중첩 사용을 방지하기 위해 메모리 컨트롤러가 존재합니다. 

### Timer
CPU는 보통의 경우 프로그램들에 각각 할당량을 주면서 효율적으로 작동하는데 **무한루프등 소모량이 많은 프로그램**이 작동할 때를 방지하기 위해 타이머가 존재합니다. **몇세컨드안에 실행되어야 한다** 라는 것을 정하고 특정 프로그램에 시간제한을 다는 역할을 합니다. 

### modebit
지금 실행하는 프로그램이 사용자 프로그램인지 운영체제인지를 파악해주는 역할을 합니다. 
IO디바이스는 운영체제를 통해서만 작동해야 합니다. 
왜냐하면 사용자프로그램을 통해서만 운용된다면 카메라가 갑자기 켜지는 등 나쁜 짓을 할 수 있기 때문에 운영체제를 통해서만 작동할 수 있어야 하고 이를 위해 modebit이 존재합니다. 
 - modebit의 0, 모니터모드 1, 사용자모드를 통해 이를 관리
사용자모드일 경우에는 IO 디바이스에 시스템콜을 못하게 막습니다. 즉 **한정된 인스트럭션**만 가능하게 합니다.

### Device Controller
컴퓨터와 연결되어있는 IO디바이스들은 작은 CPU가 붙어있음 이를 컨트롤러라고 부르고 이 디바이스들의 작업공간, 메모리를 로컬 버퍼라고 부릅니다.   

### 인터럽트
현대의 운영체제는 **인터럽트**에 의해 구성됩니다. 인터럽트는 CPU에게 무언가를 알려주는 일을 하며 그렇게 해야할일들을 처리하며 OS가 동작합니다. 
인터럽트는 두가지로 나눠집니다. 
 1. 하드웨어 인터럽트
 2. 소프트웨어 인터럽트, Trap
 - Trap 은 프로그램 오류가 나거나 System call로 프로그램이 커널 함수를 호출, **시스템콜**을 하는 경우에 발동됩니다.
 - 과정 : 1) IO에 요청 2) 소프트웨어 인터럽트(Trap) 3) IO작업 종료 4) 하드웨어 인터럽트로 종료 알림   

## 메모리
### 메모리 구조 
| 이름 | 설명 |
|:--------|:--------|
| code | 시스템 콜, 인터럽트 처리 코드 등의 사용자코드 |
| data | 전역변수, 프로그램이 종료시에 사라짐 |
| heap & stack | 동적변수 & 지역변수, 함수가 할당 | 
| 커널영역 | 시스템 운영에 필요한 메모리 |  

### 메모리 계층 구조 
| 이름 | 역할 | 특징 |  
|:--------|:--------|:--------|
| 캐시메모리 | CPU와 RAM사이를 이어주는 역할 | 휘발성 |  
| 메인메모리 | 커널 RAM | 휘발성 |  
| SSD, HDD | 보조기억장치 | 비휘발성 |    

CPU와 하드디스크, 그리고 램 사이의 상관 관계
일반적인 컴퓨터 작업의 과정을 살펴보면, 램은 하드디스크로부터 일정량의 데이터를 복사해 임시 저장한 후, 이를 필요 시마다 CPU에 빠르게 전달하는 역할을 합니다. 이후부터는 속도가 느린 하드디스크는 배제하고 빠른 CPU와 램끼리만 데이터를 교환하므로 전반적인 작업을 고속으로 처리할 수 있습니다. 이러한 이유로, 하드디스크가 단순히 데이터를 보관하는 역할에 그치는데 비해, 램은 컴퓨터 전반의 성능에 미치는 바가 크다고 할 수 있습니다. 이에 따라 램은 주기억장치, 하드디스크는 보조기억장치로 분류된다.

일반적으로 컴퓨터 게임을 실행할 때 램과 하드디스크의 상관 관계를 확인할 수 있습니다. 게임을 처음 실행할 때, 또는 각 스테이지를 넘어가는 도중에 화면이 정지하며 ‘로딩 중(Now Loading)’, 혹은 ‘기다려 주세요(please wait)’ 등의 메시지가 나오는 것을 본 적이 있을 것이다. 여기서 말하는 ‘로딩(적재)’이라는 것이 하드디스크에서 데이터를 읽어 램으로 전송하는 과정을 의미합니다. 로딩이 끝나야 비로소 게임을 플레이 할 수 있습니다. 

## 프로세스
### 프로세스의 문맥
프로세스의 모든 상태를 나타내는 것을 프로세스의 문맥이라 합니다. 
1. 하드웨어 문맥
2. 주소 공간, code, data, stack
3. 프로세스 커널관련 자료구조, **PCB**(주소공간위치정보, Process Control Block) 

### 프로세스 상태의 종류
 - Running, CPU를 잡고 인스트럭션을 수행중인 상태 [active]
 - Ready, CPU를 기다리는 상태[active]
 - Blocked, 오래거리는 작업 중이라 CPU로 실행 못하는 상태[active]
 - Suspended, 메모리를 통째로 빼앗긴 상태[inactive]

### PCB, Process Control Block
운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보 
CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정에서 CPU는 CPU를 내어주는 프로세스의 상태를 그 프로세스 PCB에 저장을 하고 새롭게 얻는 프로세스 상태를 PCB에서 읽어옵니다. 
  1) Process ID
  2) CPU 수행 관련 하드웨어 값
  3) 메모리 관련 Code, data, Stack의 위치 정보
  4) 파일 관련  

### 쓰레드
프로세스가 만들어지면 [code, data, stack, heap]이 만들어지고 이를 관리하기 위해 **PCB**를 둡니다. 
이 **PCB**에는 쓰레드가 여러개 들어가 있습니다.  
[code, data, stack, heap]를 **각각** 생성하는 프로세스와는 달리 쓰레드는 stack을 제외한 정보를 **모두 공유**합니다. 
좀 더 자세히 말하면 쓰레드는 Program Counter, registers(CPU레지스터값), stack space는 별도로 유지하지만 data, code, heap을 공유합니다.  
 - Program Counter : 코드 어느부분을 가리키면서 실행하는 것에 대한 정보

동일한 일을 하는 프로세스는 독립적으로 있기 때문에 별도의 메모리 주소공간이 낭비되지만 쓰레드는 그렇지 않습니다. 
쓰레드는 프로세스 하나당 공유할 수 있는 것은 최대한 공유합니다. 
 - 메모리 주소공간 공유
 - 프로세스 상태 공유 
 - 쓰레드끼리도 공유, 이 때 동료 쓰레드와 공유하는 부분을 task라고 합니다.  

쓰레드는 lightweight process라 부르고 하나의 쓰레드만 가지고 있는 것을 heavyweight process라 합니다. 

쓰레드의 장점 
 1. 하나가 blocked하는 상태여도 다른 쓰레드는 running상태여서 빠른 처리를 할 수 있습니다. ex) WebSite Request시
 2. 동일한 일을 하는 도중 협력해서 처리를 하면 성능 향상을 얻을 수 있습니다. 
 3. CPU가 여러개 달린 컴퓨터에는 병렬성을 높일 수 있습니다. (계산시 하나당 맡아가지고 가능)

### 프로세스 생성, fork, exec
보통은 자식과 부모프로세스 생성시 자원을 공유하지 않습니다. 
 - fork : 자식이 부모의 주소공간을 그대로 복사하여 (binary & OS data) 새로운 프로세스 생성(복제생성) 
 - exec : 새로운 프로그램을 그 공간에 올릴 수 있습니다. 
두개의 프로세스 생성 과정은 독립적이며 이 모든게 시스템 콜을 통해 생성되며 부모가 OS에 요청을 해서 생성됩니다.   

## 프로세스 종료
### exit
프로세스의 마지막 명령 수행 후, OS에 알려준다. (자식이 부모에게 죽었다 알리며 자원을 모두 반납하고 죽는다.)
 - 자식이 먼저 죽고 부모가 그 다음에 죽는다. 
 - 프로그램에 안적어도 메인함수 리턴되는 위치에 컴파일러가 넣어준다. 

### abort
부모프로세스가 자식의 프로세스를 강제로 종료시킴
 - 자식이 할당된 자원의 한계치를 넘어섬
 - 자식에게 할당된 태스크가 더이상 필요하지 않음 
 - 부모가 종료할 경우 제거 된다. 
 - 키보드로 kill, break를 친경우 

### 프로레스 대기, wait
 자식프로세스의 일이 끝날 때까지 부모프로세스가 기다리는 과정

### 프로세스 간 협력
IPC, Inter Process Comunication
 1. 메시지패싱, 커널을 이용해 메시지 전달
메일박스 또는 포트를 통한 간접방식과 전달프로세스이름표기 직접방식
 2. 메모리 공유
쓰레드끼리는 메모리가 공유되기 때문에 완전한 협력이 가능 

## 2일차
### CPU Scheduling  
프로그램이 실행될 때 IO burst, CPU burst가 반복되서 일어나는데 이 때 누구에게 CPU를 줄 것인가를 결정하는 과정입니다. 어느 시점에서 실행되고 있는 프로세스는 단 한개이며 CPU는 여러개의 프로세스를 아주 빠른 속도로 번갈아 가며 실행하는데 누구에게 먼저 이 일꾼녀석을 줘야 할지를 결정하는 것입니다. 
  - IO burst, IO에서 인스트럭션을 하는 과정
  - CPU burst, CPU에서 인스트럭션을 하는 과정 
문맥교환, context switch
**인터럽트** 발생 후, 문맥교환으로 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 **커널**이 이전의 프로세스의 상태를 PCB에 보관하고 스케줄링 알고리즘에 따라 결정된 프로세스로 CPU제어권을 넘겨주는 것입니다. 

스케줄링 알고리즘은 두가지로 나눠집니다.  
**preemptive, 선점형방식**
현대 OS가 이를 씁니다. 현재의 프로세스를 쫓아내고 CPU소유권을 강제로 할당합니다.  
**nonpreemptive, 비선점형방식**
프로세스가 스스로 CPU 점유를 포기해야만 CPU소유권이 할당되는 방식, context switch overhead가 적습니다. 

### CPU 스케쥴링 알고리즘
매 CPU burst시 어떤 알고리즘을 써야 하는가를 결정하는 과정입니다. 그렇다면 어떤 알고리즘을 써야 할까요?
 - 이용률, CPU 이용률이 높아야 합니다.
 - 처리량, 주어진 시간에 많은 일을 해야 합니다. 
 - 소요시간, CPU를 쓰러 들어와서 IO를 하러 나갈 때까지의 시간이 짧아야 합니다.
 - 대기시간, ready queue에 있던 시간이 짧아야 합니다. 
 - 응답시간, 일을 시작해서 결과가 나오는 시간, 짧아야 합니다. 
 
#### FCFS, First Come, First Served [비선점형]
가장 먼저 온 것을 가장 먼저 처리하는 것입니다. 
길게 수행되는 프로세스 때문에 Convoy Effect, Queue에서 오래 기다리는 현상이 발생합니다. 
#### SJF, Shortest Job First[비선점형]
 - 가장 짧은 프로세스를 가장 먼저 스케쥴링 합니다. 
 - 긴 시간을 가진 프로세스가 실행이 안되는 현상, StarVation이 발생합니다. 
 - 평균 대기시간이 가장 짧습니다. 
 - 하지만 실제로는 CPU시간을 알 수 없기 때문에 과거의 CPU burst time의 흔적을 이용해 추측해내서 사용합니다.
 - Priority Scheduling의 일종입니다.  
#### Priority Scheduling[비선점형]
SJF의 StarVation을 Aging을 통해 단점을 보완한 것
 - 에이징 : 오래될수록 우선순위를 높여서 막을 수 있습니다.
#### RB / Round Robin 현대적 컴퓨터가 쓰는 스케쥴링[선점형]
Priority Scheduling의 일종으로 각 프로세스는 동일한 할당시간을 주고 그 시간안에 안끝나면 다시 ready queue 뒤로 갑니다. 
예를 들어 q만큼의 할당시간을 주었을 때 (n - 1)q시간이 지나면 자기 차례가 오게 됩니다. 
할당시간이 너무 크면 FCFS가 되고 짧으면 context switch의 잦음으로 인해 오버헤드,즉 비용이 커집니다. 
일반적으로 전체작업 시간은 길어지지만 평균 응답시간은 짧아진다는 특징이 있습니다. 

#### CPU 스케쥴링 알고리즘 평가방법
큐잉모델 : 확률분포로 큐에 도착하는 비율과 서비스가 끝난후의 비율을 비교해서 각종 퍼포먼스의 인덱스를 계산
구현 & 성능측정모델 : 실제 시스템에 적용시킨 알고리즘 구현, 실제작업성능 비교
모의실험모델 : 알고리즘 모의프로그램으로 구현 

### Deadlock, 교착상태 
 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 말합니다. 
 - 여기서 자원은 하드웨어, 소프트웨어적을 다 포함합니다. I/O, 메모리공간, semaphore(공유 공간) 등
 - 프로세스가 자원을 사용하는 절차도 포함 ex) request, allocate 
 자원할당을 하는 그래프를 보았을 때 cycle이 있다면 **deadlock**이 될 수도 있고, 없다면 아니다. 
 자원을 할당할 때 데드락에 연루되지 않은 할당된 자원들이 있다면 할당가능성을 보고 데드락이 아니라고 할 수 있습니다. 

**해결방법**
 1. 자원할당을 할 때 애초에 조건이 성립을 안하게 설계
 2. 데드락 가능성이 없을 때만 자원할당, 이 때 프로세스당 요청할 자원들의 최대치를 통해 자원할당가능 여부를 파악(banker's algorithm)
 3. 데드락 detection and recover
   - 사이클이 있는지를 발견[detection]
   - 모든 데드락관련 프로세스를 죽이거나 한개씩 데드락이 사라질 때까지 지워본다. [recover#1]
   - 데드락에 관련된, 비용을 최소화할 자원을 뺏어서 데드락을 없앤다.  [recover#2] 
 4. 무시(unix, window os 채택), 데드락은 매우 드물게 일어나기 때문에 데드락을 처리하는 비용이 더 크기때문입니다. 데드락이 발생되면 사용자가 작업종료를 합니다. 

### 메모리 관리
 - 논리적 주소, 프로그램 상 올라가 있는 주소, 프로세스마다 독립적으로 가지는 주소 공간
 - 물리적 주소, 메모리에 실제 올라가 있는 위치
이러한 논리적 주소와 물리적주소를 매핑하는 것을 **주소바인딩**이라고 합니다. 

주소바인딩 
예를 들어 함수명으로 호출하면 컴퓨터에서는 논리적주소와 물리적주소로 연결합니다.  
구조 : Symbolic Address(코드) - 논리적 주소 - 물리적 주소
#### 가상메모리 
프로세스들이 메모리 여유가 없이 지나치게 많은 요구를 할 경우 이를 방지하기 위해 가상메모리가 존재합니다. 
당장 사용하지 않는 영역을 하드디스크로 옮긴 뒤, 필요할 때만 램에 데이터를 불러와 올리고 사용하지 않으면 하드디스크로 내림으로써 램을 효과적으로 관리합니다. (스와핑)
메모리관리의 단순화, 각 프로세스마다 **가상메모리의 동일한 주소 공간**을 배정할 수 있으므로 메모리 관리가 단순해집니다. 
스와핑
물리적인 RAM의 허용치를 넘어설 경우 하드디스크 등 보조기억장치가 RAM의 대용이 되는데 이는 RAM보다 매우 느리기 때문에 RAM을 초과하는 데이터를 다뤄서 보조기억장치를 끌어다 쓸 경우 시스템의 속도가 확연히 느려집니다.
참고로 페이징은 주소변환입니다.
#### 물리적 메모리 할당 
메모리는 일반적으로 두가지로 나누어진다. 
 - OS 상주 영역, 낮은 주소 영역
 - 사용자 프로세스 영역, 높은 주소 영역 
여기서 사용자 프로세스 영역을 메모리 주소에 올릴 때 방법 나뉘는데 크게 **연속할당, 불연속할당**이 있습니다. 
#### 연속할당 
레지스터 2개(시작 메모리 위치, 메모리의 할당크기)를 통해서 할당합니다. 
1. 고정분할방식
분할의 크기를 미리 나눠서 할당합니다. 
2. 가변분할방식
프로그램이 실행될 때마다 차곡차곡 올려 놓는 방법입니다. size가 n이상인 hole을 찾아 할당하는 것입니다.  
- best-fit : n 이상인 공간 중 가장 작은 것 부터 할당
- first-fit : n 이상인 공간을 찾으면 바로 할당
- worst-fit : 가장 큰 hole을 찾으면 할당  

hole : 비어있는 메모리 공간
#### paging, 불연속할당 
현재의 컴퓨터가 쓰는 방법입니다. page별로 주소변환을 해야 하며 프로그램마다 페이지테이블을 가지고 있어야 합니다. 논리적 메모리를 동일한 크기의 paging으로 나눠서 물리적 메모리에 어디있는가를 결정합니다. 
테이블이라는 자료구조 특성상 위에서 부터 접근해야 하기 때문에 대신에 프로그램 주소 공간만큼 페이지가 생성이 되어야 합니다. 
 1. 논리적메모리를 동일한 크기의 page로 자릅니다. 보통 4kb 
 2. 매칭되는 페이지 테이블을 통해 주소변환이 되고 물리적메모리에 매핑됩니다. 
- 페이지테이블은 메인 메모리에 위치합니다. 때문에 프로그램에 대한 메모리에 접근하기 위해서 2번접근하게 됩니다. (그래도 빠릅니다.)
이 때 속도 향상을 위해 **TLB**가 사용됩니다. 

#### TLB
TLB는 별도의 하드웨어이며 메인메모리와 CPU사이에 있는 메모리 주소변환모듈입니다. 
메인메모리에서 캐싱메모리를 통해 빠르게 접근이 가능한 것처럼 메모리를 빠르게 전환하도록 사용되는 캐싱계층입니다. 
페이지테이블에 가기전에 TLB에 그 메모리가 있는지를 파악해서 빠르게 전달합니다. 이 페이지 테이블은 각각의 프로세스마다 페이지테이블이 존재하기 때문에 context switch시 비우게 됩니다.  

#### 이단계 페이지 테이블, Two-level Page table 
페이지테이블을 4kb에 할당하면 32비트 기준, 총 100만개의 주소공간만이 할당이 되는데 
 - 32비트 기준 2^32B, 4GB의 주소공간을 가집니다. 
그러나 대부분의 프로그램은 4G의 주소공간 중 지극히 일부분만 사용되므로 page table 공간이 심하게 낭비됩니다. 이를 다시 계층적인 page table 로 구성하여 바깥쪽 테이블과 안쪽 테이블을 활용한다면 공간 낭비를 줄일 수 있습니다. 
논리적인 주소는 p1 + p2 + d로 되어있습니다. 
 - p1 : outer page table - 10bit
 - p2 : page of page table - 10 bit
 - d : 그 안에서 몇번째를 나타내는 depth(page offset) - 12bit

안쪽 테이블은 4byte이므로 1k개를 집어 넣을 수 있으며 바깥쪽 테이블은 4kbyte이기 때문에 안쪽으로 많이 넣을 수 있습니다. 이 때 안쪽 테이블도 페이지화 되서 들어간다. 

page table의 엔트리마다 아래의 bit를 둡니다.
- protection bit, page에 대한 접근 권한(read / write / read-only)
코드는 read-only, 데이타들은 read, write 가능하게 설계됩니다.

이렇게 2단계 페이지를 만드는데도 효율성이 높아집니다. 
왜냐하면 바깥쪽 테이블만 만들고 안쪽테이블은 만들어지지 않는게 많기 때문입니다.

#### inverted page table
그렇게 해도 페이지 테이블은 너무나 클 수 있습니다. 프로세스마다 본인의 페이지테이블을 가지고 있기 때문입니다. 
많은 프로세스를 실행시키면 차지하는 메모리양이 늘어나게 되죠. 그렇기 때문에 나온 테이블이 바로 역 페이지 테이블, inverted page table입니다. 하나의 global 페이지 테이블을 갖고 프로세스를 구분할 수 있는 PID 정보와 page number 정보를 가지고 있습니다. 그렇게 실제 메모리 적재된 프레임의 주소만을 가지고 가상 주소로 매핑시킴으로써 메모리 크기를 줄입니다. 

즉, 물리적 주소에 관한 페이지 테이블입니다. 하지만 주소변환요청이 들어오면 페이지 엔트리를 전부다 검색해야 하는 단점이 있습니다.  
#### Shared Page
read - only 로 하여 프로세스 간에 하나의 code만 메모리에 올리는 것입니다. 
중복 코드가 있을 때 공유하는 페이지 기법입니다. 
코드가 동일하다면 동일한 논리적 메모리에 위치해야 합니다. 
**valid / invalid bit**으로 프로세스 내용이 있느냐 없느냐만 파악합니다. 
valid, invalid bit
사용되냐 안되냐를 위해서 사용되는 비트 

#### segmentation, 불연속할당
프로세스 주소공간은 의미단위로 쪼갭니다.(페이지처럼 동일한 크기가 아닙니다.)
segment number, offset 로 이루어져있으며 번호만큼 떨어진 위치로 가면 

1. limit(세그먼트의 길이) 
2. base(세그먼트 시작위치)

라는 구성의 의미단위로 자르기 때문에 길이가 다를 수 있습니다. 
그렇기 때문에 중간 중간에 hole들이 생깁니다.  
각 세그먼트 별로 Protection bit 이 있습니다.
길이가 다르므로 가변분할과 동일한 문제점 발생, 의미단위로 공유와 보안에 대해 효과적입니다. 

r, w, x 비트를 만들어 해당 세그먼트에 대한 접근 제어를 하는데 페이지는 같은 간격으로 자르는 대신 segmentation은 코드영역, 내용측면 등으로 잘라지기 때문에 그 기능을 수행하기 쉬워집니다.  code, data, stack 부분이 하나의 세그먼트로 이 엔트리는 사용하는 엔트리의 갯수만큼 만들어집니다. 

 - 운영체제는 메모리할당에 대해서 관여하지 않고 하드웨어적으로만 작동됩니다. 운영체제를 거치는 경우는 IO작업이 필요한 트랩의 경우에만 해당이 됩니다. 

#### segmentation & paging
공유나 보안은 세그먼트로 의미단위로 하고 물리적 메모리는 페이지로 하는 것을 말합니다.  

## 3일차
### Virtual memory
전적으로 가상메모리는 운영체제가 관리를 합니다. 
Demanding Paging, 실제로 필요한 메모리만 올립니다. 필요한 요청에 경우에만 올립니다.
 - 메모리 사용량 감소은 더 빠른 응답시간을 가져옵니다.
 - valid, invalid bit 사용 : 사용되지 않거나 페이지가 물리적페이지에 없는 경우 invalid이며 그렇지 않다면 valid로 설정해 놓습니다. 

### page fault
자신의 주소 공간에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말합니다.   이때의 과정은 다음과 같습니다.
```
1. 잘못된 요청인가 확인
2. 빈페이지를 가져오거나 replace를 합니다. 
3. 해당 페이지를 disk에서  memory로 읽어 온다.
4. 이 프로세스가 CPU를 잡고 다시 인스트럭션을 실행합니다. 
```
디스크는 메모리에 비해 수십만배 ~ 백만배 느리기 때문에 page fault가 많이 발생이 되면 느려지게 됩니다. 대부분의 경우는 메모리로부터 직접 주소변환이 가능하지만 꽉차 있거나 그러면 page fault가 발생하게 됩니다.
p : page fault rate 평소에는 0.1에 가깝습니다. 거의 일어나지 않습니다.
(1 - p) * 메모리 접근시간 + p(OS & HW page fault overhead, swap page, OS & HW restart overhead) 
 

### MMU
메모리 관리 장치(Memory Management Unit, 줄여서 MMU)는 CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품입니다. 

가상 메모리 주소를 실제 메모리 주소로 변환하며, 메모리 보호, 캐시 관리, 버스 중재 등의 역할을 담당합니다. CPU가 MMU에게 주소할당요청을 통해 메모리가 할당되게 됩니다. 

### 메모리 할당(allocate) 및 replace 과정
 1. 잘못된 참조요청인가 확인
 2. 빈 empty frame에 할당하고 아니라면 replace를 합니다. 
 3. 해당 페이지를 disk에서 memory로 읽어와서 작업재게  
할당이 안되면 replace를 하게 되는데 메모리 변환 과정(replace)시 **page-fault**를 최대한 줄이는 것으로 바꿔야 합니다.
 
#### offline-algorithm, optimal 
가장 먼 미래에 참조되는 페이지를 쫓아냅니다. 원래 있는 것 중에서 가장 먼 미래에 참조되는 페이지를 바꿉니다.사용할 수 없지만 다른 알고리즘 성능 비교에 대한 upper bound를 제공합니다. 이것보다 더 나은 방법이라는 것은 있을 수 없습니다. 
#### FIFO
메모리에 먼저 들어온 것을 먼저 쫓아냅니다. 메모리프레임을 늘려줘도 page fault가 증가하는 문제점 발생
#### LRU, Least Recently Used 
가장 오래된 참조를 바꾼다. 최근에 참조된 것들이 다시 참조될 가능성이 높기 때문이다. 
 - Linked list로 구현 O(1) 참조될 때마다 가장 아래쪽으로 매달고 요청할 때마다 가장 윗부분을 바꾸면 됩니다. 
#### LFU,Least Frequently Used
참조횟수가 제일 적은 것을 바꾼다.가장 적은 참조를 바꾼다. 참조횟수가 같다면 오래된 참조를 바꾸는 것이 좋다.
 - HEAP을 통해 O(logn) 구현 업데이트에 logn, 바꿀 때는 O(1) 
### clock 알고리즘
LRU의 근사 알고리즘으로 불린다. 최근에 사용되지 않은 프로세스를 쫓아 냅니다.
reference bit을 1로 설정, 최근에 참조되었다를 의미합니다. 시계방향을 돌면서 0을 찾아서 바꿉니다.
운영체제는 circular linked list를 사용하여 0을 찾아서 바꿉니다. 그리고 지나가면서 reference bit이 1인것은 0으로 바꿉니다.
 - modified bit : 최근에 변경된 페이지

#### COW
프로세스1과 프로세스2가 같은 자원을 활용하고 있을 때 그 자원을 수정하면 문제가 발생할 수 있다. 
이런 상황을 막기 위해 평소에는 같은 자원을 공유했지만 자원을 수정할 경우, 복사본을 쓰는 것이다. 
복사를 했지만 원래는 원본을 보여주며 그 데이타 수정을 가할 때 copy되는 것을 말합니다.

#### page frame의 allocation
어떤 프로그램이 원할하게 실행이 되려면 일련의 프로세스들이 같이 올라와 있어야 합니다. 
1. 모든 프로그램에 똑같은 갯수를 할당
2. 프로그램 크기에 비례 할당
3. 프로세스 우선순위에 따라 다르게 할당
#### Thrashing
page fault가 많이 일어나는 상황을 말합니다.(스와핑이 많이 일어나는 경우) 프로세스에게 너무 적은 page를 할당받은 경우 발생합니다.
메모리에 너무 많은 프로세스가 동시에 올라가게 되면 동시에 올라가는 메모리 갯수를 조절해줘야 합니다. 이를 위한 알고리즘은 다음과 같습니다. 
#### working-set
프로세스는 특정시간 동안 일정페이지만 집중적으로 참조함, 이를 locality set이라 합니다.
이를 기반으로 한꺼번에 올라와있어야 하는 페이지들의 집합을 working set이라고 합니다. 
과거를 통해 working-set을 참조합니다.
#### page fault frequency algorithm 
상한값과 하한값으로 조절하여 그 안에서 page fault rate에 따라서 페이지 갯수를 조절합니다.

## FILE
관련정보를 이름을 가지고 저장하는 것. 
다양한 저장장치를 file 이라는 논리적 단위로 볼 수 있게 해준다. 
파일을 읽게 되면 순차적으로 위치포인터가 이동해가며 읽게 된다.
Operation : create, read, write, open, close

#### open()
이 파일의 메타데이타를 메모리에 올려놓는 과정을 말합니다.

1) Open[사용자 메모리영역]
2) 시스템콜 > 운영체제로 넘어간다. [커널 메모리영역]
3) root의 metadata를 올린다. [커널 메모리영역]
4) root의 content의 해당 메타데이타가 있어서 메타데이타를 메모리영역에 올리며 순차적으로 찾아간다.[커널 메모리영역]
5) 해당 디렉토리의 meta 데이타를 찾게 되면 그 파일의 메타데이터의 포인터가 몇 번째 인덱스 (file descriptor)인 것을 반환하게 됩니다. 

이 때 똑같은 파일을 두번 요청하게 되면 **메모리영역**에 미리 올려 놓은 것을 리턴하게 됩니다.
이것을 버퍼캐싱이라고 합니다.
이 때, 메타데이타를 디스크에서 메모리에 올려 놓게 되면 현재 이 프로세스가 이 파일의 어느 위치, offset을 참조하고 있는가를 나타내는 데이타가 필요합니다. 

### File Protection 방법
누구에게 read, write, execution 을 허락할 것인가를 정하는 방법입니다. 
#### Access control Matrix
행 : user, 열 : file에 대해서 권한을 사용해서 하는 방법
#### Grouping
전체 user을 owner, group, pulic의 세 그 룹으로 구분하여 3비트씩으로 표시 (UNIX)
#### Password
파일마다 password를 두는 방법입니다.

#### file attribute, 메타데이터
파일을 관리하기 위한 각종 정보들
#### file system
운영체제에서 파일을 관리하는 부분
파일 및 파일의 메타데이타 등을 관리 
파일의 저장 방법을 결정 
#### Directory
파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일
 - 파일 이름, 파일 attribute를 담고 있습니다.
search / create / delete / list a diretory / rename / traverse the File System
#### Partition(= Logical Disk)
하나의 디스크 안에 여러 파티션을 두는게 일반적입니다.
여러 개의 물리적 디스크를 하나의 파티션으로 구성합니다.
파티션에 file system을 깔꺼나 swap area 로 사용할 수 있습니다.
만약에 다른 파티션에 있는 (다른 디스크)에 접근하기 위해서는 mounting을 하면 됩니다.

파티션간 mount
특정 디렉토리에 파일시스템을 탑재하는 것을 말합니다. 
리눅스 파일 단위로 모든 장치를 관리, 새롭게 만든 파일 시스템을 사용하기 위해서는 디스크장치에 임의의 디렉토리에 마운트 시켜 사용해야 합니다. 

### 파일을 디스크에 저장하는 방법
#### Contiguous Allocation 연속할당
파일들은 start와 length를 가지고 있는데 순차적으로 할당, 즉 인접하게 비어있는 부분에 할당을 합니다. 
그러나 파일이 삭제가 되면 외부조각이 발생할 수 있습니다. 

장점
1. 한 번 이동시 많은 바이트를 할당할 수 있습니다. 
2. Direct Access 가능
3. 많은 양의 데이터를 한꺼번에 받아올 수 있습니다.  
4. 리얼타임 파일용으로 사용하면 된다.  

단점
1. 외부조각, externel segment, 내용이 들어있지 않은 빈공간과 파일과 파일 사이의 블록 사이에 비어있는데 들어가려는 파일의 크기가 그것보다 커서 들어가지 않는 현상이 발생합니다. 
2. 그리고 파일이 커질 때 반응하기가 어려습니다.즉, file 하나의 크기를 어느정도로 설정해놓아야 하는가에 대한 결정부분과 그부분을 해소 또는 문제가 발생합니다. 

#### Linked Allocation
파일의 데이타는 빈위치면 아무렇게나 들어가도 됩니다. 하지만 중간위치를 보려면 다 탐색을 해야 하는 단점이 있습니다. 포인터를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어트립니다.


#### Indexed allocation
먼저 디렉토리가 가지고 있는 인덱스 블록을 가리키게 합니다.
외부조각이 생기지 않고 직접접근이 가능합니다.
index 블록이 필요합니다.
하지만 매우 작은 파일의 경우 공간을 낭비합니다.
그러나 매우 큰 파일의 경우 인덱스에 Linked List를 걸면 됩니다. 
 
## 유닉스의 파일시스템 구조
가장 기본적인 파일시스템 구조
```
Boot block
Super block
Inode list
Data block
```
#### Boot block
부팅에 필요한 정보가 0번에 저장이 되어있습니다.
#### Super block
파일시스템에 관한 총체적인 정보를 담고 있습니다. 
#### Inode List
파일 하나당 Inode 하나가 저장이 된다. 
파일이름을 제외한 파일의 모든 메의 메타데이타는 디렉토리에 저장된다.  
실제로 파일의 메타데이타는 디렉토리 일부에만 저장되고 대부분의 메타데이타는 여기에 저장된다. 
#### Data block
파일의 실제 내용을 보관합니다.  file이름 + Inode번호

### Indexed allocation 
파일의 크기에 따라 순차적으로 index가 주어집니다. (효율적)

Direct index : 파일의 위치를 가리킨다. 
Single index : 실제파일의 내용을 가리키는
double indirect : 실제파일의 위치를 가리키는 
그 보다 더 큰 파일은 tuple indirect로 가리킵니다. 

### FAT File System
```
Boot block
FAT
Root Directory
Data blcok
```
#### Boot block
부팅과 관련된 정보를 담고 
#### FAT
파일의 메타시스템 중 일부를 담는다. (위치정보)
EOF로 파일의 끝나는 위치를 담고 있습니다. 
파일의 직접적 접근이 가능하다. 
#### Root directory 
위치정보가 있습니다. 
#### Data block
파일의 시작위치를 담고 있습니다. 
파일의 이름을 비롯한 것들을 디렉토리가 다 가지고 있습니다. 
FAT이라는 테이블의 Data Block에 그 다음 파일을 알 수 있는 정보가 있습니다. 

### Free-Space Management
비어있는 블락의 관리법
#### 비트맵, bitmap
각각의 블록별로 번호로 비트를 둬서 사용중이냐 비어있느냐를 0 또는 1로 표기를 합니다. 
부가적인 공간을 필요로 하며 연속적인 n개의 free block을 찾는데 효과적입니다. 
#### Linked list
모든 free block들을 링크로 연결  
비어있는 블록의 첫번째 위치만 포인터로 남겨 놓습니다. 
추가적인 공간 낭비는 없고, 연속적인 빈공간을 찾기가 어렵다. 
#### Grouping
Linked List 방법의 변형
첫번째 Free block이 n개의 pointer를 가집니다. 
n - 1 pointer, 마지막 포인터가 가리키는 block은 또 다시  free data block을 가리킴
### Counting
프로그램들이 종종 여러개의 연속적인 block을 할당하고 반납한다는 성질에 착안
빈블록의 위치리를 가리키고 그것들이 몇개를 가리킨다. 

### Directory Implementation
디렉토리의 구현입니다.
#### Linear List
파일들을 순차적으로 저장
디렉토리 내 파일이 있는지 찾기 위해서 linear search 가 필요
#### Hash Table
Linear List + hashing
Hash table은 파일이름을 파일의 Linked List의 위치로 바꿔줍니다. 
search time을 없애며 collision이 발생할 수 있습니다.
#### File의 metadata의 보관위치
디렉토리내에 직접보관을 한다고 했지만 사실은.. 
디렉토리 내에 직접 보관을 하지 않고 포인터를 두고 다른 곳에 보관합니다. inode, FAT 등
#### File 이름 관리 
각 list에서 각 entry는 일반적으로 고정되어 있습니다.
파일이름에 해당하는 길이를 어느정도로 해놓고 길어서 벗어난다면 pointer를 둬서 저장되도록 합니다.

### Page Cache and Buffer Cache
#### Page Cache
가상메모리에서 페이징 시스템에서 사용하는 page frame을 caching의 관점에서 설명하는 용어
swap area에 올라와있나 안올라와 있나 캐싱을 사용하나. 
#### buffer Cache
파일을 읽을 때 운영체제가 자신의 영역 중 일부에 저장을 해놓고 나중에 다시 요청을 하면 버퍼캐시를 해준다. 페이지로 관리를 합니다. 
똑같은 페이지 단위4kb를 씁니다. 
#### Unified Buffer Cache
최근의 OS는 buffer cache도 페이지 단위로 합니다. 
그리고 같이 page cache에 통합되어 관리를 합니다. 

### Memory - Mapped I/O
파일의 일정부분을 가상메모리에 매핑을 해서 메모리 직접연산을 통해서 
메모리 접근하는 연산을 통해 파일 입출력을 수행하게 합니다.   
물리적메모리에 있는 내용을 카피해서 쓰는게 file read & write call이고
물리적메모리와 가상메모리를 매핑하여 쓰는것이 MMAP,  Memory - Mapped I/O
시스템콜을 하지 않고 메모리를 통해 접근하기 때문에 효율이 높다. 
한번의 메모리카피가 줄어들다. 

### Disk 관리 및 스케쥴링
디스크는 sector라는 최소 단위로 관리한다. 
디스크 스케쥴링 
Logical block
 - 디스크의 외부에서 보는 디스크의 단위정보 저장 공간들
 - 주소를 가진 1차원 배열처럼 취급
 - 정보를 전송하는 최소 단위 
Sector
 - Logical block이 물리적인 디스크에 매핑된 위치
 - Sector 0 은 최외곽 실린더의 첫 트랙에 있는 첫번째 섹터이다.  
디스크 관리 
 - 디스크를 컨트롤러가 일고 쓸 수 있도록 섹터들로 나누는 과정
 - header + data + trailer로 구성 
 - 메타데이터가 header, trailer를 생각하면 됨 
partitioning, 파티셔닝
 - 디스크를 하나 이상의 실런더 그룹으로 나누는 과정 C, D드라이브 나누는 것
 - OS는 각각의 독립적 disk로 관리
logical formatting 
 - 파일시스템을 만드는 것

#### Booting
 - ROM에 있는 small boostrap loader를 실행
 - sector 0을 load하여 실행
 - sector 0은 full Bootstrap loader program 
 - OS를 디스크에서 load하여 실행
여러원판들이 쌓여 있는 것을 상상
Access time, 디스크에 접근하는 시간
 - seek time : 헤드를 해당 실린더로 움직이는데 걸리는 시간
 - rotatinal latency : 헤드가 원하는 섹터에 도달하기까지 걸리는 회전지연 시간
 - Transfer time : 실제 데이터의 전송시간 
Disk bandwidth
 - 단위 시간 당 전송된 바이트의 수

#### Disk Scheduling 
 - seek time을 최소화 하는 것이 목표 : 요청을 최소화하는 것이 목표

디스크 스케줄링 알고리즘
queue가 98, 183, 37, 122, 14, 124, 65, 67로 들어왔을 때

FCFS   : 들어오는 순서대로 처리 

SSTF   : Shortest Seek Time First, 가장 짧게 갈 수 있는 것을 먼저 계산 현재의 head로 부터 가장 짧은 것을 탐색한다. 

SCAN   : 한쪽끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리(와리가리)

C-SCAN : 한쪽 방향으로 끝까지 가고, 그리고 다시 한쪽방향 처음으로 가서 스캔

LOOK & C-LOOK : 스캔을 하다가 그 방향에 처리할 요청이 없다면 방향을 바꾼다.  제일 낮은 주소로 가서 다시 탐색(이게 가장 효율적인 것으로 알려져있음)

#### Swap - Space Management
Disk를 사용하는 두가지 이유
 - 메모리의 휘발성한 이유로 파일시스템
 - 프로그램 실행을 위한 메모리 공간 부족
Swap-space 
 - 가상메모리에서는 디스크를 메모리의 연장 공간으로 사용
 - 파일시스템 내부에 둘 수도 있으니 별도 파티션 사용이 일반적
 별도의 파티션을 둬서 둠, 속도 효율성이 우선 

#### RAID
여러개의 디스크를 묶어서 사용하는 것
- 분산저장, 병렬적으로 읽어올 수 있다. interleaving, striping
- 중복저장 : 신뢰성 향상, Mirroring, shadowing이라고 한다. 

