# 질문사항
 - 안경잡이 개발자 : https://ndb796.tistory.com
 - DS 그래프 개발자 : https://qpakzk.github.io/software-notes/2018/09/20/DS-Graph/

## 나에 대한 질문들 모음

### Q. 다른 지원한 곳은?
솔직히 말씀드리자면 저는 라인, 카카오, 네이버 이렇게 3가지를 지원했습니다. 카카오의 경우 떨어졌고 네이버의 경우 서류합격을 기다리고 있는 상태입니다. 하지만 이 3개가 모두 붙는다고 할 경우에도 저는 라인을 선택할것입니다. 왜냐하면 라인은 이 3개의 기업중 최고로 도전적이며 글로벌환경에서 서비스를 한다는 게 매력적이기 때문입니다. 

라인은 인도네시아 고젝과 제휴를 하고, 라인페이, 라인렌즈, 라인 토큰 이코노미, 라인뮤직, 라인만화 등 여러가지 방면에서 글로벌적으로 도전을 하고 있기 때문입니다.

 > 라인 토큰 이코노미 : 언체인, 블록체인랩, 언블락, 비트박스

저는 세계로 나아가는 도전적인 개발자가 되고 싶고 그 출발점이 저는 라인이고 싶습니다. 지금 지원하는 SDK, 라이브러리 제작은 정말 재밌을 것같고 또 제가 잘하는 분야라고 생각하니다. 저를 뽑아주시면 정말 열심히 스스로 배우고 열심히 노력하겠습니다. 감사합니다. 

### Q. 자기소개
#### 버전1
대학교 재학시절 강의평을 공유할 수 있는 강의평가페이지를 만들고 이어 커뮤니티를 개발하여 2년동안 운영했습니다. 이후 공군장교에 들어가 기상정보지원체계란 신규프로젝트의 PL이 되어 2년동안 6명의 팀원과 함께 개발했습니다. 장교시절 항상 책임감을 가지고 열심히 개발에 임했고 그 이유로 단기장교는 받기 힘든 국가유공자상★★★을 받기도 하였습니다.  

코드 하나하나 확장성, 다형성, 표준화 등을 고려하며 짜며 성능이 좋은 함수, 로직을 고민하는 습관을 가지고 있습니다. 꾸준히 좋은 알고리즘을 현업에 적용시키려고 노력하고 실제 현업에 메모이제이션, 피벗알고리즘을 적용시켜 트러블슈팅해결 및 성능을 향상시킨 적도 있습니다.
 
업무외에 책을 읽고 독후감 쓰는 것과 기술을 알기 쉽게 알려주는 것을 좋아해 블로그와 유투브를 운영하고 있으며 새로운 기술로 미니 프로젝트를 진행하는 것을 좋아해 이를 기반으로 IOT대회에서 웨어러블 IOT기기를 만들어 상을 타기도 하였습니다.  
 

### Q. 마지막 할 말
저는 공주대학생 시절부터 제가 살아온, 제 주위의 삶을 바꾸고자 노력했습니다. 혼자 인터넷보고 정리되지 않은 지식을 정리해 블로그에 올리고 강의평들을 공유하고자 강의평가홈페이지를 만들었습니다. 그리고 공군에 와서는 수동적인 것들을 자동화 시스템으로 바꾸는데 열중했습니다. 저의 이 노력들이 이곳에 녹아들어 또 한번 바꾸고 싶습니다.  
그리고 코드리뷰할 때는 정말 엄격하게 지적을 하고 협업을 할 때는 누구나 다 저랑 같이 협업하고 싶을 정도의 실력과 남의 말을 잘 듣는 개발자 그리고 퇴근 후 같이 술한잔하고 롤할 수 있는 그런 친근하고 친구같은 개발자가 되어 함께하고 싶습니다.  

### Q. 수상 경험 
가장 대표적인것은 군장병 SW 캠프 개발대회 공군 참모총장상입니다. IOT에 관한 기사가 많이 뜰 때쯤 호기심이 생겨서 업무가 끝나고 숙소에 돌아와 IOT에 대해 공부를 꾸준히 진행했습니다.  라즈베리파이를 사서 온도센서를 연결하고 모니터에 그 센서값을 표출하는 미니 프로젝트를 진행하였고 그 이후 대한민국 군장병 SW 개발대회 IOT 부분에 참가하게 되어 체력검정 때 사망하는 병사나 간부들을 위해 실시간으로 심장박동수를 점검해주고 감시하는 웨어러블한 IOT기기, 하트세이버를 만들었습니다.

### Q. 1등을 하게 된 계기 및 큰 요인은 뭐라 생각해?
해커톤을 하기전 어떤 아이템이 좋을까 한달정도 생각했습니다. 군대에서 체력검정을 하는데 사망하는 사건들이 종종 있었고 이것을 기술로 풀어보면 어떨까 생각을 했습니다. 그리고 해커톤당일이 되었습니다. 

해커톤 총 5일이 주어지는데 처음에 가장 중요한게 팀을 짜는 것이라 생각을 했습니다. 처음모인 강당에서 대회장소로 가는 내내 병사들에게 어느정도 할 수 있느냐 뭘 잘하느냐 라고 질문해가며 팀을 모았습니다. 결국 저희팀은 1. 삼성개발자 1, 포항공대학생1, 연대컴공1 그리고 저로 이루어진 팀을 이룰 수 있었고 분업화도 잘되어 프로젝트가 진행하였습니다. 

저는 차트 및 화면을 표출하는 프론트엔드와 node.js로 만들어진 백엔드서버를 개발했으며 다른 팀원들은 PPT담당, 아두이노 & 센서 담당, 파이썬으로 통신모듈담당으로 나눠져 개발을 진행했습니다. 개개인의 심박수 임계치를 설정하여 그 임계치를 기반으로 심박수를 모니터하고 자각인지를 하는 웨어러블 IOT기기를 만들었습니다. 
(심박수 센서가 없어 온도센서로 모의구현하였습니다.)

1. 처음에 패스를 아두이노에 대면 RFID를 통해 군번을 읽어옵니다. 
2. 군번에 해당하는 나이, 이름, 병력값을 파이썬으로 짠 통신모듈을 통해 SQLLITE DB에서 긁어 옵니다. 이 DB는 인트라넷 DB를 가리킵니다. 
3. 이를 바탕으로 임계점을 설정합니다. (최대 : 220 - 나이 - 질병인덱스, 최소 : 60)
4. 심박도센서값이 파이썬 통신모듈로 전해지게 되고, 이를 바탕으로 파이썬 통신 모듈에서 위험한지 안한지를 판단합니다. 
5. 판단한 후, 위험하다면 아두이노로 보내어 LED센서와 진동센서를 작동시킵니다. 
6. 동시에, 파이썬 통신모듈을 통해 NODE.JS 서버로 이름, 나이, 센서 등의 값을 보냅니다. 
7. 이를 바탕으로 Client와 소켓연결, 데이타를 클라이언트로 전송하여 실시간 모니터링을 구현합니다. 

### Q. 프로젝트 진행시 가장 중요시 여기는 부분
요구사항, 성능 그리고 유지보수성입니다. 일단 요구사항이 제일 중요합니다. 효율적인 회의와 상대방이 무엇을 원하는지 상세히 조금 더 상세히 알 필요가 있습니다. 운동화끈을 묶을 때 처음 묶는 끈이 가장 중요하듯 개발에 있어서는 요구사항을 제대로 정립하는 것이 제일 중요합니다.  

그리고 그 다음은 성능입니다. 성능은 3가지로 이루어집니다. 어떤 것을 쓰느냐, 얼마나 선언하느냐, 어떻게 구성하느냐.입니다. 
1. 어떤것을 쓰느냐. 예를 들어 정수형으로 바꿔야 할 것이 있습니다. 대표적인 자바스크립트의 메소드는 parseInt가 있습니다. 하지만 물결표시 비트 연산자 2번을 쓰면 똑같이 정수형으로 만들 수 있습니다. (비트연산자의 결과는 정수형입니다. 이는 자바, 자바스크립트 모두 다 그렇습니다.)

2. 얼마나 선언하느냐. new Date같은 객체를 여러번 쓰는 것보다 조금 쓰는 것이 좋습니다. 이외에도 불필요한 객체선언으로 인한 메모리낭비는 없어야 합니다. 

3. 어떻게 구성하느냐. 이는 시간복잡도와 공간복잡도를 줄이는 것이 말합니다. 저는 원격통합표출체계 프로젝트에서 이미지 리스트를 추출하는 로직에서 시간복잡도가 n * m 이였는데 이를 피벗알고리즘을 적용하여 n 으로 줄인 사례와 기상정보지원체계 개발당시 메모이제이션을 이용해 서버요청을 85%이상 줄인 사례가 있습니다.  
이런식으로 성능을 올릴 수가 있습니다. 
그리고 이뿐만 아니라 프로젝트를 구성하는 기술을 구성하는 시작단계의 고민을 곁들여야 합니다.  
예를 들어 보안이 필요한 데이터를 전송할 때 단방향으로 전송할 수 있고, JWT를 이용해 전송할 수 있고, HTTPS를 사용하거나 등을 이용할 수 있습니다. 이러한 고민은 필수입니다.

마지막으로 유지보수성입니다. 유지보수성을 올리기위해서는 모듈화는 기본이며 간단하고 명료하게 짜야 합니다. 그리고 팀워들끼리 어떻게 짜야 할 것인지를 통일하는 것이 중요합니다. 예를 들어 vue.js의 shortcut 메서드를 쓸 것인지 아닌지, margin : 0 px 는 margin: 0으로 쓸 것인지 아닌지, flex를 어느 부분에 쓸건지 등을 정확히 정하는 것이 추후 유지보수성을 증대시킬 수 있습니다. 프로그래머마다 다양한 코드스타일이 있지만 프로젝트를 할 때 어느정도는 통일을 시켜야합니다.  
또한 저는 특히 자바스크립트로 만드는 프로젝트라면 함수형 프로그래밍 패러다임을 기본으로 개발할 것을 추천합니다.  함수형프로그래밍은 전역변수를 최소화시키고 부수효과를 최소화하며 그리고 작은 함수들로 구성된 로직이 기본입니다. 이러한 것들은 유지보수성을 증대시킵니다. 아무리 복잡한 로직이라고 작은 로직들로 이루어진다면 추후 요구사항에 대해 빠르게 대처할 수 있습니다. 그리고 함수형프로그래밍의 지연평가를 통해 성능을 향상시킬 수 있으며 동시성처리에 해당하는 것도 쉽게 만들 수가 있고 다형성을 통해 재사용성을 높일 수 있으며 null, undefined처리도 쉽게 할 수 있습니다. 

이 3가지가 저의 개발철학이며 개발시 꼭 지켜야 한다고 생각하는 것들입니다.  
 
### Q. 기술적인 도전
2017년 3월, 처음 기상정보지원체계를 개발할 당시 아키텍처를 설계하는 일이였습니다. 클라이언트 프레임워크를 선택할 때 당시 React, Angular의 양대산맥구조로 이루어져있었고 Vue.js는 뜨고 있는 상황이였고 인지도도 없었습니다. 좀 더 정확한 결정을 위해서 일주일만에 그 상황에서 그 3가지로 간단한 소개 웹앱을 다 만들어 러닝커브, 성능, 초기구축 어떤게 좋았나 고민을 했고 Vue.js를 도입해 성공적으로 잘 만들게 되었습니다.  

### Q. 장점
호기심, 바른방향의 열정, 꼼꼼함입니다. 
먼저 호기심이 생기면 빠르게 미니프로젝트를 진행해서 이게 뭔지 알고자 했습니다. IOT, 딥러닝, 머신러닝에 대해 관심이 생겼을 때 온도센서표출 프로그램, LSTM 온도예측을 만들기도 했습니다. 이러한 호기심으로 인한 활동들덕에 그 이후 대회에서 좋은 성적을 거뒀다고 생각합니다. 

두번째는 바른방향의 열정입니다. 군대에서는 빠르게 개발을 하라고 하는 압박감, 그리고 기능만 되면 되는 것이다 라는 주의가 만연했습니다. 이 상황에서 바른 방향의 개발문화를 가지고자 노력했습니다. 함수형 프로그래밍을 도입시키고 모듈화, 오픈된 코드리뷰를 통한 버그 수정및 유지보수성 증가로 정말 후대에 좋은 코드를 남겨주자는 노력으로 열정적으로 나아갔습니다. 

세번째는 꼼꼼함입니다. 코드하나하나 정말 이 함수를 사용해도 되는 것인지. 아닌지에 대한 고민을 하고 이렇게 구조를 짜서 해도 되는지에 대한 고민을 많이 했습니다. 

### Q. 단점
1. 자만심이 생기는 버릇이 있습니다. 지속적인 자극이 없으면 자만해져서 공부를 안하게 됩니다. 그래서 주기적으로 세미나를 참가하고 있으며 알고리즘 공부로 "세상은 넓고 배울 것이 많다"라는 것의 대한 주기적인 자극을 받으려고 하고 있습니다. 

2. 자신의 지식에 대한 강한 믿음으로 가끔 보수적.. 세미콜론을 항상 써야 되는줄 알았지만 안 써도되고 안써도 된다는 진영과 써야 한다는 진영에서 맞붙고 있으며 써도 되고 안 써도 되는 결과가 나왔습니다. 
또한, nightmare.js를 이용해 해커톤을 나가서 자동로그인 및 메일 확인 시스템을 만드려고 했는데 알고보니 창이 띄워지는 이벤트 발생시 그 창으로 포커싱이 안되는 기술적한계발생했습니다. 좀 더 차분히 준비를 해야 하는데 덜렁거릴 때가 있습니다.    

3. 다양한 환경에서의 경험이 부족하다 생각합니다. 작전지원적인 부분에 있어 안정적인 부분과 커스터마이징 부분에 있어서 노력했지만 다양한 환경, 낮은 버전의 브라우저, 다양한 단말기에 있어서 경험이 떨어집니다.

### Q. 개발 지식 쌓는 방법
먼저 구글로 해당키워드를 한글로 검색 후 10개정도의 페이지를 연다음 정리를 하고
그걸 기반으로 다시 영어로 검색 후 10개 정도의 페이지를 열어서 정리를 하고 좀 더 부족함을 느낀다면 그것에 관한 책을 사서 미니프로젝트를 진행하면서 공부를 했습니다. 


### Q. 지원한 이유, 포부
#### [기업의장점]
카카오뱅크는 혁신이라고 생각합니다. 저는 줄곧 왜 이렇게 계좌이체나 은행 업무가 복잡하고 까다롭지? 이런 것들을 해결할 무언가가 나타나 주면 안되냐고 바랬던 사람이었습니다. 그 후 카카오뱅크가 나타났습니다. 혁신적으로 계좌이체가 간편하고 적금까지 오프라인으로 은행을 거치지 않고 온라인으로만 해결하는 그러면서도 은행지점을 설치했을 때의 비용을 줄여 고객에게 만족감을 주는 가치로 변환시킨다는 것이 매력적이었습니다.
이렇게 멋지게 세상을 바꾸고 도전적인 카카오뱅크는 저에게 꿈이자 미래입니다. 저도 여기에 동참하여 세상을 바꾸고 싶습니다.

저는 웹 개발자이며 알고리즘을 공부하고 이 알고리즘을 어떻게 하면 웹앱에 녹일까하는 사람입니다. 또한 시각화 라이브러리인 D3. js 에 특화된 기술을 가지고 있어 시각화도 잘 해냅니다. 그리고 꼼꼼한 코드 최적화 및 안정화에 관심이 많습니다. 이러한 제 강점을 기반으로 사내 서비스나 좀 더 도전적인 플랫폼 기술파트에 있어 알고리즘으로 시간복잡도를 줄여 좀 더 효율적이고 성능이 좋은 무언가를 만들어내고 시각화가 필요한 부분에 있어 앞장서서 시각화를 하고 코드 최적화를 통해 좀 더 아름다운 코드, 안정성 높은 코드를 만들어 내 플랫폼 기술파트에 있어 뿌리 깊은 나무가 되고 싶습니다.

### Q. 너의 역량, 그리고 장점, 그리고 여기서 할것들. 
첫 번째, 저는 도전적인 사람입니다. 어떠한 기술이 있다면 그걸 미니 프로젝트를 통해 구현하고 배우는 사람입니다. IOT가 한창일 때 IOT를 배우고 미니프로젝트를 진행해서 상을 탄 경험이 있으며, 딥러닝이 한창일 때 LSTM 모델을 만들어 대회에 나간 적이 있습니다. 그리고 Spring도 배워서 간단한 CRUD 예제 또한 만든 적이 있습니다. 언어에서도 PHP, java, python, c++ 가리지 않고 많은 언어를 배우고 도전합니다. 이 도전적인 정신은 실무에서도 이어진 경험이 있습니다.

2017년 3월, 처음 기상정보지원체계를 개발할 당시 클라이언트 프레임워크를 선택할 때 당시 React, Angular의 양대 산맥구조로 이루어져 있었고 Vue·js는 뜨고 있는 상황이었고 인지도도 없었습니다. 좀 더 정확한 결정을 위해서 2주일 만에 그 상황에서 그 3가지로 간단한 소개 웹앱을 다 만들어 러닝 커브, 성능, 초기구축 어떤 게 좋았나 고민을 했고 Vue·js를 도입해 성공적으로 잘 만들게 되었던 경험이 있습니다.

두 번째, 좀 더 나은 사람이 되고자 노력합니다. 제 블로그에 보면 많은 책을 읽고 있습니다. 독후감 파트의 포스팅이 366건을 기록하고 있습니다. IT기술서도 많이 읽지만, 인문학책들도 많이 읽습니다. 논어, 이순신 관련 책 등을 읽으며 인격적으로 훌륭한 사람이 되고자 노력하였고 솔선수범하고 인격적으로 좋은 사람이 되고자 노력합니다. 

세 번째, 코드입니다. 메모이제이션 피벗알고리즘, 투포인트 등 알고리즘을 녹아내서 코드 부분에 있어서 시간복잡도를 줄이는 것을 잘하고 상대방과 나의 코드에 대해 꼼꼼한 코드리뷰, 블록 단위 식으로 로직을 구현하고 그걸 빠르게 코드를 짜는 것을 잘하며 부분적으로 작은 함수로 테스트를 진행하기 때문에 좀 더 안정적인 코드 구축을 하는 것들을 잘합니다.

### Q. 의견 불일치 시 어떻게 했어?
1. D3.js 선정
차트표출에 관해 처음에 chart.js라는 라이브러리를 쓸건지 d3.js를 쓸건지에 대한 의견충돌이 있었다. chart.js의 경우 이미 만들어진 풍배도라는 체계가 있었고 그걸 이용한다면 쉽게 풍배도나 차트를 쉽게 만들 수 있었다. 그러나 d3.js 가 더 가볍고 ticks나 yaxis 등을 세세하게 커스터마이징하기에 더 쉬웠으며 추후 유지보수성을 높이기 위해서는 D3가 제격이라고 생각했습니다.
하지만 새로운 라이브러리를 배우게 한다는 것은 실원들에게 부담되는 일이였습니다. 그래도 이게 나은 방향이라고 생각했고 주도적으로 d3.js에 대해 강의를 진행함으로써 실원들의 런닝커브를 줄였고 실원들도 열심히 하는 제 모습에 반해서였는지 어느정도 공부를 하기 시작했고 성공적으로 d3.js를 우리 개발실에 안착시켰고 그걸 기반으로 풍배도와 차트 그리고 지도기반 컴포넌트까지 구현할 수 있었습니다. 

2. 김해출장
의견이 불일치 하는 일이 생겼을 때 빠르게 결정을 내리는 것보다 조금 더 시간을 가지고 더 나은 방향이 없을까 고민했습니다. 예를 들어 김해 비행단에서 문제가 생겼는데 그 쪽에서는 우리 프로그램 탓이라고 하고 출장을 와달라고 했습니다. 김해까지는 가는데만 4시간이 걸리던 터라 부담스러웠고 실장님과 팀원들의 의견이 갈렸습니다. 김해 측의 쭉 들어보면서 모뎀 탓일 수도 있으니 일단은 모뎀을 교체해보자. 하면서도 우리쪽에서는 출장을 준비했습니다. 결국은 모뎀탓이여서 출장을 가지 않게 되었습니다. 무턱대고 빠른 결정을 내렸다가는 출장을 갈 뻔한 일이였습니다.
 
### Q. 사례
예를 들어 10초마다 쌓이는 센서 데이터를 1~5시간 중 선택적으로 표출해야 하는 차트 모듈를 개발할 당시 미리 5시간의 데이터를 시간당 5개의 세그먼트로 나눠서 메모이제이션을 적용하여 네트워크 요청을 줄여서 성능을 높인 사례가 있습니다. 

### Q. 마무리
저는 기술이 세상을 바꾼다고 믿습니다. 공주대학교 커뮤니티를 만들어 학생들에게 “덕분에 강의 선택을 좀 더 잘할 수 있었어”라는 얘기를 들으며 저의 작은 개발이 세상을 이롭게 바꾸는 데 쓰일 수 있구나라는 것을 깨닫고 개발자의 꿈을 키워나갔고 군대에 들어와서도 기존의 불편한 시스템을 바꾸고자 고군분투하였습니다. 이러한 다양한 경험들을 바탕으로 카카오커머스에 들어가 다시한번 기술로 세상을 바꿔나가고 싶습니다.
저는 18년부터 딥러닝에 관심이 많아 친구와 함께 LSTM온도예측모델을 만들기도 하고 CNN을 구축하기도 하였습니다. 이러한 경험과 제가 지금까지 만든 웹기반 프로젝트를 융합한다면 SW Engineer로써 인공지능관련 웹서비스를 구축하는데 있어 큰 도움이 될 것이라 생각합니다.

### Q. 자신있는 개발 언어와 해당 언어 관련 가장 성공적인 경험을 설명해주시고, 프레임웍 사용 경험이 있으신지 알려주세요.
가장 자신있는 개발언어는 자바스크립트입니다. 자바스크립트만으로 구성된 MEVN 스택, MongoDB, Express.js, Vue.js, Node.js 그리고 시각화 라이브러리인 D3.js 그리고 데이타 포맷은 JSON으로 통일하여 만든 기상정보지원체계 경험이 제 가장 큰 성공적인 경험입니다. 그 때 당시에는 Vue.js와 React.js, Angular.js가 있었고 Vue.js는 나온지 얼마 되지 않았었습니다. 처음 어떤 스택으로 개발할건지를 결정하는 것이 중요했을 때 그 3가지로 모두 미니 앱을 2주만에 개발하여 Vue.js가 가장 좋다는 판단을 가지고 도전적으로 스택을 정하고 시작했습니다. 그렇게 2년 6개월동안 개발을 진행하고 지금은 정말 성공적으로 대한민국 전 비행단에 배포가 되어 전투기, 비행작전 등에 사용되고 있습니다. 이를 통해 안정성, 유지보수성, 성능면에서 MEVN 스택의 좋은 점을 증명했다는 점에서 성공적이라 할 수 있습니다. 
항상 만들면서 Vue.js는 규모가 작은 곳에 서비스를 하는 데 쓴다. MongoDB는 성능이 좋지 않다. join도 되지 않는다. 라는 말을 들으면서 개발했습니다. 
저는 Vue.js는 Vuex를 쓰면 충분히 큰 프로젝트에서도 가능하며 MongoDB는 json 포맷에 있어서는 SQL과 다르게 타입변환이라는 단계가 없어져 성능이 더 좋고 센서데이타를 주로 저장하는 이 프로젝트에는 이게 맞춤일 것이다 라는 제 판단을 근거로 개발해 나아갔습니다. 그저 주관적인 느낌이 아닌 정말 많은 공부와 연구를 토대, 그리고 직감으로 이어갔는데 그게 성공적으로 이어졌던 경험입니다. 
프레임웍은 Vue.js, Express.js를 잘 다루며 라이브러리로는 D3.js를 잘 다룹니다. 

### Q.  글로벌 서비스를 개발한다면 어떤 점이 중요하다고 생각하시는지 설명해주세요
안정성, 유지보수성, 커스터마이징이 중요하다고 생각합니다. 첫째 모든 서비스는 그렇듯이 안정해야 합니다. 서버가 죽는 것을 대비해야 하며 죽지 않게 들어오는 나가는 데이터에 관한 꼼꼼한 체크 등을 해야 합니다. 둘째는 유지보수성입니다. 글로벌 서비스라면 상상을 초월하는 다양한 요구사항이 들어올 것입니다. 이러한 것에 대한 것에 대해 잘 대처한다는 것은 유연하게 대처하는 것을 말합니다. 유연하게 대처하려면 빠르게 프로그램을 수정할 수 있게 만드는 유지보수성 증대에 많은 힘을 기울여야 합니다. 마지막은 커스터마이징입니다. 라인의 경우, 페이스북을 보면 각 나라의 언어로 개설이 되어있으며 카카오는 영어로만 서비스되고 있습니다. 커스터마이징화가 잘된 라인이 카카오보다 더 글로벌하다고 할 수 있습니다. 나라마다 문화도 다르고 다른 부분이 더 많을 것입니다. 그러한 것들을 이해하고 그 부분에 따른 커스터마이징화가 필요할 것입니다. 

## 기술적 질문들 모음

### Q. Jekyll
Jekyll 은 아주 심플하고 블로그 지향적인 정적 사이트 생성기입니다. Jekyll 은 다양한 포맷의 원본 텍스트 파일을 템플릿 디렉토리로부터 읽어서, (Markdown 등의) 변환기와 Liquid 렌더러를 통해 가공하여, 당신이 즐겨 사용하는 웹 서버에 곧바로 게시할 수 있는, 완성된 정적 웹사이트를 만들어냅니다. 그리고 Jekyll 은 GitHub Pages 의 내부 엔진이기도 합니다. 다시 말해, Jekyll 을 사용하면 자신의 프로젝트 페이지나 블로그, 웹사이트를 무료로 GitHub 에 호스팅 할 수 있다는 뜻입니다.
 - 사용법이 간단
 - 마크다운(Markdown) 기반
 - GitHub Pages에서 무료 호스팅 지원
 - 다양한 테마 및 플러그인, 편집기(editor) 생태계 보유
 - 확장 가능한 테마 시스템

### Q. 자연어처리, 자연어 처리(NLP, natural language processing) 
자연어(natural language)란 우리가 일상 생활에서 사용하는 언어를 말합니다. 자연어 처리(natural language processing)란 이러한 자연어를 의미를 분석하여 컴퓨터가 처리할 수 있도록 하는 일을 말합니다. 음성 인식, 내용 요약, 번역, 사용자의 감성 분석, 텍스트 분류 작업(스팸 메일 분류, 뉴스 기사 카테고리 분류), 질의 응답 시스템, 챗봇과 같은 곳에서 사용되는 분야입니다.

자연 언어 처리에서 말하는 형태소 분석이란 어떤 대상 어절을 최소의 의미 단위인 '형태소'로 분석하는 것을 의미한다. (형태소는 단어 그 자체가 될 수도 있고, 일반적으로는 단어보다 작은 단위이다.) 정보 검색 엔진에서 한국어의 색인어 추출에 많이 사용한다. 
 - 나는 → 나(대명사) + 는(조사)
 - 나는 → 날(동사) + 는(관형형어미)

자연어 처리는 머신러닝(ML)을 통해 이뤄지며 관련 모델은 Word2Vec, RNN, LSTM 등이 있습니다. 
예를 들어 네이버 검색이 자연어 처리(NLP Natural Language Processing) 분야에서 축적한 기술력과 서비스 노하우를 바탕으로 검색 이용자의 의도를 더욱 잘 이해하는 검색으로 진화하고 있다. 네이버는 12일(금), 13일(토) 양일간 고려대 인촌기념관 대강당에서 개최되는 ‘제 30회 한글 및 한국어 정보처리학술대회(조직위원장 임희석 고려대 교수, HCLT2018)’에서 총 5편의 논문을 접수하고 발표한다. 올해는 자연어 처리 및 한글 검색어와 관련한 총 3편의 논문이 우수 논문으로 선정됐다. 

네이버는 모바일 상에서의 검색이 일상화된 이용자들을 위해 AI 기술 기반 검색어 교정 시스템인 ‘AIQSpell’ 개발에 힘써왔다. 딥러닝을 비롯한 최신의 AI 기술을 활용해 기존의 검색어 교정 시스템을 대체했으며, 최근 이에 대한 유의미한 성과가 나타나고 있다. 

네이버는 이용자의 리뷰 문서를 분석하여 영화 제목을 찾는 질의에 답하는 시스템을 개발했다. 가령 ‘10분마다 기억을 잃는 영화’를 검색하면 영화 ‘메멘토’가, ‘인공지능이랑 연애하는 영화’를 검색하면 영화 ‘그녀’가 답변으로 제시된다. 네이버의 영화 AI는 서비스를 사용한 이용자가 영화를 본 후 리뷰를 작성하면, 해당 리뷰가 영화AI에 반영되어 점점 똑똑한 추천 시스템을 갖추게 되는 구조다. 해당 시스템은 이용자가 영화 제목을 기억하지 못하거나, 관람하고 싶은 특정한 유형의 영화가 있을 때 알맞은 영화를 찾아주는데 유용하게 활용될 전망이다. 네이버의 영화AI는 네이버의 인공지능 플랫폼 클로바(Clova)가 탑재된 모든 서비스에 적용될 예정이다. 

### Q. 트리
트리는 그래프의 일종으로서, 다수의 데이터를 빠르고 효율적으로 처리하기 위해 사용됩니다. 
부모 노드 밑에 여러 자식 노드가 연결되고, 자식 노드 각각에 다시 자식 노드가 연결되는 재귀적 형태의 자료구조다. 단, 자식 노드의 자식이 부모로 연결되는 경우는 보통 트리로 인정하지 않는다.  

1. 연결 그래프이다. 
2. 방향을 무시하였을 때, 싸이클이 존재하지 않는다. 
3. 트리의 간선 개수는 반드시 트리의 정점 개수보다 1 작다.  
 
 
트리의 높이는 DFS를 통해 재귀적으로 구하면 됩니다. 
```c++
void dfs(int now, int level){ 
    dfs(left, level + 1);
}
``` 


#### 트리의 구성요소 및 노드
리프노드 : 차수가 1인 정점, 포레스트는 서로 독립인 트리들의 모임
높이(height): 가장 긴 루트 경로의 길이로 DFS로 구할 수 있다.  

잎새노드(leaf node)란 자식노드가 없는 노드입니다. internal node란 잎새노드를 제외한 노드를 나타냅니다. 루트노드(root node)란 부모노드가 없는 노드를 가리킵니다.

중위 순회(In-order traversal): 왼쪽 자손, 자신, 오른쪽 자손 순서로 방문하는 순회 방법. 이진 탐색 트리를 중위 순회하면 정렬된 결과를 얻을 수 있다.
전위 순회(Pre-order traversal): 자신, 왼쪽 자손, 오른쪽 자손 순서로 방문하는 순회 방법.
후위 순회(Post-order traversal): 왼쪽 자손, 오른쪽 자손, 자신 순서로 방문하는 순회 방법.

#### 이진탐색 트리
이진 트리의 일종으로, 노드의 왼쪽 가지에는 노드의 값보다 작은 값들만 있고, 오른쪽 가지에는 큰 값들만 있도록 구성되었다. 자식 노드들도 동일한 방법으로 정렬되어 노드의 왼쪽 자식의 왼쪽 가지에는 왼쪽 자식이 가진 값보다 작은 값만 있고, 왼쪽 자식의 오른쪽 가지에는 왼쪽 자식의 값보다 큰 값들만 있으며 어느 노드를 잡아도 동일한 규칙으로 정렬이 되어 있다.
활용으로는 B-tree가 있다. 이진 트리를 확장한 것으로 이진 트리는 하나의 노드가 가질 수 있는 자식 노드의 수가 최대 2개지만 B-tree는 2개 이상을 가질 수 있다. 

노드에 접근 하는 시간 자체가 노드에서 연산하는 시간보다 훨씬 길 경우, B-tree를 쓰는것이 매우 좋다. 자식 노드가 가질 수 있는 수를 늘이고, 트리의 높이를 줄여서 노드에 접근하는 횟수를 줄일 수 있기 때문이다. 
 - DB의 인덱스

#### AVL tree
가장 처음으로 나온 자가 균형 이진 탐색 트리로, 이진 탐색 트리가 운이 안 좋을 경우 O(N)의 시간이 걸리는 것을 보완한 트리이다.이상적인 상황에서나 최악의 상황에서 탐색/삽입/삭제 모두 시간 복잡도가 O(log N)이다. 만족해야 하는 조건은 모든 노드에서 오른쪽 트리와 왼쪽 트리의 높이(height)의 차이가 1이하로만 나는것. 삽입/삭제를 할 때마다 균형이 안맞는 것을 맞추기 위해 트리의 일부를 왼쪽 혹은 오른쪽으로 회전시켜야 한다. 
균형은 아래에 나온 Red-black tree보다 훨씬 잘 잡히지만, 그렇기 때문에 Red-black tree보다 삽입과 제거가 느리고 탐색 자체는 빠르다. 그래서 보통 자가 균형 이진 탐색 트리가 필요한 경우 Red-black tree를 쓰는 경우가 많다.

#### Red-black tree
자가 균형 이진 탐색 트리의 일종으로, 노드에 색깔 속성이 붙은 트리이다. 이상적인 상황에서나 최악의 상황에서 탐색/삽입/삭제 모두 시간 복잡도가 O(log N) 
C++ STL의 set, map이 이 레드블랙 트리를 이용하여 구현되었다.  
 - 포화 이진 트리 - 세그먼트트리, 구간합, 최소 스패닝 트리 

### Q. 병합정렬
병합 정렬은 폰 노이만이 제안한, 평균 시간 복잡도와 최악 시간 복잡도가 모두 O(NlogN)인 정렬 알고리즘입니다. 분할 정복 알고리즘의 대표적인 예시입니다.

### Q. 병합 정렬의 Best Case가 O(NlogN)을 증명하라. 
Worst Case에 대해서는 잘 알고 있습니다. 병합 정렬을 수행할 때 특정 범위의 원소가 정확히 반씩 쪼개지기 때문에 연산의 깊이는 O(logN)이므로, 전체 정렬 과정에서 O(NlogN)이 됩니다. 병합 정렬은 어떤 방식으로 입력이 들어와도 반씩 쪼개면서 정렬을 해야 합니다. 따라서 입력 상태와 상관 없이 Best Case 또한 O(NlogN)입니다.  

### Q. 다이나믹 프로그래밍
Dynamic Programming은 앞서 설명했던, 병합 정렬과 같은 분할 정복 알고리즘에서 출발합니다. Optimal Substructure와 Overlapping Subproblems라는 특징이 있습니다. 작은 문제와 큰 문제가 중복되기 때문에 메모이제이션을 통해서 배열에 이미 해결된 데이터를 담아서 한 번만 문제를 해결하면 되도록 할 수 있습니다.
상대적으로 어려운 Dynamic Programming  문제로는 Shortest Path Algorithm을 이야기할 수 있습니다.
DP의 특성으로 optimal substructure와 overlapping subproblem이 있습니다. optimal substructure는 부분 문제들의 최적해들을 전체 문제의 최적해가 포함하고 있는 것을 말합니다. overlapping subproblem은 divide-and-conquer와 차이나는 부분으로 …


### Q. 플로이드 와샬이 Dynamic Programming으로 O(N^3)이 나오는 것을 증명해보세요.
플로이드 와샬은 Dynamic Programming을 이용했을 때 O(N^3)이 나옵니다. 플로이드 와샬은 A에서 C로 갈 때 B라는 노드를 거쳐서 가면 더 빠를 때, 테이블을 갱신하여 더욱 빠른 경로를 저장한다는 특징이 있습니다. 그래서 3중 For문이 사용됩니다. (여기에서도 제 설명이 명확하지 못하고 부족해서, 수학적인 증명에 관해서 계속 물어보셨음.)

 

### Q. Greedy 알고리즘이란 무엇인가요?
현재 상황에서, 당장 더 좋아보이는 방향으로 처리하는 알고리즘입니다. 대표적인 Greedy 알고리즘에는 Minimum Spanning Tree, 허프만 인코딩 알고리즘 등이 있습니다.

 

### Q. 크루스칼 알고리즘에서 Greedy한 접근 방법이 최적의 해를 구하는 이유를 증명해보세요.
크루스칼 알고리즘에서는, 단순히 각 간선을 정렬한 이후에 비용이 작은 간선부터 연결하면 문제를 해결할 수 있습니다. 그렇기 때문에 '항상 작은 것을 선택'한다는 점에서 Greedy 알고리즘에 해당합니다. 이러한 접근 방법이 최적의 해를 보장하는 이유는, 사이클이 발생하지 않도록 보장하면서 작은 간선끼리 연결하여 집합을 만들면 항상 적은 비용이 발생하기 때문입니다. (횡설수설, 이 부분 또한 확실하고 명확한 정의를 내리지 못했던 것 같음.)

 

### Q. 촘스키 4계층에 따른 언어와, 이를 인식하는 도구를 설명하세요.
촘스키의 네 가지 언어 유형은 가장 작은 범위부터 Regular Language, Context Free Language, Context Sensitive Language, Recursively Enumerable Language입니다. 가장 작은 범위의 계층부터 설명하자면 유한 상태 기계, Pushdown 오토마타, Linear Bounded 오토마타, 튜링 머신으로 이를 인식할 수 있습니다.

### Q. 결정 문제와 정지 문제
알고 있습니다. 정지 문제는 결정 문제의 대표적인 예시로, 결정이 불가능한 문제로 증명되었습니다. (횡설수설) 정지 문제에 대해서는 개인적으로 관심이 있어서, 찾아보고 증명 과정을 따라해 본 적이 있습니다.

 

### Q. 결정 문제와 튜링 머신의 상관 관계에 대해서 설명하세요.

  

### Q. Cache가 무엇인가요?
속도 차이를 보상하기 위해서 사용합니다. 흔히 CPU와 RAM 사이에 존재하여, 두 장치 간의 데이터를 임시적으로 저장하여 빠르게 처리할 수 있도록 도와줍니다. 메모리에는 Locality 라는 특징이 있기 때문에 Cache는 큰 효과가 있습니다.

 

### Q. Memory Hierarchy에 대해서 설명하세요.
Memory Hierarchy는 CPU부터 보조기억장치에 이르는 각각의 메모리 장치 간의 관계를 계층적으로 설명한 것입니다. CPU에 가까울 수록 비용이 비싸고, 저장 장치가 작지만 빠르다는 특징이 있습니다. 아까 설명했던 Cache의 개념이 전체적으로 통용됩니다. 예를 들어 RAM 또한 CPU와 보조기억장치의 Cache라고 볼 수 있습니다.

 

### Q. Cache 구현 방법에 대해서 설명하세요.
Direct Mapping 방식, Set-Associative Mapping 방식, ... (횡설수설)

 

### Q. Cache Miss의 3가지 종류에 대해서 설명하세요.
Compulsory, Capacity, Conflict입니다. (이후 각각의 Miss에 대한 보충 설명)

 

### Q. Conflict Cache Miss를 해결하는 방법은 무엇인가요? Set-Associative 방식으로 해결이 가능한가요?

### Q. 파이프라이닝을 사용하는 이유는 무엇인가요?
명령어를 처리할 때 명령어를 하나씩 순차적으로 처리하는 것보다, 명령어를 여러 단계로 나누어서 병렬적으로 처리하면 더 빠르게 데이터를 처리할 수 있기 때문에 파이프라이닝 기법을 사용합니다. 명령어는 Fetch, Decode, Execute, Memory, Write Back 등으로 나눌 수 있습니다. 그래서 이론적으로 4~5단계 파이프라이닝 기법을 이용하는 경우, 프로그램 실행 속도가 4~5배 정도 빨라집니다.

 

### Q. 파이프라이닝 해저드 정의와 각각의 해결법에 대해서 설명하세요.
파이프라이닝 해저드는 각 상황에서의 한계점 때문에, 파이프라이닝 속도를 저해하는 요소입니다. Hazard의 종류는 세 가지입니다. 구조적 해저드, 데이터 해저드, 제어 해저드입니다. 먼저, 구조적 해저드는 부족한 하드웨어 구성요소 때문에 발생합니다. 그리고 데이터 해저드는 데이터의 종속성 때문에 발생하며, 제어 해저드는 조건 분기 명령 때문에 발생합니다. (세부적인 질문을 하셨으나, 횡설수설 파티가 열렸음.)

### Q. 그러면 Java를 기준으로 설명할게요. 객체지항 프로그래밍에서 다형성에 대한 정의를 내려보세요.
다형성이란, 서로 다른 클래스의 객체가 같은 메시지를 받았을 때, 각자의 방식으로 동작하도록 합니다. 다형성을 이용할 때 소스코드의 재사용성을 극대화 하고, 명확한 설계가 가능합니다. (내가 말하면서도 이게 무슨 소리인가? 싶었음.)

 

### Q. Java에서 다형성을 구현하기 위한 방법으로 무엇이 있나요?
먼저 Overiding이 있습니다. 이는 부모 노드에서 정의되어 있는 함수 등을 자식 노드에서 물려 받을 때, 특정 함수에 대해서 자식 노드에서 부모와 다른 처리를 할 수 있도록 하는 것입니다. (횡설수설) 그리고 어떠한 연산자를 특정한 구조체나 클래스에 대한 연산으로 처리하고 싶을 때 사용할 수 있는 Overloading이 있습니다. 또한 코드의 재사용성을 많이 높여줄 수 있는 Generic이 있습니다. 이는 자료구조 등에서 많이 사용되며, 다양한 인스턴스가 들어왔을 때 모두 동일하게 동작하는 템플릿을 만드는 목적으로 사용됩니다. (다형성 관련 기술은 모두 사용해 본 적은 있지만, 이론적으로 제대로 공부를 하지 않아서, 총체적 난국이었습니다. 너무 Technical한 정의만을 내리는 것 같다고 교수님께서 말씀해주셨습니다.)

### Q. Static Binding과 Dynamic Binding을 설명하세요.
Static Binding은 프로그램이 실행되기 전에 전체적으로 바인딩 되는 것이며, Dynamic Binding은 프로그램이 동작하고 있는 도중에 동적으로 Binding되는 것입니다. (횡설수설)

 

### Q. CPU 스케줄링이란 무엇인가요? 프로세스가 CPU를 할당 받았다는 의미가 정확히 무엇인가요? 
다중 프로그래밍을 하기 위해서는 여러 프로세스 혹은 쓰레드가 동시에 실행되어야 합니다. 이 때 프로세스나 쓰레드의 실행 순서를 결정해주어야 하는데요. CPU 스케줄링은 그러한 과정을 의미합니다. 프로세스가 CPU를 할당 받았다는 것은 프로세스 생명 주기에서 Running 상태에 존재한다는 것입니다. (설명이 마음에 안 드셨는지, 교수님께서 조금 더 깊은 이야기를 친절하게 해주셨습니다.)


### Q. Thrashing이 발생하는 이유를 상세히 설명해주세요.
다중 프로그래밍의 정도가 심해지면, CPU 이용률이 높아집니다. 그러면 CPU 이용률이 어느 정도 이상을 넘어가면, 다중 프로그래밍의 정도가 그 이상으로 커지게 되어 Thrashing이 발생하며, 그 때 CPU 이용률이 급격히 떨어집니다. Thrashing이 발생하게 되면, 실질적으로 페이징 과정에서 불필요하게 많은 시간을 소비하게 되어 매우 비효율적인 상태에 빠지게 됩니다. (횡설수설... 세그먼테이션, 페이징 뭐시기 저시기...)

### Q. 허프만 인코딩이 무엇이고 왜 그리디 알고리즘으로 구현하는가
허프만 인코딩의 pseudocode가 주어졌고 pseudocode

### Q. 병합정렬
mergesort는 space complexity가 quicksort보다 높아서 정렬할 때 quicksort보다 더 많은 메모리를 차지하기 때문에 mergesort보다 quicksort를 더 선호합니다. 그리고 heapsort는 … (기억이 안남 ㅠ) quicksort가 최악의 경우만 아니라면 같은 O(nlogn)이지만 quicksort가 heapsort보다 성능이 더 좋다고 … 왜 그런지 Stack Overflow에서 읽었었는데 기억이 잘 안납니다.

### Q. 프로그래밍언어

나 : … 인간이 컴퓨터와 의사소통하기 위해 프로그램을 짜는데 프로그램을 작성할 때 쓰이는 것이 프로그래밍언어라고 합니다


### Q. CPU 스케줄링 

나 : 다중 프로그래밍을 하려면 여러 프로세스 또는 쓰레드가 동시에 실행되어야 하는데 이때 프로세스나 쓰레드의 실행 순서를 결정해주기 위해 사용합니다. 

### Q. 동기화  

나 : 여러 프로세스나 쓰레드가 공유 자원을 동시에 접근하려고 할 때 이를 제어하는 것을 말합니다.

### Q. 공유 자원의 동시 접근을 왜 제어해야 하나요?
data consistency를 유지해야 하기 때문입니다.

나 : … 공유 자원에 0라는 값이 있을 때 프로세스 A가 공유 자원에 접근하여 0을 1로 수정하고 있는데 프로세스 B가 0을 의도하고 공유 자원에 접근하여 1을 읽어가면 데이터의 일관성이 깨지기 때문에 문제가 발생합니다.

교2 : 동기화 기법 중에 세마포어와 뮤택스가 있잖아요? 이 두가지의 차이가 무엇인가요?

나 : 뮤택스는 바이너리 세마포어입니다. 세마포어는 공용 변수로 wait을 통해 변수의 값을 감소시키고 signal을 통해 변수의 값을 증가시킵니다. 뮤택스는 0과 1을 통해서만 상태를 표현합니다.

교2 : 그럼 뮤택스만 써도 되는데 굳이 세마포어는 왜 쓰는 것인가요?

나 : 세마포어 변수값이 양수이면 현재 남아 있는 공유 자원의 개수를 알 수 있고 0이면 모든 공유자원이 프로세스에 의해 점유된 상태임을 알 수 있으며, 음수이면 그 절대값이 블록 상태의 프로세스 개수임을 알 수 있습니다.

교2 : mutual exclusion으로 발생할 수 있는 문제가 무엇이 있을까요?

나 : 데드락이 발생할 수 있습니다.

교2 : 데드락이 무엇인가요?

나 : 프로세스들이 실행하지 않고 대기 상태에 있는 현상을 말합니다.

교2 : 왜 그러한 상태가 되는 것인가요?

나 : 프로세스들이 서로 자원을 점유한 채 서로의 자원을 요청하기 때문입니다. 대표적으로 환형 대기가 있습니다. 프로세스 A가 어떤 자원을 점유한 채 다른 자원을 요청하고 있습니다. 근데 프로세스 B가 그 자원을 점유하고 있고 프로세스 B도 프로세스 A가 점유하고 있는 프로세스를 요청하여 대기 상태에 빠지게 됩니다.

### Q. 프로세스에서 선점, 비선점이 무엇인가요?

나 : 선점은 프로세스가 CPU를 점유하고 있을 때 다른 프로세스에게 점유권을 빼앗길 수 있는 것을 말하고 비선점은 그 반대입니다.

교2 : XXX 학생이 쓰고 있는 PC에 윈도우가 설치되어 있다고 합시다. 윈도우는 선점 방식인가요? 비선점 방식인가요?

나 : 선점 방식입니다.

교2 : 그럼 자동차에 OS가 설치되어 있다면 그 OS는 선점 방식인가요? 비선점 방식인가요?

나 : 비선점적인 요소가 필요하다고 생각합니다.

교2 : 왜 그렇게 생각하나요?

나 : 자동차의 경우 반드시 일정 시간 안에 반드시 계산하여 결과를 도출해야 하는 상황이 발생할 수 있습니다. 즉 Real-Time OS를 사용해햐 합니다. Real-Time OS는 데드라인까지 반드시 결과를 내야하는 OS를 말합니다. Real-Time OS를 사용하지 않으면 인명 피해와 같은 치명적인 상황이 발생할 수 있습니다.


### Q. 마이크로 아키텍처
