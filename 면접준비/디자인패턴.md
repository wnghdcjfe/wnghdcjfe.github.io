# HTML 질문
디자인 패턴이란 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 "규약"을 통해 쉽게 쓸 수 있는 형태로 만든 것을 말합니다.
## 싱글턴 패턴
  - 클래스의 인스턴스가 오직하나.
  - 똑같은 값을 넣어도 인스턴스가 하나다! 
  - 어떤 객체와도 같지 않다! 리터럴, 클래스로 생성하는 객체들을 일컫는다.  
## 팩토리 패턴
 객체를 생성한다. 비슷한 객체를 생성하는 반복작업을 수행한다. 
## 프로토타입 패턴
 프로토타입 인스턴스를 사용, 새 객체를 만든다. 
## 반복자패턴
 객체들의 집합을 효과적으로 반복하면서 탐색한다. 이터레이터객체가 쓰인다 
## MVC 패턴

<center>
<img src="https://postfiles.pstatic.net/MjAxNzAzMjVfMjUw/MDAxNDkwNDM4NzI4MTIy.4ZtITJJKJW_Nj1gKST0BhKMAzqmMaYIj9PobYJMFD4Ig.xTHT-0qyRKXsA4nZ2xKPNeCxeU2-tLIc-4oyrWq5WBgg.PNG.jhc9639/mvc_role_diagram.png?type=w966" width="700px">
</center> 

MVC 는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다.
아키텍처의 최상위에 뷰가 있고 그아래 컨트롤러가 있고 그 아래 모델이 있습니다. 때문에 뷰는 컨트롤러만 알고 있고 컨트롤러는 모델을 알고 있습니다. 모델이 변경되었을 때 뷰는 컨트롤러를 통해서 통보를 받습니다.

### 모델, Model
애플리케이션의 정보, 데이타를 나타냅니다. 데이타베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻합니다.
모델의 속성 중 텍스트 정보가 변경이 된다면, 이벤트를 발생시켜 누군가에게 전달해야 하며, 누군가 모델을 변경하도록 요청하는 이벤트를 보냈을 때 이를 수신할 수 있는 처리 방법을 구현해야 합니다. 또한 모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 합니다. 
### 뷰, View
input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 다시 말해 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당합니다. 데이타를 기반으로 사용자들이 볼 수 있는 화면입니다.  
모델과 같이 변경이 일어났을 때 이른 누군가에게 변경을 알려줘야 하는 방법을 구현해야 합니다. 뷰에서는 화면에서 사용자가 화면에 표시된 내용을 변경하게 되면 이를 모델에게 전달해서 모델을 변경해야 할 것이다. 그 작업을 하기 위해 변경 통지를 구현합니다.
그리고 재사용가능하게끔 설계를 해야 하며 다른 정보들을 표현할 때 쉽게 설계를 해야 합니다. 

### 컨트롤러,Controller
데이터와 사용자인터페이스 요소들을 잇는 다리역할을 합니다. 
즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻합니다.  
컨트롤러 또한 다음과 같은 규칙을 이해해야 합니다.

## MVVM 패턴
로직과 UI가 분리된 패턴
MVVM도 MVC의 변종이자 MVC에서 컨트롤러가 뷰모델로 교체된 형테이고 뷰모델은 UI레이어 아래에 위치합니다. 
뷰모델은 뷰가 필요로 하든 데이터와 커맨드 객체를 노출해 주기 때문에 뷰가 필요로하는 데이터와 액션은 담고 있는 컨테이너 객체로 볼 수도 있습니다.
MVVM이 MVC와 다른 점은 뷰모델은 뷰를 지원하고 뷰가 필요한 데이터와 커맨드를 제공하기 위해서 만들어졌다는 것입니다. 이름그대로 뷰모델은 뷰를 위한 모델이며 뷰모델을 뷰에 바인딩할 때 가장 강력합니다. 여러가지 뷰를 제공하는 일반적인 객체가 아닌 각 뷰에 맞춰서 만들어진 것입니다. 때문에 뷰는 뷰모델에 대해서만 알고 있으면 되고 그외의 아키텍처에 대해서는 신경쓰지 않아도 됩니다. 
그래서 MVC와 가장 다른 점은 커맨드와 데이터바인딩이라고 할 수 있습니다. 이 2가지 요소로 인하여 뷰와 컨트롤러(MVVM에서는 뷰모델)의 관계를 끊을 수 있습니다. 커맨드를 사용함으로써 비헤이비어를 뷰모델에서 정의한 특정한 뷰액션과 연결할 수 있습니다. 데이터바인딩 특정한 뷰 속성과 뷰모델의 속성을 연결할 수 있도록 하고 뷰모델에서 속성이 변경되었을 때 뷰에 반영이 됩니다.
```
커맨드 : 액션이 그것을 처리하는 객체와 분리되는 것이 목표 / 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 한다. 
데이타바인딩 : 화면에 보이는 Data와 브라우저 메모리 데이터와 일치시키는 기법 / View 모델의 상태가 변경되면 View도 변경되며 그 역도 가능하다. 
추상화된 뷰 : 여러형태의 View를 만들 수 있다면 추상화가 잘 되었다고 할 수 있다. 
```
첫째, ‘추상화된 뷰 상태(ViewState)’로 존재한다. 뷰는 HTML과 CSS를 조합하여 사용자에게 시각적으로 접근한다면 뷰모델은 이 뷰를 추상화하여 텍스트 입력기 컨트롤을 추상화하거나 뷰 상태 컬렉션을 사용하는 식이다. 추상화된 뷰모델은 구체적인 뷰에 대한 정보를 가지고 있지 않기 때문에 다양한 플랫폼에서 재사용할 수 있다는 장점이 있다.

두번째로, 모델에서 제공하는 데이터를 사용자 인터페이스에 맞게 ‘상대적인 표현’으로 변환하여 표기하는 경우 뷰모델은 값 변환기(ValueConverters)를 가진다.

마지막으로, 사용자가 서비스에서 특정 동작을 수행할 수 있도록 그 수단을 제공하는 것도 뷰모델의 명령(Commands) 기능이 있기 때문이다.

그렇다면 추상화된 뷰와 실제 뷰를 연결해줄 수 있는 수단이 필요한데, MVVM 패턴에서는 기존의 컨트롤러가 했던 작업흐름 제어의 역할보다는 뷰와 뷰모델의 상태를 동기화해줄 데이터 바인딩(Data Binding)을 필요로 한다. 해당 요소를 통해 뷰모델이나 뷰가 변경되었을 경우 서로에게 변경사항이 반영되는 것이다.
Backend 로직과 Client의 마크업 & 데이터 표현단을 분리하기 위한 구조로 전통적인 MVC 패턴 방식에 기인하였다. 
간단하게 생각해서 화면 앞단의 화면 동작 관련 로직과 뒷단의 DB 데이터 처리 및 서버 로직을 분리하고, 뒷단에서 넘어온 데이터를 Model에 담아 View로 넘겨주는 중간 지점이라고 보면 된다.

MVP 의 문제점인 View-Presenter 관계의 의존성(1 : 1관계)은 데이터 바인딩과 명령을 통해 해결하게 된다.
현재 많은 변화를 요구하는 사용자 인터페이스에 있어, View 를 위한 View 가 중심이 되는 패턴이라고 볼 수 있다.
참고로 Vue.js 는 MVVM 패턴을 부분적으로 참고하여 만들어졌다.Vue.js 가 ViewModel 의 역할을 하는 것이다


### VUE.js  

<center>
<img src="https://github.com/namjunemy/TIL/blob/master/Vue/img/01.PNG?raw=true" width="700px">
</center> 

프로그래밍이 가능하게 끔 뷰단에서 모든 것을 제어하는 뷰모델 라이브러리이다.
Angular에서 지원하는 2 way data bindings을 동일하게 제공
하지만 Component 간 통신의 기본 골격은 React의 1way data flow(부모 -> 자식)와 유사 

#### Vue.js 라이프사이클 

<center>
<img src="https://cdn-images-1.medium.com/max/1600/1*tnSXRrpLBYmfHnIagITlcg.png" width="700px">
</center>  

####  1. Creation : 컴포넌트 초기화 단계
서버 렌더링에서도 지원되는 훅이다.
클라이언트 단과 서버단 렌더링 모두에서 처리해야할일이 있다면 이단계에서 하면된다. 
아직 컴포넌트가 돔에 추가되기 전이기 때문에 돔에 접근하거나 this.$el를 사용할 수 없다.
이 단계에서는 beforeCreate 훅과 Created 훅이 있다. 
#### created
created 훅에서는 이제 data와 events가 활성화되어 접근할 수 있다. 여전히 템플릿과 가상돔은 마운트 및 렌더링되지 않은 상태이다. 데이타 Fetch시 사용

####  2. Mounting : 돔(DOM) 삽입 단계
서버렌더링에서는 지원하지 않는다.
Mounting 단계는 초기 렌더링 직전에 컴포넌트에 직접 접근할 수 있다.  
초기 랜더링 직전에 돔을 변경하고자 한다면 이 단계를 활용할 수 있다.  
beforeMount / mounted 
#### mounted
mounted 훅에서는 컴포넌트, 템플릿, 렌더링된 돔에 접근할 수 있다. 모든 하위 컴포넌트가 마운트된 상태를 보장하지는 않는다. 서버렌더링에서는 호출되지 않는다.
mounted 훅에서 유의할 점은, 부모와 자식 관계의 컴포넌트에서 우리가 생각한 순서로 mounted가 발생하지 않는다는 점이다. 즉 부모의 mounted훅이 자식의 mounted훅보다 먼저 실행되지 않는다. 오히려 그 반대이다.
위 그림처럼 Created훅은 부모->자식의 순서로 실행되지만 mounted는 그렇지 않다는 것을 알 수 있다. 다른 식으로 말하면 부모는 mounted훅을 실행하기 전에 자식의 mounted훅이 끝나기를 기다린다.
(참고 Vue Parent and Child lifecycle hooks)
####  3. Updating : Diff 및 재 렌더링 단계
컴포넌트에서 사용되는 반응형 속성들이 변경되거나 어떤 이유로 재 렌더링이 발생되면 실행된다. 
디버깅이나 프로파일링 등을 위해 컴포넌트 재 렌더링 시점을 알고 싶을때 사용하면 된다. 조심스럽지만, 꽤 유용하게 활용될 수 있는 단계이다. 서버렌더링에서는 호출되지 않는다.
```
// nextTick 을 이용해서 업데이트 된 것을 알 수 있다. 
// modify data
vm.msg = 'Hello'
// DOM not updated yet
Vue.nextTick(function () {
  // DOM updated
})
```
####  beforeUpdate
이 훅은 컴포넌트의 데이터가 변하여 업데이트 사이클이 시작될때 실행된다. 정확히는 돔이 재 렌더링되고 패치되기 직전에 실행된다. 재 렌더링 전의 새 상태의 데이터를 얻을 수 있고 더 많은 변경이 가능하다. 이 변경으로 이한 재 렌더링은 트리거되지 않는다.
####  updated
이 훅은 컴포넌트의 데이터가 변하여 재 렌더링이 일어나 후에 실행된다. 돔이 업데이트 완료된 상태이므로 돔 종속적인 연산을 할 수 있다. 그러나 여기서 상태를 변경하면 무한루프에 빠질 수 있다. 모든 자식 컴포넌트의 재 렌더링 상태를 보장하지는 않는다.

####  4. Destruction : 해체 단계
####  beforeDestroy
이 훅은 해체(뷰 인스턴스 제거)되기 직전에 호출된다. 컴포넌트는 원래 모습과 모든 기능들을 그대로 가지고 있다. 이벤트 리스너를 제거하거나 reactive subscription을 제거하고자 한다면 이 훅이 제격이다. 서버 렌더링시 호출되지 않는다.

**reactive subscription이란?** 

####  destroyed
이 훅은 해체(뷰 인스턴스 제거)된 후에 호출된다. Vue 인스턴스의 모든 디렉티브가 바인딩 해제 되고 모든 이벤트 리스너가 제거되며 모든 하위 Vue 인스턴스도 삭제된다. 서버 렌더링시 호출되지 않는다.

그 밖에
activated와 deactivated가 있다. 각각 keep-alive 컴포넌트가 활성화 될 때와 비활성화 될 때 호출된다.

#### Virtual DOM
돔 요소가 많아지면 자바스크립트로 돔을 핸들링하는 일이 무거워진다. 그래서 돔과 비슷한 구조로 자바스크립트를 만든다. 이것은 진짜 돔과는 달리 메모리에 올라가있는 것이기 때문에 비교적 매우 빠른 성능을 보인다. 뷰js가 가상 돔을 수정하면 진짜 돔을 수정하는 것보다 빠르다. 뷰는 버추얼 돔이 변경될 때마다 진짜 돔과 비교해서 차이를 찾는다. 그 결과 차이난 부분의 돔만 수정하는 동작을 한다.

## MVP패턴
MVC에서 컨트롤러가 Presenter로 교체된 형태이고 프리젠터는 뷰와 같은 레벨에 있습니다. 프리젠터는 뷰와 모델의 이벤트를 모두 받으면서 둘 사이의 상호작용을 조정합니다. 
View-Presenter 는 One-to-One(일대일) 관계이다.
View 는 Presenter 를 참조하고, Presenter 는 View 의 존재를 알고 있다. (강한 결합 = 서로 의존성이 높다)

<center>
<img src="https://mblogthumb-phinf.pstatic.net/20161019_183/itperson_14768823355558NxuM_PNG/image_7551188081476882317130.png?type=w800" width="700px">
</center>  

View와 Model 은 오로지 Presenter 에 의해서만 상호작용을 하게 된다.
그로 인해 View-Model 관계는 분리되었지만, View-Presenter 관계는 서로 강하게 의존한다.
코드 상으로는 View-Presenter 일대일 관계로 인해, 각 View 를 위한 각 Presenter 가 필요며 이로인해 코드의 수가 상당히 증가하게 된다.
이를 MVVM 또는 MVC는 느슨한 결합으로 추상화하여 재사용가능하게끔 하였다.