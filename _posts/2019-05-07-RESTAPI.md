---
layout: post
title: 'REST API를 구축하는 자세한 방법'
author: kundol
comments: true
date: 2019-05-04 06:00
tags: [web, rest, restful, restapi]

---  
# REST API를 구축하는 자세한 방법 
![REST](/img/20190507_REST_1.png) 

## REST의 정의
웹에 있는 자원들을 HTTP를 활용하여 효율적으로 얻기위한 아키텍처스타일의 집합을 말합니다. 
기본적으로 웹에 있는 자원들은 URI라는 규칙에 따라 정의되어있고 정한 방법에 따라 그 자원들을 얻거나 수정할 수 있는데 이렇게 얻거나 수정하는 방법들을 좀 더 효율적으로
구현할 수는 없을까 고민이 담긴 집합이며 이를 잘 지킨 아키텍처를 **RESTful하다**라고 하는 것입니다. 

그럼 어떠한 아키텍처 스타일의 집합일까요? 일단 아래의 6가지 규칙은 지켜야 합니다. 
### 아키텍처 규칙
#### 1. Uniform-Interface : Self-descriptive messages
독립적으로 자원들이 각각 인터페이스를 가져야 한다는 것입니다. 
왜 독립적이야 하는가? 
 - 웹 페이지를 변경했다고 웹 브라우저를 업데이트할 필요는 없다.
 - 웹 브라우저를 업데이트했다고 웹 페이지를 변경할 필요도 없다.
 - HTTP 명세가 변경되어도 웹은 잘 동작한다.
 - HTML 명세가 변경되어도 웹은 잘 동작한다.

즉, 시간이 지나서 클라이언트와 서버가 변경되더라도 언제나 해석 가능하게끔 하는 것입니다. 
Self-descriptive messages이란 각 자원들의 타입에 대하여 **media 타입**을 이용하고 그 타입에 대해서 IANA에 등록해야 합니다.(하지만 힘듭니다.)
HTTP Header에 타입을 명시해주어야 합니다. 

각 메시지(자원)들은 MIME types에 맞춰 표현되며 스스로를 표현해야 합니다. 또한 이 데이타가 무엇을 나타내는지 path를 통해 나타내주어야합니다. 
```
{
  "path" : "/kundol"
}
```
[MIME타입](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 

#### 1. Uniform-Interface : HATEOAS 구조 
URL 에 따라 다른 페이지를 보여줘야 하는 것은 물론이며, 서버는 클라이언트 요청에 따른 URL RESPONSE를 보내야 합니다.  
애플리케이션은 하이퍼링크에 따라 전이가 되어야합니다. 
```
// send person object with HATEOAS links added
res.json(personObject, [
    { rel: "self", method: "GET", href: 'http://127.0.0.1' },
    { rel: "create", method: "POST", title: 'Create Person', href: 'http://127.0.0.1/person' }
]);
```
이렇게 하거나 data위에 링크를 써야 합니다. 
```
{
  "link":"http://kundol.net/todos/{id}"
  "data":[]
}
```

#### 2. Stateless
이건 HTTP 자체가 Stateless이기 때문에 HTTP를 이용하는 것만으로도 충족이 됩니다. 
API를 제공해주는 서버는 Session을 그 서버 쪽에 유지하지 않는다는 의미입니다. 

#### 3. Cacheable 
HTTP 는 원래 웹에서 작동하는 캐싱이 됩니다. 새로고침을 하면 304가 뜨면서 원래 있던 js와 css 이미지등을 불러오는 것을 볼 수 있습니다.
캐시는 네트워크 요청을 줄여주며 이는 UX향상에 도움이 됩니다. 네트워크 요청시 해당되는 자원들을 복사해서 메모리에 저장해두었다가 또 같은 요청시 네트워크요청을 하지 않고 브라우저메모리에 있던 자원을
다시 반환합니다. HTTP 메서드 중 GET에 한정되어있으며 `Cache-Control:max-age=100`이런식으로 한정된 시간을 정할 수가 있으며 이 캐싱된 데이타가 유효한지를 판단하기 위해 `Last-modifed` 그리고 `Etag`를 씁니다.   
`Etag`는 전달되는 값에 태그를 붙여서 캐싱되는 자원인지를 확인해주는 것입니다. 예를 들어 `Cache-Control:max-age=100`으로 형성된 자료는 100초가 지나면 응답이 완료 되었기 때문에 다시 똑같은 자료를 가져올 수 있습니다. 이 때 Etag, 디지털 지문을 사용한다면 똑같은 자원은 캐싱되서 요청을 줄일 수 있습니다
node.js에서는 npm을 다운받아 `res.setHeader('ETag', etag(body))`이렇게 사용됩니다. 

쿠키는 `public` 또는 `private`로 설정이 가능합니다. 
응답이 `public`으로 표시되면 이와 관련된 HTTP 인증이 구성되어 있고 응답 상태 코드가 정상적으로 캐시할 수 없는 경우에도 캐시가 가능합니다. 대부분의 경우, 명시적 캐싱 정보(예: `max-age`)가 응답이 어떠한 경우든지 캐시가 가능하다고 나타내므로 `public`이 필요하지 않습니다.

반대로, `private` 응답은 브라우저가 캐시할 수 있습니다. 그러나 일반적으로 이 응답은 단일 사용자를 대상으로 하므로 중간 캐시가 이 응답을 캐시하는 것은 허용되지 않습니다. 예를 들어, 비공개 사용자 정보가 포함된 HTML 페이지는 사용자의 브라우저가 캐시할 수 있지만, CDN은 이 페이지를 캐시할 수 없습니다.

#### 4. Client-Server 구조  
클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론 이는 HTTP 를 통해 가능한 구조입니다. 서버에서 HTTP 표준만 지킨다면 웹에서는 그에 따른 화면이 잘 나타나게 됩니다. 서버는 그저 API를 제공하고 그 API에 맞는 비즈니스 로직을 처리하면 됩니다. 마찬가지로 클라이언트에서는 HTTP 로 받는 로직만 잘 처리하면 되는 것입니다.
  
#### 5. Layered System
계층구조로 아키텍처를 만들 수 있다는 것을 뜻합니다.  

이렇게 규칙을 지켰으면 이제 자원을 표기하는 URI에 아래의 6가지 규칙을 지켜야 합니다.  
### URI 규칙
 1. 동작은 HTTP 메소드로 해야 합니다. 수정 = put, 삭제 = DELETE, 추가 = post, 조회 = get을 이용해야 합니다. 
예를 들어 `/books/delete/1` 이렇게 표기하면 안된다는 것입니다. 
 2. 확장자는 표기하지 말아야 합니다.
 3. 동사가 아닌 명사로만 표기해야 합니다. **유저가 책을 소유한다**라고 예를 들면 이런식으로 구성되어야 합니다. `유저/유저아이디/inclusion/책/책아이디`
 4. URI는 계층적인 내용을 담고 있습니다.  `/집/아파트/전세` 이런식으로 내려가야 합니다. 
 5. 소문자로 쓰며 너무 길경우에는 **-**를 씁니다. 
 6. HTTP 응답 상태 코드를 활용합니다.

|  상태코드   | 설명 | 
|:--------|:--------| 
| 200 OK   | 요청이 성공적으로 되었습니다. | 
| 201 Created | 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다 | 
| 400 Bad Request | 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다. | 
| 301 Moved Permanently |  이 응답 코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 새로운 URI가 응답에서 아마도 주어질 수 있습니다. | 
| 401 Unauthorized |  "비인증(unauthenticated)"을 의미합니다. 클라이언트는 요청한 응답을 받기 위해서는 반드시 스스로를 인증해야 합니다. |  
| 500 Internal Server Error |  서버에 오류가 있음을 나타냅니다. | 


### 도서관 REST API 예 
도서관으로 REST API 예제를 들고 마무리 하겠습니다.
```
GET /books - 모든 책을 조회합니다.
POST /books/{{booksid}} - 책을 생성합니다. 
PUT /books/{{booksid}} - 책을 수정합니다.
GET /books/{{booksid}} - 특정 책을 조회합니다. 
PUT /users/{{userid}}/books/{{booksid}} - 어떤 유저가 책을 빌립니다. 
```