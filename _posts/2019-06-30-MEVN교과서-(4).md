---
layout: post
title: 'MEVN교과서 (4)'
author: kundol
comments: true
date: 2019-07-16 10:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (4)

---    

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo.jpg)

## 3. 코드최적화와 패러다임
코드를 짤 때 그저 로직만을 짜면 절대 안됩니다. 그것은 죄악입니다. 코드를 짤 때 우리는 확장성, 유연성, 성능 등을 모두 고려해야 합니다. 이렇게 조금씩 그리고 세심하게 짠 코드가 나중에 봤을 때 무한한 행복을 가져올 것입니다. 

### 3.1 함수형프로그래밍
그렇다면 어떻게 짜야 할까요? 한 프로젝트당 코드 패러다임을 정해놓고 짜는 것이 중요합니다.패러다임이란 어떻게 짤 것인지를 규정한 것을 말합니다. 예를 들어서 객체지향형으로 짜자, MVC패턴으로 짜자, 함수형프로그래밍으로 짜자 등을 일컫습니다. 자세히 들어가면 `margin: 0 px`는 `margin : 0` 으로 놓자 등 아주 세세한 코드 스타일까지 정하는 것을 일컫습니다. 

저는 코드를 짤 때 함수형프로그래밍으로 짜는 것을 추천하며 이 책에서는 함수형프로그래밍으로 모든 소스코드를 짜도록 하겠습니다.

### 3.1.1 함수형프로그래밍의 특징 
함수형프로그래밍은 작은 순수함수들의 집합으로 최소의 부수효과를 누리는 패러다임입니다.

좀 더 자세히 말하자면 함수들을 작게 쪼개서 블록을 쌓듯이 로직을 구현하고 다형성을 높이고 고차함수를 활용하여 재사용성을 높이고 참조투명성을 통해 부수효과가 줄어들어 유지보수성을 증대시키는 함수형 프로그래밍에 대해서 알아보겠습니다. 함수형프로그래밍을 하면 단순하고 간결한 흐름 중심의 모델이 되고 서술부와 평가부가 분리되어 지연평가가 가능합니다.   
 
 > 다형성, 어떠한 인자든 가능한 것을 말한다. 
 
 > 참조투명성: 함수의 출력은 오로지 그 함수에 입력된 값에만 의존성을 가진다는 의미
 
 > 추상화를 높이다. : 다형성을 증가시켜 특정 데이터형에서 분리한다는 것


함수형 프로그래밍에는 여러가지 특징들이 있습니다. 그 특징들을 살펴보겠습니다.  

#### 1. 순수함수와 참조 투명성 
순수함수란 동일한 입력을 받아서 동일한 출력을 하는 것을 말합니다. 참조투명성의 성질을 가지고 있죠.  
위의 `PURE`는 순수함수고 아래 `not_PURE`는 순수함수가 아닙니다. 
```js
const PURE = (a, b)=>{
    return a + b; 
} 
const not_PURE = (a)=>{
    return a += 10;  
}
```
외부의 인자를 변화시키지 않고 값이 일정해야 합니다. 10을 더하는 함수지만 외부의 a의 값을 증가시켜서 부수효과가 생기게 했습니다. 
이는 순수함수가 아닙니다.  

즉, 외부의 인자를 변화시키지 않고 최대한 지역변수만을 써서 구현해야 합니다. 그리고 인수로 넘기는 값의 본체조차 수정되면 안됩니다. 
함수인수로 넘길 때 객체에 변이를 일으키지 않도록 주의를 하며 `deep copy`를 한 후 변이를 하던가 등의 방법을 써야 합니다. 또한 외부변수에 종속되지 않고, 동일한 입력을 받았을 때 동일한 결과를 내는 참조 투명한 함수를 써야 합니다. 
```js
var c = 0;
//받은 인자자체가 변함
function f(){
  return c++;
}
//인자를 변화시키지 않고 +1을 할 수 있다.
const f = c => c + 1
```
이렇게 인자를 변화시키지 않아야 합니다. 

#### 2. 고차함수
함수가 다른 함수를 인자로 받아서 어떠한 로직을 생성하는 함수를 말합니다.  

 > 고차함수는 함수를 값자체로 넘길 수 있는 **일급객체**여야만 가능합니다. (고계함수 = 고차함수)

#### 2.1 map
map은 함수 a를 받는 고차함수입니다. 

 > map이나 filter는 어떠한 값 [a]를 받아 새로운 []를 
```js
const a = (a)=>{
    return a + 10; 
}
const b = [1, 2, 3].map(a)
console.log(b)
```

**일급객체**란 함수를 변수에 담을 수 있고 함수나 메서드의 인자로 넘길 수 있으며 함수나 메서드에서 리턴을 할 수 있는 것을 말합니다. 
그리고 자바스크립트의 함수는 일급함수입니다. 일급함수란 아무때나 선언이 가능하고 익명으로 선언이 가능하고 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있어서 아래처럼 함수를 자유자재로 놓을 수 있습니다. 

#### 2.2 함수를 실행하여 리턴하는 `_call` 
```js
const _call = (a, b) => a() + b() 
```

#### 2.3 함수를 리턴하는 함수 
이렇게 함수를 안에서 다시 리턴해서 실행시점을 지연시킬 수 있습니다.  
```js
//ES6
const a = val => () => val; 
//ES5
function a(val) {
  return function() {
    return val;
  }
}

var a_lazy = a(12010);
a_lazy();
// 12010 
```


#### 3. 커링
여러개의 파라미터 보다 적은 수의 파라미터를 받아 누락된 파라미터를 인자로 받습니다.  
그러다가 인자가 다 채워지면 함수를 실행하게 됩니다. 커링의 원리는 클로저의 도움을 받는 것으로 이루어집니다. 
내부함수가 외부함수의 컨텍스트가 소멸이 되도 외부함수의 실행환경, 즉, 인자를 참조하면서 실행시점을 기다리게 됩니다. (평가를 미룬다고도 합니다.)
1. 파라미터가 클로저로 잡아져있다 라고 생각하시면 쉽습니다. 
2. 클로저라는 공간을 만들어서 그 안에서 내부함수를 return한다라고 생각하시면 쉽습니다. 

메모이제이션을 할 때도 효과적이며 `Point-free`로 로직을 구현하는데도 효과적입니다.


#### 3.1 ramda를 이용한 예
FP를 도와주는 Ramda를 이용한 예입니다. 마지막 파라미터를 skip하고 sum을 만들 수 있으며 add의 경우 나중에 2를 추가할 때 함수를 평가하게 하여 3이 되게 합니다. 
```js
const R = require('ramda')
const add = (a, b)=> (a + b); 
const total = R.reduce(add, 0)
const sum = total([1, 2, 3, 4, 5]) 
console.log(sum)
R.add(1)(2)
``` 

#### 3.2 ramda를 이용한 예
아래처럼 순차적으로 인자를 넘겨줘도 커링이 됩니다. 
즉 인자를 완전히 채우지 않아 실행시점을 미루다가 인자를 완전히 채웠을 때 실행이 되는 것이 바로 커링입니다.
```js
const addFourNumbers = (a, b, c, d) => a + b + c + d;

const curriedAddFourNumbers = R.curry(addFourNumbers);
const f = curriedAddFourNumbers(1, 2);
const g = f(3);
g(4); //=> 10 
```

그렇다면 커링을 한번 만들어보겠습니다. 
```js
const k_curry = fn => a => b => fn(a, b); 
const f = k_curry((a, b) => a + b); 
const f_c = f(1)
const ret = f_c(2);
console.log(ret)
```
`k_curry`, 2개의 인자를 받을 수 있는 커리를 만들었고 그 커리로 `f`를 래핑, 감싸줍니다. 이제 f는 커링이 가능한 **더하기함수**가 됩니다. 
저런식으로 평가시점을 늦출 수 있습니다. ES6버전은 위와 같고 ES5버전은 다음과 같습니다. 

```js
var k_curry = function(fn){
    return function(a){
        return function(b){
            return fn(a, b);
        }
    }
}
var f = k_curry(function(a, b){
    return a + b
}); 
var f_c = f(1)
var ret = f_c(2);
console.log(ret)
``` 

또한 커링을 하게 되면 코드가 간결해집니다. 커링을 한다는 것은 `f(a)(b)`이런식으로 인자를 넣는다는 것인데 이를 이용하면 파이프라인에서 조금 더 간결해집니다. 간결해진다는 것은 조금 더 깔끔해진다는 것이며 깔끔이라는 것은 조금 더 표현력이 증가한다는 것을 뜻합니다. 
```js
//커링 적용전
pipe(
  a => a + 1, 
  a => filter(a => a % 2, a) 
)
//커링 적용 후 - filter에 적용을 하였다. 첫번째 함수의 결과값이 filter라는 함수로 전달되었다. 
pipe(
  a => a + 1, 
  filter(a => a % 2) 
) 
```

참고로 `fx.js`의 커리는 이런식으로 구현되어있습니다. 
`..._`로 **남은**인자를 받아서 만약에 남은 인자가 없다면 함수를 실행합니다. 
즉, 인자가 **완성** 되었다면 실행하게끔 되어있습니다. 
```js
export const curry = f =>
  (a, ..._) => _.length ? f(a, ..._) : (..._) => f(a, ..._);
```
 


#### 4. 함수 합성
합성시키는 것은 compose와 pipe가 있는데 R.compose는 오른쪽에서 왼쪽으로 로직이 흘러간다면  
```js
const R = require('ramda') 
R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
```
pipe는 왼쪽에서 오른쪽으로 흘러가며 `point-free` 형으로 짤 수가 있습니다. 보통 저는 `pipe`를 씁니다.

절차지향형에 익숙한 방법이며 이 방법을 point-free방법이라고 합니다. 
```js
const f = R.pipe(Math.pow, R.negate, R.inc); 
f(3, 4); // -(3^4) + 1
```

#### 5. 파괴적인 함수를 쓰지 않습니다. 

splice는 배열을 파괴합니다. 
하지만 slice는 파괴를 하지 않고 1을 제외한 나머지 배열 요소들을 추출해낼 수 있습니다. 
되도록 payload를 파괴하지 않는 함수를 써야 합니다. 
```js
const a = [1, 2, 3, 4, 5]  
let b = a.slice(1)
console.log(a, b)  
b = a.splice(1)
console.log(a, b)
/*
[ 1, 2, 3, 4, 5 ] [ 2, 3, 4, 5 ]
[ 1 ] [ 2, 3, 4, 5 ]
*/
```   
#### 6. Point -free

무인수 프로그래밍입니다. 인자를 신경쓰지 않고 구현하는 것을 뜻합니다. 
커링을 통해 구현할 수 있습니다.

```js
const map = fn => list => list.map(fn); 
const add = x => y => x + y; 
const incrementAll = numbers => map(add(1))(numbers);
/* function with point-free */
const incrementAllWithPointFree = map(add(1));
var a = incrementAll([1, 2, 3]); // [2, 3, 4]
var b = incrementAllWithPointFree([1, 2, 3]); // [2, 3, 4]
console.log(a, b)
```

#### 7. 모나드
어떠한 값의 결과가 불확실하게 2가지형태 이상으로 나타날 수 있습니다. 이럴 때 컨테이너로 래핑하여 안전하게 연산을 하는 것을 말합니다. 함수형프로그래밍에서는 참조투명성, 입력과 출력이 동일하게 1 : 1 매칭이 되어야 하기 때문에 `try catch`를 쓰게 되면 로직을 담고 있는 컨테이너의 벨트의 라인이 2개로 분리되어 투명성을 잃게 되기 때문입니다. (물론 `try catch`를 써서 애러처리를 할 수도 있습니다만 함수형 프로그래밍에서 써야한다. 안써야 한다. 라고 하는 주장이 나눠집니다. 케바케입니다. 참고로 저는 씁니다.) 

`ramda-fantasy`의 `Either`라는 컨테이너박스에 담아서 
1. Right메소드로 성공처리로직을 
2. Left메소드로 애러처리로직을 구현해도 되고 Promise를 이용해도 됩니다. 

Promise 는 future Monad라고 합니다. 이런 형태의 값이라는 것을 설정해 놓고 비동기적인 상황에서 성공과 실패를 값으로 다루는 하나의 컨테이너 박스입니다. 콜백으로 넘기는 방식은 컨텍스트를 넘겨서 로직을 수행하고 Promise는 그것들을 하나의 "값"으로 받아서 로직을 수행합니다.

 > 콜백 : 어떤 함수가 어떠한 시점에서 다시 호출 되는 것

#### 7.1 Promise를 이용한 예
```js
const g = JSON.parse;
const f = k => k.temp; 
const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f)
const log = x => console.log(x)

fg('{"temp":36.5}').catch(_ => 'JSON PARSE is not working').then(log)
``` 

#### 7.2 Promise를 이용한 예
```js
const log = console.log
const users = [{name : '큰돌'}, {name : '제호'}, {name : '우람'}, {name : '다빈'}] 
const getUserByName = (name) => users.find(u => u.name === name) || Promise.reject("객체에 없습니다.")
const g = getUserByName;
const f = ({name}) => `${name}이가 춤을 춥니다.`
const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f) 
fg("큰돌1").catch(_ => _).then(log)
//객체에 없습니다.

fg("큰돌").catch(_ => _).then(log)
// 큰돌이가 춤을 춥니다.

/*
큰돌이가 춤을 춥니다.
객체에 없습니다.
*/
```

#### 8. 제너레이터와 이터레이터
제너레이터를 써서 순차적인 로직 구현과 지연효과를 쉽게 설계할 수 있습니다. 
```js
function *map(f, list){
    for(const a of list){
        yield f(a)
    }
}
``` 

또한 제너레이터는 **이터레이터**를 손쉽게 만들 수 있으며 **코루틴**이 가능합니다.
#### 8.1 제너레이터의 코루틴
1. yeild문이 발동하면 스택프레임에 복사를 하고 콜스택에서는 제거를 합니다.
2. 그리고 next()문이 발동하면 스택프레임을 복원하여 실행해서 진입점을 개발자가 원하는 데로 실행이 가능하게 설계할 수 있습니다. 
 
 > 코루틴 : 진입점을 개발자가 원하는 데로 실행이 가능하게 설계하는 것 

이 코루틴 덕에 이터레이러를 이용해서 **지연평가**라는 것이 가능합니다.

 > 지연평가를 하면 range함수를 만드는데서 성능에서의 장점 로직구현이 좀 더 효율적이게 됩니다. 왜냐하면 파이프라인에서 제너레이터로 연결된 함수들이 합쳐지는 듯한 효과를 내기 때문입니다. 
 
#### 8.2 이터러블/이터레이터 프로토콜
 - 이터러블: 이터레이터를 리턴하는 `[Symbol.iterator]()`라는  키를 가진 값이자 반복할 수 있는 순차적인 객체
 - 이터레이터: `{ value, done }` 객체를 리턴하는 `next()` 를 가진 값
 - 이터러블/이터레이터 프로토콜: 이터러블을 `for...of`, `전개 연산자` 등과 함께 동작하도록한 규약

... 전개연산자는 적용되는 공간에서의 인수들(배열, key-value)에 따라 그 공간에 맞는 인수 또는 요소로 확장할 수 있게 합니다. 전개연산자는 이렇게 활용할 수도 있습니다. `const [head, ...tail] = f();`

#### 8.3 제너레이터와 이터러블
제너레이터는 커스텀형 이터레이터로 함수자체가 이터러블을 생성합니다.

참고로 이 제너레이터는 return값을 가질 수있습니다. 그러나 순회할 때 대상에는 포함이 안되지만 `next()`메서드로 계속해서 호출하게 되면 `{value : 리턴값, done : true}`를 반환되게 하는 종결값으로 값이 끝내지게 됩니다.  
```js
const log = console.log
function* gen() {
    yield 10;
    if (false) yield 20;
    yield 30;
    return 90; 
}
let iter = gen();
log(iter.next())
log(iter.next())
log(iter.next())
/*
{ value: 10, done: false }
{ value: 30, done: false }
{ value: 90, done: true }
*/
 
log([...iter]); //[10, 30]

for (const a of iter) {
    log(a); //10, 30
} 
```

return을 넣었기 때문에 value와 done을 보면 됩니다. 
```js
const log = a => console.log(a)
function* gen() {
    yield 10;
    if (false) yield 20;
    yield 30;
    return 90; 
}
let iter = gen();
//log([...iter]); 
log(iter.next())
log(iter.next()) 
log(iter.next()) 
/*
{ value: 10, done: false }
{ value: 30, done: false }
{ value: 90, done: true }
*/
```

#### 8.4 객체로 만드는 제너레이터 
`[Symbol.iterator]()`라는 키를 넣어서 이터러블한 객체를 커스텀하게 만들 수 있습니다.
```js
var myIterable = {
    *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
    }
}
``` 

#### 9. 클로저 
클로저는 독특한 함수체제를 멋지게 활용할 수 있습니다. 
 - 프라이빗 변수를 모방 
 - 가상의 블록 스코프 변수를 생성  

 > 클로저 : 외부함수의 실행컨텍스트가 소멸해도 `[[scope]]`프로퍼티가 가리키는 **외부함수의 실행환경은 소멸하지 않고 참조할 수 있는 것을 말합니다.** 스코프체인이 형성될 때 `[[scope]]`로 참조할 수 있는데 이를 이용해 참조할 수 있는 것을 말합니다.

#### 9.1 클로저의 예
```js
var test = (function(){
    var count = 0; 
    return {
        increase: function(){
            count++;
        },
        decrease: function(){
            count--;
        },
        getValue: function(){
            console.log(count);
        }
    }  
})();
test.increase();
test.increase();
test.increase();
test.getValue();

var add = (function () {
    var counter = 0;
    return function () {
        counter += 1; 
        console.log(counter) 
    }
})();

add();
add();
add(); //1 2 3

//D3js에서의 예
function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}
``` 

이렇게 private 변수를 흉내내는 것 말고 어떤 시점에서의 시점을 이어가는 데도 쓰입니다. 

이렇게 함수형 프로그래밍의 주된 9개의 특징을 살펴 보았습니다. 

### 3.1.2 함수형프로그래밍의 응용예제  

#### 1. 배열안에서의 비동기 순서로직
아래를 그저 map이라는 함수를 써서 하면 순차적인 비동기 로직이 아니라 pending 6개가 찍혔다가 동시에 실행이 될 것입니다.
유인동이라는 개발자님이 만든 `partial.js`라는 라이브러리를 사용해보는 것이 어떨까요? 쉽게 비동기 순서 로직을 짤 수 있습니다.
```js
var _ = require('partial-js');
const delay = (val)=>{
    return new Promise((resolve, reject)=>{
        setTimeout(() => {
            resolve(val)
        }, 1000); 
    })
}
async function test3() {
  const list = [1, 3, 5, 6, 7, 9];
  console.log(list)
  return _.map(list, async function(val, i) {
    console.log(val, i); // 1초씩 순차적으로 실행됨
    return await delay(val * 10); // 1초씩 순차적으로 실행되고 정상적으로 결과를 꺼냄
  });
} 
test3().then((result)=> {
  console.log(result);
  // [10, 30, 50, 60, 70, 90]
});
``` 

#### 2. reduce를 통한 집계
이외에도 reduce를 통해 함수형 프로그래밍을 통하면 쉽게 집계된 데이타를 뽑아낼 수 있습니다. 아래의 예제는 20대 10대 별로 나누어서 count와 나이의 합계를 계산합니다.
```js
const _ = require('lodash') 
const users = [
    { id: 1, name: "홍철", age: 22 },
    { id: 2, name: "서영", age: 25 },
    { id: 3, name: "종선", age: 31 },
    { id: 4, name: "제호", age: 27 }, 
  ];

const a = _.reduce(users, (info, user)=> {
    const group = user.age - user.age % 10;
    info.count[group] = (info.count[group] || 0) + 1;
    info.total[group] = (info.total[group] || 0) + user.age;
    return info;
  }, { count: {}, total: {} }); 

console.log(a)

``` 

함수형 프로그래밍을 한다면 유인동개발자님이 만든 FX.js를 사용하는 것이 좋습니다. 유인동개발자님은 우리나라에서 함수형 프로그래밍을 제일 잘하는 사람 중 하나이며 lodash, ramda의 장점을 섞어 만든 partial.js의 장본인입니다.  FX.js는 partial.js의 다음 버전 라이브러리입니다. 
당연히 사용하기도 편리하고 성능도 좋습니다. 앞으로 이어나갈 모든 코드들에는 fx.js가 포함될 예정입니다. 
함수형 프로그래밍을 조금 더 알고 싶다면 [유인동의 함수형프로그래밍](https://www.inflearn.com/course/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/#) 을 보기를 권장드립니다.  

### 3.2 자바스크립트 최적화 
자 우리는 하나의 패러다임 중 제가 추천하는 함수형프로그래밍을 살펴보았습니다. 그렇다면 자바스크립트의 최적화는 어떻게 진행이 될까요? 먼저 로직을 구성하는데 있어 어떤 것들을 맞추는 것이 중요합니다. 제가 생각하는 것들은 이러한 것이며 개인취향이 강하기 때문에 이런 것들은 팀원들과 상의 후 결정하면 됩니다. 이러한 것들이 미리 정해져 있는 eslint를 써서 정해도 됩니다.  

1. 함수, 변수명은 카멜표기법을 사용합니다. 팟홀표기법(underbar 표기법)도 있지만 저는 이걸 추천합니다.  
2. 간단하더라고 if { 중괄호를 사용해야 한다. 
3. 문자열은 무조건 템플릿문자열을 사용해야 합니다.
4. 한 컴포넌트, 모듈의 길이는 200줄 이하로 작성되어야 한다.
5. 배열순회의 경우 for-in 루프를 쓰지 않습니다. (객체 속성순회일경우에는 씁니다.) 왜냐하면 인스턴스, 프로토타입 체인까지 검색하므로 느립니다.
6. 정규표현식은 간단하게 씁니다. 예를 들어 ble|blue 대신 blu?e를 씁니다.

### 3.2.1 함수선택, parseInt와 ~~의 성능비교
예를 들어 실수형을 정수형으로 만드는 연산이 있습니다. 자바스크립트에서 대표적인 함수로는 parseInt를 뽑을 수 있습니다. 하지만 ~~이라는 비트연산자를 통하면 좀 더 빠르게 구할 수 있습니다. ~~는 ~라는 비트를 전체를 뒤집는 비트연산자를 한 번 더 한 것이며 이를 이용하면 더 빠르게 됩니다. 

[JSMATCH](http://jindo.dev.naver.com/jsMatch/index.html)라는 네이버에서 만든 비교사이트를 통해 비교해봅시다. 

#### A. parseInt
```js
for(let i = 0; i < 100000; i++){
	let a = 123.456789
	b = parseInt(a)
} 
```

#### B. ~~
```js
for(let i = 0; i < 100000; i++){
	let a = 123.456789
	b = ~~(a)
} 
```

![비교결과](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_parseInt.PNG)

`~~`가 조금 더 빠릅니다.

 > ~ = -(n + 1), 비트연산자를 통해 적용한 겨로가는 부호 있는 32비트 정수로 반환됩니다.  - ECMA5 SPEC (그렇기 때문에 2 ^ 31 + 1 이상은 쓸 수 없습니다.)


이러한 비트 연산자는 실제로도 많이 쓰입니다. 유명한 오픈소스인 D3.js의 184번째 줄(5.9.4버전)을 보면`n = Math.max(0, Math.ceil((stop - start) / step)) | 0,`이라는 코드가 있습니다. `| 0` 은 제가 ~~과 똑같은 역할을 하는 비트연산자 입니다. 실제로 ~~보다는 `| 0`이 더 성능이 좋습니다. 하지만 그렇게는 차이가 많이 나지 않으니 ~~를 써도 무방합니다. 

이외에도 indexOf보다는 includes가 성능에 좋으니 includes를 써야 하고 불필요한 객체 선언을 없애서 메모리소모를 줄여서 최적화 시키는 방법이 있습니다.  

### 3.2.2 함수선택, 객체를 복사하는 방법의 선택 
자바스크립트에서 객체를 할당하게 되면 주소값을 참조하게 되는 얕은 복사가 일어납니다. 그렇기 때문에 그 이후에 그 값을 변경하면 원래의 객체가 변화게 되어 사이드 이펙트가 일어날 수 있는 상황에 접하게 됩니다. 그래서 우리는 deepCopy라는 깊은 복사를 해야 하는데 객체의 깊이에 따라 좀 더 효율적인 방법이 있습니다.  

#### 스프레드 연산자와 Object.assign
아래의 2가지 방법은 JSON객체의 깊이가 1일 때까지 유효합니다.
```js
const a ={"b" : 1}
let b = {...a}
let c = Object.assign({}, a);
c.b = 3;
b.b = 3;
console.log(a)
//a는 바뀌지 않는다
```
하지만 아래처럼 깊이가 2이상일 경우 다시 얕은 복사처럼 바뀌게 됩니다.
```js
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
}
let b = {...a}
let c = Object.assign({}, a);
c.c.d = 3;
console.log(a)
//a가 바뀌게 된다. 
``` 
그렇다면 어떻게 깊은 복사를 해야 할까요?

#### 재귀함수
재귀함수 copy가 재귀적으로 작동하면서 해당 value가 object임을 검사함과 동시에 null이 아님을 검사해서 객체가 만약에 또 있다면 또다시 재귀함수를 실행시키는 형식입니다.
```js
const copy = o =>{ 
    let out = {}; 
    let value, key;  
    for(key in o){
        value = o[key];
        out[key] = (typeof value === "object" && value != null) ? copy(value) : value;
    }
    return out; 
}
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
} 
let b = copy(a)
b.c.d = 4; 
console.log(a)
```  
#### JSON.parse와 JSON.stringify
이렇게 아예 문자열로 만든 다음에 다시 객체형태로 반환하는 방법이 있습니다. 
```js
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
} 
let b = JSON.parse(JSON.stringify(a))
b.c.d = 4; 
console.log(a)
``` 

그렇다면 스프레드 연산자와 `Object.assign`, 재귀함수 copy와 `JSON.parse(JSON.stringify)` 중에 뭘 써야 할까요? 그것은 프로젝트 때의 객체의 깊이와 객체안에 뭐가 담기는지 파악하고 성능테스트를 진행한 후 결정하면 됩니다. 

  > 필자는 프로젝트를 진행할 때 JSmatch를 통해 성능테스트를 했고 객체에 따라 JSON.parse가 더 좋을 때가 있고 copy가 더 좋을 때도 있었습니다.
 
### 3.2.3 서버요청최적화 - 메모이제이션과 서버요청최소화 
예를 들어 10mb짜리 API요청 10개와 100mb짜리 API요청 1개가 있습니다. 무엇이 빠를까요? HTTP2는 몰라도 HTTP에서는 전자가 더 느립니다. 서버요청은 최대한 줄여야 하며 중복되는 요청의 경우는 메모이제이션을 통해 재사용해야 합니다. 메모이제이션은 후에 실시간 데이터 프로젝트를 하며 살펴보도록 하겠습니다. 

### 3.2.4 UX향상 : LAZY load와 이미지크기 축소   
흔히들 UX를 향상시키자고 합니다. UX를 향상시킨다는 것은 홈페이지를 눌렀을 때 빠르게 뜨는 것이 포함이 됩니다. 여러가지가 있지만 이것은 제일 중요한 요소 중 하나입니다. 사용자가 처음 페이지를 켰을 때 필요한 것은 그렇게 많지 않습니다. 

**지금 사용자가 보고 있는 영역의 이미지만**이 필요할 뿐이고 그 아래의 이미지는 필요하지 않습니다. 그렇기 때문에 사용자가 보고 있는 영역의 이미지만 로드를 하면 될뿐이죠. 이렇게 추후 나중에 게으르게 이미지를 로드하는 것을  LAZY load라고 합니다. 

그렇다면 LAZY load는 어떻게 구현할까요? 
먼저 심플한 서버를 구축합니다. 

전에 구축했던 서버랑 비슷합니다. dist라는 폴더를 사용자에게 제공하는 서버입니다. 
```js
const express = require('express');
const path = require('path')
const app = express();
const _path = path.join(__dirname, './dist') 
app.use('/', express.static(_path)) 
app.listen(12010, ()=> {
  console.log('lazy 이미지서버 : 12010시작 http://127.0.0.1:12010');
});
```

html을 만듭니다. 트와이스 모모를 좋아하기 때문에 모모이미지 카드들로 만들어진 html파일입니다. 
```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./img_lazy.js"></script>

    <style> 
    ul{
        list-style-type: none; 
    }
    .cardWrap > li { 
        height: 500px; 
        margin-bottom: 100px;
        text-align: center;
    } 
    .cardWrap img{
        height: 100%;   
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    }
    </style>
</head>
<body> 
    <ul class="cardWrap">
        <li><img class="lazy" data-src="./img/1.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/2.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/3.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/4.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/5.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/6.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/7.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/8.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/9.gif" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/10.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/11.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/12.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/13.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/14.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/15.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li> 
    </ul>
     
</body>
</html>
``` 
![lazy_load전](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy.PNG)

정말 이쁜 예제 입니다. 하지만 15장의 이미지를 한꺼번에 로드하는 것은 부하가 큽니다. 자 이제 lazyload를 구현해봅시다. 


그냥 `document.querySelectorAll("img.lazy")`를 하면 유사배열인 NodeList로 배열의 메소드인 filter나 forEach를 쓰지 못합니다. 따라서 배열로 만들어 주어야 하므로 빈배열에 slice로 얕은복사를 하고 인자로 `document.querySelectorAll("img.lazy")` 넣으면 유사배열로 배열을 만들 수 있습니다. 200초마다 확인을 하면서 지금 내가 보는 화면을 `window.innerHeight`를 통해 파악해서 만약 이게 지금 lazyImage보다 더 멀리 있는 위치라면 lazy라는 클래스를 지우고 원래 이미지에 src에 할당합니다. dataset은 html의 `data-src="./img/15.jpg"`의 data-src를 말합니다. 이를 dataset.src로 접근을 할 수 있습니다. 

 > 그렇다면 data-큰돌은 data.큰돌로 접근이 가능하겠죠? 여러모로 응용이 가능한 dataset입니다. 

그리고 할 때마다 lazyImages를 갱신시킵니다. 이미 지웠다면 신경쓸 필요가 없겠죠? 그 이후 만약 길이가 없다면, 다 완료가 되었다면 removeEventListener로 이벤트를 지웁니다. 이렇게 하면 스크롤 할 때 흐릿한 이미지가 분명한 트와이스 이미지로 바뀌면서 구현이 되고, 처음에 15장의 이미지를 동시에 받지 않고 볼 때마다 받는 lazy-load가 완성이 됩니다. 

```js
document.addEventListener("DOMContentLoaded", function() {
    let lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));  
    let active = false;   
    const lazyLoad = function() {   
      if (active === false) {
        active = true; 
        setTimeout(()=> { 
          lazyImages = lazyImages.map((lazyImage) => {  
            if ((lazyImage.getBoundingClientRect().top <= window.innerHeight && lazyImage.getBoundingClientRect().bottom >= 0) && window.getComputedStyle(lazyImage).display !== "none") { 
              lazyImage.src = lazyImage.dataset.src;  
              lazyImage.classList.remove("lazy");    
              return null;
            }else return lazyImage;
          }).filter(image => image);
          if (!lazyImages.length) {
            document.removeEventListener("scroll", lazyLoad);
            window.removeEventListener("resize", lazyLoad);
            window.removeEventListener("orientationchange", lazyLoad);
          }else active = false;
        }, 200);
      }
    }; 
    document.addEventListener("scroll", lazyLoad);
    window.addEventListener("resize", lazyLoad);
    window.addEventListener("orientationchange", lazyLoad);
  });
``` 

자 완성한 모습입니다. 
스크롤 하기전에는 blur 모모 이미지가 뜹니다.
![스크롤하기전](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy1.PNG)

그러나 스크롤 한 후에는 실제 모모 이미지가 뜹니다. 완성입니다!
![스크롤하기후](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy2.PNG) 

라이브러리로는 lozad.js / yall.js 가 있습니다. 모두 똑같은 원리입니다. 보지 않는다면 placholder 이미지 또는 blur이미지를 셋팅하고 사용자가 본다면 실제로 보는 이미지를 놓으면 됩니다. 
이외에도 template를 사용하는 방법이 있지만 권장하지 않습니다. 

또한, 애초에 이미지의 용량을 줄이는 것도 중요합니다. 이미지 용량을 줄이는 사이트로는 https://compressjpeg.com/ 와 https://tinypng.com/ 를 추천합니다. 


 > 이 예제에서는 별도의 서버를 두었지만 굳이 서버를 두지 않고 index.html만 눌러도 잘 작동이 됩니다. 보다 실제 환경적인 예제를 위해 서버를 구축했습니다.

### 3.3 CSS 최적화 
자 이제 코드를 어떻게 짜는 지를 알았다면 스타일을 어떻게 짜는 것이 관건입니다. CSS를 팀원들끼리 어떻게 짜는지 맞추는게 추후 아름다운 코드를 위한 지름길입니다. 꼭 이렇게 안 맞춰도 됩니다. 하나의 예시입니다. 이런 식으로 프로젝트를 진행하기전 어떻게 코드를 짤 것인지를 맞춰야 합니다.

#### 1. 0은 px을 쓰지 않는다.
```css
article{
    margin:0;
    padding:0;
}
```

#### 2. short hand를 사용한다. 
```css
/* x */
article{
    margin-top:10px;
    margin-bottom:10px;
} 
/* o */
article{
    margin:10px 0px; 
} 
```

#### 3. CSS SPRITE이미지를 쓰자
서버요청을 줄이기 위해 반복되는 이미지는 한장의 이미지를 요청하고 background속성을 이용해서 이미지를 나타낸다.  

#### 4. 하위 선택자는 좀 더 깔끔하게 한다.  
`library book article`보다는 `library article`이 좋습니다. 

#### 5. repaint 와 reflow를 최소화 한다 

애니메이션을 할 때는  transform, filter, opacity를 사용해야 합니다. 
그냥 top, left를 걸어버리면 repaint와 reflow가 일어나는데 저 속성을 걸게 되면 GPU에 업로드되어 
repaint와 reflow가 일어나지 않습니다. 

 > 화면이 구성될 때 랜더링레이어와 그래픽레이어로 분리되며 구성이 되는데 렌더링레이어에 포함이 되면 reflow, repaint가 일어나며 그래픽레이어에 포함된다면 그것들이 안일어나며 GPU하드웨어 가속이 적용됩니다.  

예를 들어, 
```css
@keyframes swim {
  from {
    top:0px;
  }
  to {
    top:200px;
  }
}
```
이것 보다는 `transform`을이용해서 y축을 움직여야 합니다. 
또한 이걸 응용해서 어떠한 요소를 `style="transform:translateZ(0);"`를 통해 스타일에 CSS 3D속성인 translateZ를 걸게 되면 해당요소는 하드웨어 가속대상이 되게 되며 그 대상이 움직이거나 그럴 때 repaint와 reflow가 일어나지 않아 효율적이게 됩니다. 

 > 그러나 이렇게 GPU 하드웨어 가속에 걸게 되면 감빡거릴 수도 있으며, 성능이 낮은 기기에서는 성능저하를 가져올 수 있습니다.따라서 하드웨어 가속을 적용하는 요소의 크기를 줄이고 화면에서 몇개 단위로 구성하는 것이 좋으며 기기에 따라 선별적인 하드웨어 가속을 하게끔 해야 합니다.

#### 6. 스타일을 재사용한다. 
제일 중요합니다. 많은 컴포넌트들 사이에서 재사용할 클래스를 미리 지정해 놓고 사용하는 것이 중요합니다. 예를 들어 A컴포넌트에서 `display : flex`를 사용하는데 B 컴포넌트에서도 `display : flex`를 사용한다면 좋지 않습니다. 부모 컴포넌트에서  `display : flex`를 정의한 후 재사용하는 것이 좋습니다. 

이렇게 함수형프로그래밍 패러다임부터 시작해서 어떻게 코드를 짜는지 자바스크립트, css에서 살펴보았습니다. 이제는 실전입니다! 이제 예술품사이트를 만들고 실시간 데이터 시각화 프로그램을 만들 것입니다.