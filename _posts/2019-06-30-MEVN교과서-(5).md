---
layout: post
title: 'MEVN교과서 (5)'
author: kundol
comments: true
date: 2019-06-30 12:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (5)

---    

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_4장.jpg)
## 4. 실시간 데이터시각화사이트제작  
이제 드디어 실시간 데이터시각화사이트를 제작할 것입니다. 데이터를 시각화를 하기 위해서는 시각화 라이브러리가 필요합니다. D3.js, chart.js 등 많은 라이브러리를 비교하교 장점과 단점을 비교할 것입니다. 그 후 D3.js로 간단하게 사용법을 알아보고 지도, 증가하는 숫자모듈을 만들고 실시간통신과 차트모듈을 만들어보겠습니다.  

실시간통신을 위해서는 websocket사용은 필수입니다. 하지만 오래된 브라우저에서는 웹소켓자체가 구동되지 않습니다. 이를 위한 polling이라는 기법또한 알아볼 것입니다. 그 후 실제로 구현해보고 차트컴포넌트와 전에 만든 증가하는 숫자 모듈을 활용해 하드웨어 모니터링 시스템까지 완벽하게 알아보겠습니다.

### 4.1 시각화 라이브러리 D3.js
어떠한 데이터를 시각화하는 것은 중요한 일입니다. 같은 데이타라도 다르게 보여줄 수 있으며 효과적으로 내가 주장하는 바를 강하게 나타낼 수 있습니다.  
![콜레라지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2375B83653D9EED42D.jpeg)   
실제로 데이타 시각화는 사람을 살리는 일도 합니다. 

빅토리아 여왕 시대의 의사인 존스노우는 콜레라가 수인성 전염병이라는 것을 파악하기 위해 펌프가 있는 지역들을 위처럼 시각화 했고 이를 통해 콜레라가 펌프와 상관관계여부를 파악하고 규칙성을 찾아내었습니다.  

이러한 시각화를 도와주는 좋은 도구인 시각화라이브러리중 하나인 D3.js를 소개합니다.
D3를 사용하면 임의의 데이터를 DOM (Document Object Model)에 바인딩 한 다음 문서에 데이터 기반 변환을 적용 할 수 있습니다. 예를 들어 D3을 사용하여 숫자로 이루어진 배열에서 HTML 테이블을 생성 할 수있고 바차트, 선차트 등을 만들 수 있습니다.  이외에도 지도, flow, treemap, pie chart, 상호작용, 애니메이션 등 무궁무진하게 정말 많은 시각화적인 요소들을 만들 수 있습니다.
매우 작은 용량의 라이브러리로 정말 작은 부분 하나하나 세세하게 커스터마이징이 가능한 장점을 가지고 있습니다. 

#### 4.1.1 D3와 다른 시각화라이브러리 비교
무언가 프로젝트를 하기 위해 Stack을 설정할 때 다른 라이브러리와의 비교는 필수입니다. 그렇다면 현존하는 라이브러리와 D3.js를 비교해보겠습니다. 

2019년 7월 28일 기준입니다. 각 라이브러리의 최신버전을 통해 비교했습니다.

| 라이브러리 | 용량(min기준) | 러닝커브 | 활용도 |
|:--------|:--------| 
| chart.js	| 153kb | 쉬움 | 보통 |
| echarts.js | 729kb | 매우쉬움 | 보통 |
| three.js	| 562kb | 보통 | 높음 | 
| D3.js	| 237kb | 보통 | 매우높음 |

#### chart.js 버전 : 2.8.0
chart.js는 영역차트, 바차트, pie차트 등 차트에 국한 되어있습니다. 단순히 차트만 구현한다면 chart.js는 좋은 선택입니다. 

라인차트를 구현하는데 이정도의 코드만 있으면 됩니다.
```js
var ctx = document.getElementById('myChart').getContext('2d');
var chart = new Chart(ctx, { 
    type: 'line', 
    data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [{
            label: 'category', 
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }]
    }, 
    options: {}
}); 
```
#### echarts.js 버전 : 4.2.1
echarts.js는 사용하기가 매우 쉽습니다. 
라인차트를 구현하는데 이정도의 코드만 있으면 됩니다. 또한, geomap, Radar Chart, Heatmap, Graph, Treemap, flow 등 여러가지를 구현할 수 있습니다. 필자도 토이 프로젝트를 할 때 빠르게 차트를 구현하기 위해 echarts를 구현할 정도로 정말 쉽고 빠르게 만들 수 있습니다. 써보면 아시겠지만 chart.js보다 쉽습니다. 하지만 용량이 상당히 거대하기 때문에 큰 프로젝트에서는 추천하지 않습니다.
```js
option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};  
var myChart = echarts.init(document.getElementById("container"));
myChart.setOption(option, true);  
```

#### three.js 버전 : 0.106.2
three.js는 가장 유명한 자바스크립트 3D 라이브러리 중 하나입니다. 무겁기도 하고 하드웨어의 성능을 많이 잡아 먹기 때문에 모바일에서 이를 활용한 앱을 켰을 때 버벅거리는 증상이 나타나기도 합니다. 정말 많은 3D 차트 등을 구현할 수 있습니다. 자바스크리브로 3D를 구현하자면 필수적인 라이브러리입니다. 

#### D3.js 버전 : 5.9.7
D3.js는 3D는 아니지만 2D로 구현이 가능한 모든 시각화적인 것들을 구현할 수 있습니다. 차트, 맵은 기본이며 중력도 구현이 가능하며 워드클라우드, 플로우, 못하는 것이 없습니다. 하지만 D3.js를 이용하기 위해서는 데이타가 어떻게 그려지는지 원리부터 차근차근 알아가야 잘 쓸 수 있습니다. chart.js나 echart.js와는 달리 간단히 데이타만 넣으면 알아서 차트가 그려지지는 것과는 다르죠.  

원리를 알아가는 점은 번거러울 수도 있습니다. 하지만 조금만 노력을 기울인다면 D3.js는 최고의 선택일 것입니다. 237kb라는 작은 용량으로 정말 다양한 시각화적인 요소를 표현할 수 있다는 점과 매우 작은 부분 까지 커스터마이징하기가 쉽기 때문입니다. 그리고 만든사람이 무려 json의 창시자, 마이클 보스톡입니다. 최신 리액티브 프로그래밍을 반영하는 점이나 빠르게 업데이트하는 면도 눈여겨볼만한 부분입니다.

아래의 예제를 보시면서 [D3API주소](https://github.com/d3/d3/blob/master/API.md)를 보고 진행을 하셔도 좋고 도통 모르겠다 하시는 분들은 부록E로 넘어가서 D3.js의 기본적인 예제를 공부하시면 됩니다. 

### 4.2 D3.js : 지도매핑모듈
D3.js로는 많은 것을 만들 수 있습니다. 그 중에 하나가 바로 지도입니다. 

#### 4.2.1 topojson과 geojson비교
지도를 그리기 앞서 topojson과 geojson에 대해 알아봅니다. topojson이나 geojson 모두 지도를 그리기 위한 재료이자 지리적 정보들을 담고 있는 데이타 입니다. 다양한 지리적 데이터 구조를 표현하기 위해 인코딩된 json입니다.

좀 더 자세히 설명하자면, 그림을 그리는데 있어 레스터 방식과 벡터 방식이 있습니다. 레스터 방식은 이미지를 확대하면 깨지는 픽셀단위의 그림이며 벡터 방식은 픽셀데이터가 아닌 점,선,면 등 기하학적인 모양을 저장하며 확대하더라도 "깨지지 않는" 데이터 방식인 수학적 함수관계에 의해 만들어진 이미지방식을 말합니다. 이 벡터 방식을 가지고 있는 지리데이타 포맷중에는 geoJSON, topoJSON 등이 있으며 이번에 topojson을 쓸 것입니다.  

topojson은 각 구역들이 좌표들로 구성된 line으로 이루어져 경계들이 중복되는 geojson과는 달리 경계정보를 arc속성으로 이루어져 중복되지 않는 위상(topology)정보에 따라 인코딩 됩니다. 그렇기 때문에 geojson 보다 파일 사이즈가 작은 장점을 가지고 있습니다.(데이타의 범위마다 다르지만 약 80% 정도 가볍다고 합니다.) topology를 더 자세히 알고싶다면 [topology구현방법](https://bost.ocks.org/mike/topology/)을 참고 하면 됩니다. 

 * 하지만 데이타에 기하학적인 조정을 가한다면 geojson을 써야 합니다. 
 
 

#### 4.2.2 D3.js를 이용한 지도그리기 및 줌이벤트
이제 실제 코드로 넘어가서 하나하나 살펴보도록 하겠습니다. 코드가 약간 길기 때문에 차근차근 살펴보겠습니다. 4장에 미리 만들어 놓은 코드가 있습니다. 2장과는 다른 부분이 있어 다운받아서 진행하는 것을 추천드립니다.  

`npm install --save d3` 와 `npm install --save topojson`를 통해 우리가 필요한 도구, 외부 라이브러리들을 미리 준비합니다. 

#### 전체코드 : MEVN/4장/sensor/src/views/Map.vue 
```html
    
<template>
  <div class="Map"> 
    <div class="d3"></div>
  </div>
</template>
<script>
  import * as d3 from 'd3';
  import * as topojson from 'topojson'; 
  export default {
    name: 'Map', 
    mounted() {
      this.draw();
    },
    methods: {
      draw() { 
        const koreaMap = require('../assets/skorea-provinces-2018-topo-simple.json');
        const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_provinces_2018_geo);  

        const width = 600;
        const height = 1000;
        const svg = d3
          .select('.d3')
          .append('svg')
          .attr('width', width).attr('height', height);

        const projection = d3.geoMercator()
          .scale(1)
          .translate([0, 0]);

        const path = d3.geoPath().projection(projection);
        const bounds = path.bounds(_map);

        const widthScale = (bounds[1][0] - bounds[0][0]) / width;
        const heightScale = (bounds[1][1] - bounds[0][1]) / height;
        const scale = 1 / Math.max(widthScale, heightScale);

        const xoffset = width / 2 - scale * (bounds[1][0] + bounds[0][0]) / 2 + 10;
        const yoffset = height / 2 - scale * (bounds[1][1] + bounds[0][1]) / 2 + 80;
        const offset = [xoffset, yoffset];
        projection.scale(scale).translate(offset);

        const map = svg.append('g')
          .selectAll('path').data(_map.features)
          .enter().append('path')
          .attr('d', path);
          
        const mapInfo = [{
            "name": "서울",
            "lat": "37.532600",
            "lon": "127.024612"
          },
          {
            "name": "대전",
            "lat": "36.3730178",
            "lon": "127.2483736"
          }
        ]

        const icons = svg.append('g').selectAll('svg')
          .data(mapInfo)
          .enter()
          .append("svg:image")
          .attr("width", 50)
          .attr("height", 50)
          .attr('x', d => projection([d.lon, d.lat])[0])
          .attr('y', d => projection([d.lon, d.lat])[1])
          .attr('opacity', 1)
          .attr("xlink:href", require("../assets/grapefruit.svg"))

        const zoomed = () => {
          map.attr('transform', d3.event.transform)
          icons.attr('transform', d3.event.transform);
        }
        const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
        svg.call(zoom)
      }
    }
  }
</script>
<style>
  .hello {
    width: 100%;
  }

  .d3 {
    background: #eee;
    width: 618px;
    height: 1000px;
    margin: 0 auto;
  }

  path {
    fill: #ed8b70;
    stroke: #de6a6c;
  }
</style>
```

하나하나 차근차근 알아보도록 하겠습니다. 
```js
import * as d3 from 'd3';
import * as topojson from 'topojson';
```
D3와 topojson을 `import` 시킵니다. 
이 불러오는 방법은 ES6모듈 포맷방식입니다.  

 > 참고 : 자바스크립트 모듈문법

자바스크립트 모듈문법 중 CommonJS모듈과 ES6모듈 포맷이 있습니다.
 * UMD와 AMD, System.register 모듈 포맷 방식은 여기서 설명하지 않습니다.

CommonJS 포맷은 Node.js에서 사용되며 `require`와 module.exports를 사용해서 의존성과 모듈을 정의합니다. 
```js
const a1 = require('./a1.js')
const a2 = require('./a2.js')

module.exports = function (){

}
```
위와 같은 형식입니다.

ES6 모듈 포맷은 import와 export를 사용합니다. 
```js
//특정 함수인 mapC만을 가져올 수 있으며
import { mapC } from 'fxjs';
//전체를 다 불러서 d3란 네임스페이스를 지정할 수 있습니다.
import * as d3 from 'd3';

export default curry(function mapC(f, iter) {
  return takeAllC(mapLazy(f, iter));
}); 
```

#### 1) topojson을 이용한 지도정보 설정
```js
const koreaMap = require('../map/skorea_municipalities_topo_simple.json');
const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_municipalities_geo); 
```
우리나라 topojson파일을 로드하고 `topojson.feature`을 통해 _map이라는 변수에 맵에 관련된 정보를 할당합니다.  

#### 2) 그림을 그릴 영역설정
```js 
const width = 600;
const height = 1000;
const svg = d3
.select('.d3')
.append('svg')
.attr('width', width).attr('height', height); 
```
기본 셋팅입니다. 우리가 그릴 캔버스를 설정해 놓읍시다. `class="d3"`를 가지고 있는 DOM에 `svg`태그를 `append`시키고 그 영역에 width의 값과 height의 값을 설정합니다. 그리고 그 svg에 우리가 map을 만들것이기 때문에 많은 요소들이 들어갑니다. 그러므로 group으로 감싸줘야 하므로 g태그를 붙입니다. 

이것이 D3로 시각화하는 첫단계입니다. 
1. 재료를 선택하고(topojson) 
2. 그 재료를 쓸 캔버스를 설정합니다(select, append, attr)

#### 3) projection 설정
```js
const projection = d3.geoMercator()
.scale(1)
.translate([0, 0]); 
```
이 지도의 투사법은 메르카토르 투사법을 씁니다. 지구는 동그라한 구형태이기 때문에 이를 평면에 펼쳐서 보기 위해서는 투사법이 존재하며 그 중 메르카토르 투사법을 쓸 것입니다. 메르카토르투사법, 초기 스케일, 처음에 이 투사법을 가진 프로젝터를 얼마나 이동시킬 것인가를 정하고 projection 이라는 변수에 객체를 셋팅합니다. 지구를 어떤 프로젝터로 멀리서 켜서 비친 지점들을 지도로 나타낸다고 상상하면 쉽습니다. 

 > 이외에도 Orthographic이라는 투사법도 있습니다. 
 
#### 4) bounds
```js
const path = d3.geoPath().projection(projection);
const bounds = path.bounds(geojson); 
```
`projection`을 통해 그리는 지도인 path 객체를 만들고 bounds를 통해 y축 끝값, x축 끝값을 걸정합니다. 이를 통해 그 path의 중앙설정을 할 수 있습니다. 이는 우리나라 지도의 중앙이겠죠?

bounds의 1차원배열은 path의  xmax와 xmin을 가리킵니다. bounds[0][x].. 의 0에서 0, 1을 통해 xmax와 xmin을 나타낼 수 있습니다.  즉, 최소경도, 최대경도(longitude)를 가리키게 됩니다. 
bounds의 2차원배열은  ymax와 ymin을 가리킵니다. bounds[x][0]..의 0에서 0, 1을 통해 ymax와 ymin을 가리킵니다. 즉, 최소위도, 취대 위도를 가리킵니다. (latitude)

 > bounds 그림 추가 (수정예정)

#### 5) scale
 
```js
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height;  
const scale = 1 /Math.max(widthScale, heightScale); 
```
그 다음 스케일을 정의해줍니다. 이 스케일은 지도에서 축척을 의미합니다. 넓은 우리나라 땅덩어리를 우리는 작은 화면에 표시해야 합니다.  일단 우리가 구한것은 path의 가장자리를 구한 것입니다. 
이것중에서 가장 최대값을 구하고 이를 이용해서 축척을 만들어줍니다. 5만배의 축소율을 가진 지도를 표시할 때 1 : 50000이라고 나타내며 이는 1 / 50000이라고도 합니다. 똑같이 우리는 축척을 1 / maxScale로 나타낸 것입니다.    

#### 6) translate
```css
.center {
  position: absolute;
  left: 50%;
  top: 50%; 
  transform: translate(-50%, -50%); 
}
```
어떠한 물건을 중앙에 놓으려면 어떻게 해야 할까요? 우리는 위의 코드처럼 left와 top을 50%씩 설정하고 자신의 크기만큼 translate를 -50%씩 주면 됩니다. 우리가 흔히 css로 어떠한 영역을 가로, 세로 중앙 정렬할 때 쓰는 방법이죠. 
```js
const xoffset = width/2 - scale * (bounds[1][0] + bounds[0][0]) /2 + 10; 
const yoffset = height/2 - scale * (bounds[1][1] + bounds[0][1])/2 + 80; 
const offset = [xoffset, yoffset];
projection.scale(scale).translate(offset);
``` 
지도도 또똑같습니다.  
 
위의 코드처럼 translate로 일단 사물을 옮기고 그 사물의 "크기의 50%" 만큼 또 옮깁니다. 똑같이 우리가 보여주는 크기의 반인 bounds의 반을 xoffset, yoffset으로 지정하고 translate를 통해 **중앙**으로 옮기면 됩니다. 

#### 7) selectAll
```js
map
.selectAll('path').data(_map.features)
.enter().append('path') 
.attr('d', path);  
``` 
D3.js에서 가장 중요한 구조가 뭐냐고 묻는다면 단연코 `.selectAll(요소).data(데이타).enter().append(요소)` 일 것입니다. 데이타 만큼의 가상 DOM을 생성 후 selectAll, 그 DOM에 데이타의 개수만큼(data) 특정 요소들을 붙이는 (enter & append)것을 이 4가지의 메소드 체인으로 구성할 수 있습니다. _map.features라는 지역적정보를 바탕으로 path를 만들 수 있습니다.

#### 8) 자몽을 놓을 위도 경도에 따라 매핑하기 
```js 
  const mapInfo = [
    {
      "name":"서울",
      "lat" : "37.532600",
      "lon" : "127.024612"
    },
    {
      "name":"대전",
      "lat" : "36.3730178",
      "lon" : "127.2483736"
    }
  ] 
```
우리는 자몽이라는 아이콘을 놓을 것입니다. 자몽에 해당하는 lat(위도), lon(경도)를 설정합니다.  
```js
const icons = svg.append('g').selectAll('svg')
.data(mapInfo)
.enter()
.append("svg:image")
.attr("width", 50)
.attr("height", 50)
.attr('x', d => projection([d.lon, d.lat])[0])
.attr('y', d => projection([d.lon, d.lat])[1])
.attr('opacity', 1)
.attr("xlink:href", require("../assets/grapefruit.svg"))
```  
이렇게 매핑을 하면 됩니다. 우리가 만들어 놓은 위경도 자료 만큼 svg를 붙이는(append) 하는 것입니다. 저렇게 attr을 이용해서 가로 세로, x좌표, y좌표, 투명도를 설정해주면 됩니다.  
 
#### projection 
```js
  function projection(point) {
    point = projectRotate(point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
    return [point[0] * k + dx, dy - point[1] * k];
  }
```
 * v5에서 달라진 부분존재 추후 수정예정

projection 메소드가 궁금할 것같아서 준비했습니다.  위경도에 해당하는 값을 배열로 받아서 첫번째에 그 투사법으로 추출되는 x, 경도를 반환하고 y, 위도를 반환합니다.  

​ 
#### 줌이벤트 
```js
const zoomed = () =>{
  map.attr('transform', d3.event.transform)
  icons.attr('transform', d3.event.transform)
}
const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
svg.call(zoom)
```
줌이벤트는 간단합니다. 이렇게 줌을 걸어주고자 하는 group에 transform 특성에 해당 event를 추가하고 zoom이 큰 svg에서 발동할 때마다 미리 설정해 놓은 이벤트들이 작동하게끔 설정해주면 됩니다. call은 자바스크립트의 call을 생각하면 됩니다.

#### call
```js
const 큰돌 = {
    "이름": "큰돌"
}

function editmyresume(능력, 힘) {
    this.능력 = 능력
    this.힘 = 힘
} 
editmyresume.call(큰돌, "Vue.js", "팔굽혀펴기") 
console.log(큰돌)
```
어떠한 함수를 실행하는데 객체를 넣어서 기본값을 설정할 수 있습니다. 

이제 다 만들었습니다.  결과물은 다음과 같습니다. 

![자몽지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_지도.gif)  


이렇게 D3.js를 이용해서 가벼운 지도예제를 만들어 보았습니다. 그 외에도 많은 것들을 D3.js로 구현할 수 있습니다. 다양한 예제들은 https://bl.ocks.org/mbostock 를 통해 볼 수 있습니다.
 
### 4.3 D3.js : 증가하는 숫자
좀 더 재밌는 예제를 만들어보도록 하겠습니다. 보통 게이지가 차면서 숫자가 증가하는 애니메이션 많이들 보죠? 그러한 것을 구현해보겠습니다.  

#### 전체코드 : MEVN/4장/sensor/src/views/Number.vue 
필수적인 코드만 차근차근 살펴보겠습니다. 
```html
<template>
  <div class="hello">
    <h2>커져가는 원속의 숫자 + 게이지</h2>
    <svg></svg> 
  </div>
</template>

<script>
  import * as d3 from 'd3';   
  export default {
    name: 'HelloWorld3',
    data() {
      return { 
      }
    },
    mounted() {
      this.showCircle();
    },
    methods: {
      showCircle() {  
        const width = window.innerWidth - 20;
        const height = window.innerHeight - 20; 
        const radius = Math.min(width, height) / 3;    
        const format = d3.format(".0%");  
        const group = d3.select("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
        const textDOM = group.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", ".3em");
          
        const arc = d3.arc()
          .innerRadius(radius * 0.7)
          .outerRadius(radius); 
        const pieGenerator = d3.pie().sort(null)
        const background = group.append("path")
          .data(pieGenerator([1])) 
          .attr("class", (d, i) =>"backColor") 
          .attr("d", arc)

        const foreground = group.append("path")
          .data(pieGenerator([0, 100])) 
          .attr("class", (d, i) =>`frontColor${i}`) 
          .attr("d", arc)
 

        function arcTween(pie){
          return function(d){ 
            const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
            const interpolateText  = d3.interpolate(0,pie[0].value); 
            return function(t){
              d.endAngle = interpolate(t);
              textDOM.text(format(interpolateText(t) / 100));
              return arc(d);
            }
          } 
        }   
        foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
      }
    }
  }

</script> 
<style>
  path.backColor {
    fill: #ff9c00;
  }
  path.frontColor0 {
    fill: #545f73;
  }
  path.frontColor1 {
    fill: #ff9c00;
  }  

  text {
    font-size: 7em;
    font-weight: 400;
    line-height: 16em;
    fill: black;
    font-family:오버워치;
  }
  @font-face {
    font-family: 오버워치;
    src: url(../assets/koverwatch.woff2);
  } 

</style>

```
#### 4.3.1 화면 설정 및 반지름설정
```js
const width = window.innerWidth - 20;
const height = window.innerHeight - 20; 
const radius = Math.min(width, height) / 3;  
```
현재 위도우의 width와 height에 맞춰 width, height를 잡고 그에 따라 반지름을 잡습니다.
#### 4.3.2 format설정 
```js
const format = d3.format(".0%"); 
``` 
d3.format을 이용하면 쉽게 어떠한 숫자에 포맷을 설정할 수 있습니다. 예를 들어 `1f`는 소수점1자리까지, `.0%`는 퍼센트 단위로도 가능합니다.  
#### 4.3.3 영역설정
```js
const group = d3.select("svg")
.attr("width", width)
.attr("height", height)
.append("g")
.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");     

const textDOM = group.append("text")
.attr("text-anchor", "middle")
.attr("dy", ".3em");
```
전과 똑같이 svg를 선택(select)를 하고 attr-width, height로 영역을 설정하고 transform 으로 중앙정렬합니다.  그리고 증가하는 숫자를 담을 text라는 요소를 설정합니다. 

#### 4.3.4 파이 제너레이터
```js
const arc = d3.arc()
.innerRadius(radius * 0.7)
.outerRadius(radius); 
const pieGenerator = d3.pie().sort(null)
const background = group.append("path")
.data(pieGenerator([1])) 
.attr("class", (d, i) =>"backColor") 
.attr("d", arc)

const foreground = group.append("path")
.data(pieGenerator([0, 100])) 
.attr("class", (d, i) =>`frontColor${i}`) 
.attr("d", arc)
``` 
숫자를 중심으로 증가하는 원을 만들기 전에 설정을 해야 합니다.`d3.arc().innerRadius(radius * 0.7).outerRadius(radius)` pie를 설정할 때 안쪽반지름(inner), 바깥쪽의 영역(outer)를 설정합니다. 안쪽을 0.7로 설정을 했으므로 안이 좀 비어있는 파이를 만들 수 있습니다.  그리고 `pieGenerator`를 이용해서 특정 배열을 통해 pie 제너레이터를 만듭니다. 그 제너레이터로 정확한 도넛형태의 모양을 그릴 수 있습니다.  

#### 4.3.5 애니메이션
```js
function arcTween(pie){
  return function(d){ 
    const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
    const interpolateText  = d3.interpolate(0,pie[0].value); 
    return function(t){
      d.endAngle = interpolate(t);
      textDOM.text(format(interpolateText(t) / 100));
      return arc(d);
    }
  } 
}   
foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
```
대망의 애니메이션입니다. 
interpolate는 2가지의 값을 이용해서 0부터 1까지의 값에 매핑을 합니다. 예제를 보면 쉽습니다.  
```js
var i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20
```
보간하다라는 뜻을 가진 이 interpolate는 주어진 2개의 값을 이용해서 그 사잇값들을 만듭니다.
이를 이용해서 우리는 애니메이션을 만들 수 있습니다. `pieGenerator([0, 100])`에서 부터 `pieGenerator([80, 20])`까지의 애니메이션을 하기 위해 `arcTween`이라는 것을 만들었습니다. 애니메이션을 사용하려면 매 순간순간마다 프레임이 있어야 하며 `arcTween`을 이용하면 매 순간 원에 해당한 정확한 path를 만들 수 있기 때문이죠

![증가하는 숫자](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_number.gif) 
  
### 4.4  실시간 센서시각화사이트 : 설계
이제부터 실시간 센서시각화사이트를 본격적으로 만들어 볼 것입니다. 
#### 4.4.1 아키텍처 구축
아키텍처를 구축해야 합니다. 어떻게 만들 것인지 그림으로 그려보는 것이 중요합니다. 
![아키텍처](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처.png) 

아주 간단한 아키텍처입니다. 센서를 내보내는 REST API를 통해 JSON형태의 센서를 받아 MongoDB에 저장한 후 그 값을 뽑아 내어 상태저장소인 Vuex를 통해 상태를 변이시키고 이를 통해 Chart로 표출하는 아키텍처입니다.

 > 참고

사실 아키텍처는 회사에서 정해주거나 팀원들끼리 정한 약속에 의한 양식에 맞춰 작성하는 것이 일반적입니다. 하지만 혼자 만들 때는 이렇게 아무렇게나 그려보면 됩니다. 아무렇게나 그려도 프로젝트를 설계할 때 그리는 것은 매우 중요하며 습관이 되어야 합니다.
보통 아키텍처를 그릴 때 아마존에서 사용하는 아이콘을 자주 사용합니다. 
![아키텍처_아마존](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처_아마존.png)
이 아이콘은 [아이콘링크](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/아마존아이콘.ppt) 를 통해 바로 다운 받을 수 있습니다. 참고하시길 바랍니다. 
 
#### 4.4.2 실시간 통신 : websocket방식과 polling 방식 비교  
실시간 통신이란 보통 Websocket으로 통신한다는 것은 HTTP를 기반으로 설정된 **ws프로토콜**을 통해 양방향통신을 하는 것을 말합니다.WebSocket 객체를 통해 양방향통신을 하는데 이 객체는 서버와의 WebSocket 연결을 생성하고 관리할 수 있는 API 들을 제공하며 가장 유명한 라이브러리로는 Socket.io가 있습니다. 하지만 오래된 브라우저의 경우(IE9이하) [caniuse-websocket](https://caniuse.com/#search=websocket)미지원되므로 이 때는 websocket이 아닌 polling 방식, 주기적인 요청 또는 long polling, RESPONSE 받게 되면 REQUEST를 다시 요청(무한 재귀함수)로 구현해야 합니다. 

 > Q : Ajax랑 다른점이 뭔가요? 
 
클라이언트에서 요청하지 않아도 서버에서 클라이언트에게 원하는 시간대에 원하는 데이타를 줄 수 있다는 점입니다. 

#### 4.4.3 센서생성 서버 구축
센서데이타서버를 구축하는 방법은 크게 3가지가 있습니다. 첫번째는 정말 센서를 사서 구축하는 것이며 두번째는 기상청 Open API를 받는 것이며 세번째는 방재기상포털의 있는 파일을 통해 구축하는 방법입니다. 우리는 세번째 방법으로 해보겠습니다. 날짜는 2019년 8월2일 기준으로 했으며 지역은 제가 사는 강동구를 중심으로 했습니다. 방재기상포털은 https://data.kma.go.kr 에 가면 정말 쉽게 자료들을 다운받을 수 있으며 여기서 구축하는 예제의 파일은  MEVN/4장/sensor/RESTAPI/data/20190802_강동구.csv 에 저장해 두었습니다.  

```js
id,time,temp,wv,humi
402,2019-08-02 00:01,26.2,.4,85.7
...
```
데이타입니다. 한국말로 되어있는 것을 영어 key값으로 수정했습니다. 이를 mongoDB에 저장할텐데 MongoDB에 저장할 때 key값의 용량도 함께 들어가기 때문에 키값을 축소시키는 것이 중요합니다. windvelocity는 wv로 수정했고 humidity는 humi를 썼습니다. 

센서를 만드는 로직은 이렇게 cnt라는 전역변수를 통해 구현할 수도 있으며 제너레이터를 이용해서도 구현할 수 있습니다. 
먼저 cnt를 이용한 예제입니다. 

일단 먼저 유저를 추가합니다. 
```shell
 > db.createUser({  
 user:"dabin",
 pwd:"dabin12010",
 roles:[  
  {  
     role:"readWrite",
     db:"sensor"
  }
 ],
 mechanisms:[  
  "SCRAM-SHA-1"
 ]
})
```
다빈, dabin이라는 이름을 가진 user를 추가했습니다. 이 때 sensor라는 DB를 만들지 않았다면 test라는 DB에 자동적으로 user가 추가가 됩니다.  

 > 참고 : sensor DB 생성하기
 
 ---- 

1. mongo shell을 구동합니다.
2. sensor데이타베이스로 이동 `use sensor` 
3. 데이타베이스확인 : `show dbs` 아직 sensor가 생성되지 않았습니다.
4. 데이타베이스 생성, db.sensor.insert({"kundol" : 1})
5. 데이타베이스확인 : `show dbs` sensor DB가 생성되었습니다!

 ---- 

이제 앞서 설명한 createUser을 하면 sensor에 다빈이가 추가된 것을 볼 수 있습니다. `db.getUsers()`로 유저를 확인할 수 있습니다.

자 이제 본격적으로 센서 서버를 만들어보겠습니다.  
#### MEVN/4장/sensor/서버/server.js
```js
const express = require('express')
const app     = express()
const cors    = require('cors')
const http    = require("http").createServer(app)
const io      = require('socket.io')(http)
const util    = require('./util')()
const sensorController = require('./controller/sensor')
const path    = require('path')  
const _path   = path.join(__dirname, '..', './dist')  
const PORT    = 12010 
const mongoose = require('mongoose') 
const USER = 'dabin'
const PWD = 'dabin12010'
const HOST = 'localhost:27017'
const DB = 'sensor'
const mongodbURL = `mongodb://${USER}:${PWD}@${HOST}/${DB}`  // -- (1)
let userList = [];
const main = async()=>{
  //app 객체 설정 
  app.use('/', express.static(_path))  
  app.use(cors()) 
  // MongoDB connect 설정
  mongoose.connect(mongodbURL, {useNewUrlParser: true}) 
  .then(() =>  console.log('connection succesful'))
  .catch((err) => console.error(err)) 
  mongoose.set('useFindAndModify', false);
  let toIdx = 10; 
  //io 객체 설정 
  const jsonArray = await util.readCSV();   // -- (2)
  io.on('connection', async (socket) =>{  
    console.log(`User connected :: ${util._date()} ID : ${socket.id}`)   
    userList.push(socket.id)  // -- (3)
    socket.on('disconnect', () => {  
      console.log(`User disconnected :: ${util._date()} ID : ${socket.id}`)  
      userList.splice(userList.indexOf(socket.id),1); 
    });       
    const sensor_first = await sensorController.emitSensorAndSaveStart(io, jsonArray, toIdx);  // -- (4)
    console.log(`Send to user Current Sensor And Save DB in first :: ${util._date()} ${sensor_first}`)    
  });   
  //센서데이타는 항상 받자 마자 emit을 해줘야 한다. 그 부분을 재현 
  const sensor = await sensorController.emitSensorAndSave(io, jsonArray);   // -- (5)
  toIdx = sensor.idx; 
  setInterval(async () => {    
    const sensor = await sensorController.emitSensorAndSave(io, jsonArray);  
    toIdx = sensor.idx;  
    console.log(`Send to user Current Sensor And Save DB :: ${util._date()} ${JSON.stringify(sensor)}`) 
  }, 1 * 1000); 
  http.listen(PORT, ()=> console.log(`센서서버가 시작됩니다. http://127.0.0.1:${PORT} :: ${util._date()}`)); // -- (6)
}
main();   
``` 
server.js입니다. 고작 50줄밖에 되지 않습니다. 이렇게 main서버는 항상 작게 만들고 모듈화를 시키는 것이 중요합니다. 이 서버는 단순한 센서 서버라서 sensorController라는 컨트롤러밖에 없지만 컨트롤러가 많아진다면 이 모듈화 방법은 정말 효율적이게 될 것입니다. 각각의 역할을 지닌 로직 별로 모듈화를 시키는 것은 항상 중요합니다. 또한, 주석을 달 때 첫번째 문자는 반드시 대문자로 해주어야 합니다. 


각각의 코드 설명입니다. 
1) 아까 만들었던 계정을 통해 mongoDB에 연결 합니다. DB는 sensor를 씁니다. 
2) 센서서버 자료를 읽어 옵니다. 자료는 2019년 8월 2일 여름의 강동구 기상 센서 자료입니다. 
3) connection되었을 때의 이벤트입니다. 단말기(유저)가 연결되었을 때 userList에 넣어서 관리를 합니다. class로도 할 수 있습니다. 간단하게 배열로 구축했습니다.
4) 처음에 connection되었을 때 지금의 toIdx까지 센서자료를 전달합니다. 예를 들어 지금 센서생성서버가 13의 idx를 가진 센서를 생성한다면 3부터 13까지의 10개의 센서 자료를 보내서 기본 차트를 그리도록 합니다. 
5) 센서생성서버는 항상 코든 유저에게 io.emit 이벤트를 통해 센서를 보내는 부분입니다. 
6) 서버를 생성하는 부분입니다. 보통 socket.io 와 실시간 통신을 하는 http 서버를 만들 때 이렇게 서버를 구축합니다.

```js
const http    = require("http").createServer(app)
const io      = require('socket.io')(http)
...
http.listen(PORT, ()=> console.log(`센서서버가 시작됩니다. http://127.0.0.1:${PORT} :: ${util._date()}`));

``` 


![toIdx설명](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4장_toIdx.png)
4번에 대한 설명을 하기 위한 그림입니다. 
센서는 1초마다 생성이 되는데 그 때 유저가 들어왔을 때 toIdx까지 보내기만 하면 쉽게 그 이전의 초기 센서값들을 보낼 수 있습니다. 
  
#### MEVN/4장/sensor/서버/models/senser.js
```js
const Sensor = require('../models/sensor.js'); 
const _ = require("fxjs/Strict");  
const start_CNT= 10; 
const save = async(data)=> { // --- (1)
    const ret = await Sensor.findOneAndUpdate({
        "cnt" : {
            $eq : data.cnt
        }}, {
            $set : data
        }, {
            upsert: true, 
            multi: true, 
            new : true, 
            setDefaultsOnInsert: true
        }
    ).lean()
    return ret;  
};

const setType = data =>{ 
    for(let key in data){ // --- (2)
        if(key == 'time')data[key] = new Date(data[key])
        else data[key] = Number(data[key])
    } 
    return data; 
}

// 전역변수로 증가시키는 setNextData
let cnt = start_CNT;   
const setNextData = (jsonArray) =>{ 
    const l = jsonArray.length;    
    let data = jsonArray[cnt];  
    data = {cnt : cnt, ...setType(data)} 
    cnt = (cnt + 1) % l; 
    return data;    
}  

// 이터레이터로 만드는 cnt
function *setCntIterator() {  
    let cnt = start_CNT;   
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
}  
const iterator = setCntIterator(); 
const setNextDataIterator = (jsonArray) =>{
    const l = jsonArray.length;      
    const cnt = iterator.next().value;   
    const idx = cnt % l; 
    let data = jsonArray[idx];   
    data = {idx : idx, ...setType(data)};
    return data;    
}

//slice를 이용한 take from to
const takeFromTo = (from, to, a) =>{
    if(to < from)return [...a.slice(from), ...a.slice(0, to + 1)] 
    else return a.slice(from, to + 1)
}  

//이터레이터를 이용한 take from to
function *setFromIterator(from) {  
    let cnt = from;  
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
}    
const takeFromToIterator = (from, to, sensors)=>{ 
    const l = sensors.length;   
    const cnt = to < from ? l - (from - to - 1) :  to - from  + 1
    return _.go( // --- (3)
        setFromIterator(from), 
        _.take(cnt), 
        _.map(e => sensors[e % l])
    )
} 

exports.emitSensorAndSave = (io, jsonArray)=>{
    return new Promise((resolve, reject) =>{
        //const data = setNextData(jsonArray) 
        const data = setNextDataIterator(jsonArray)    // --- (4)
        io.emit("sensor", data); 
        save(data); 
        resolve(data)
    }) 
} 
exports.emitSensorAndSaveStart = (io, jsonArray, toIdx)=>{
    const l = jsonArray.length
    const from = toIdx - start_CNT < 0 ? (toIdx - start_CNT + l) % l : toIdx - start_CNT
    const to = toIdx  
    return new Promise((resolve, reject) =>{  
        let data = takeFromToIterator(from, to, jsonArray)  
        io.emit("sensor", data); 
        save(data); 
        resolve(data)
    }) 
} 
```
센서 생성서버의 중심이 되는 sensor.js입니다. 코드별로 설명하겠습니다. 
1) save입니다. 데이타를 받아서  "cnt" :{ $eq : data.cnt} cnt에 맞는 것을 찾아서  $set : data, data를 udpate 시킵니다..
2) for in을 객체에다 쓰면 객체의 모든 key와 value들에 대한 로직을 구현할 수 있습니다. MongoDB에 넣기 전 스키마에 맞는 형식으로 변환해줍니다. 
3) 배열의 요소중 from부터 to까지 끄집어내는 모듈입니다. from 부터 시작해 ` setFromIterator(from)`이 from부터 시작하는 이터레이터를 만들어서 그 from부터 `_.take(cnt)` cnt까지의 배열 idx를 뽑아냅니다. 그 후 `_.map(e => sensors[e % l])`그 idx에 맞는 센서데이타를 할당해서 그 만큼의 센서데이터들을 뽑아냅니다.  
4) 가장 중심이 되는 `emitSensorAndSave`입니다. idx에 해당하는 센서 데이타를 뽑아 내서 `io.emit("sensor", data);` 모든 단말기에 `sensor`이벤트로 data를 보내고 `save`, MongoDB에 저장을 합니다. 그 후 `resolve(data)`를 통해 Promise문을 탈출합니다. 

#### MEVN/4장/sensor/서버/util/index.js
```js
const csvFilePath = '../data/20190802_강동구.csv' 
const csv         = require('csvtojson') 
const path        = require('path')  
const _path       = path.join(__dirname, csvFilePath)  
 
const _form = date => ("00" + date).slice(-2)   
module.exports = () => {
    return {
        async readCSV() {
            //const jsonArray = await csv().fromFile(csvFilePath);
            return await csv().fromFile(_path);
        }, 
        _date(){
            const d = new Date(); 
            return `${d.getFullYear()}-${_form(d.getMonth() + 1)}.${_form(d.getDate())} ${_form(d.getHours())}:${_form(d.getMinutes())}:${_form(d.getSeconds())}`
        }
    };
} 
```
서버에 전체적으로 필요한 도구들이 담겨있는 util입니다. csv 파일을 읽는 readCSV는 `csvtojson`이라는 npm 모듈이 await / async를 지원하기 때문에 await로 쉽게 구축할 수 있습니다. `const _form = date => ("00" + date).slice(-2)`을 통해 8을 08로 바꾸고 12는 그대로 12로 내버려두게 하여 아름답게 로그를 08-08 06:30 이런식으로 구축할 수 있게 했습니다. 
 

 > 참고 : socket, broadcast, io.emit 차이

 ----

 실시간 통신은 아래의 표로 구분됩니다. 
  
| 이름 | 설명 | 사용법(socketio) | 
|:--------|:--------|:--------|
| public	| 1 : n - 1 통신, 보내는 유저 제외 모든 유저에게 메세지전달 | socket.broadcast.emit('이벤트이름', message) 	|
| private	|1 : 1 통신, 특정 유저에게 메세지가 전달	|  io.to(소켓아이디).emit('이벤트이름' message) |
| private	| 1 : 1 통신, 연결되었을 때의 socket을 통해 그 유저에게만 메세지가 전달 	| socket.emit('이벤트이름', message)	|
| broadcast	| 1 : n 통신, 모든 유저에게 메세지가 전달 	| io.emit('이벤트이름', message)	|  

 ----

### 4.5  실시간 센서시각화사이트 : 실시간통신과 디자인 
백엔드를 구축했으니 이제 프론트엔드를 구축할 것입니다. 

#### 4.5.1 Vuex 및 프로젝트 뼈대 구축
Vuex를 써야 하는 이유는 간단합니다. 컴포넌트끼리 데이터를 주고 받으려면 props, emit으로 주고 받게 되는데 프로젝트가 커진다면 데이터를 전달하고 받는 컴포넌트간의 갯수가 많아지고 체크하기도 어렵기 때문입니다. 
중앙집중화된 어떠한 데이타들의 관리 / 어떠한 데이타들이 변환되는 것을 감시(watch)하고 싶다면 쓰는 것입니다. Vuex를 쓸 때는 비동기적인 것은 actions에 그 외 동기적인 것은 mutations에 넣어야 합니다. 그리고 state의 상태변이에 있어서는 꼭 mutations를 써야 합니다. 즉, actions에서 직접적으로 state를 수정하면 안됩니다. actions에서 mutation으로 commit을 통해 넘겨줘야 하며 mutations에서 state를 수정해야 합니다. 또한 반드시 모듈화를 해야 합니다. 

store에 actions.js, mutations-type.js, mutations.js, state.js를 만듭니다. 

#### MEVN/4장/sensor/src/store/actions.js
```js
export default {
    initGetSensor({commit}, socket) { 
        socket.on("sensor", data => commit("CHANGE_SENSOR_CHART", data)) 
    }
};
```
actions에는 비동기이벤트를 받아 commit을 통해 mutations에다가 payload를 넘기는 일을 넣으면 됩니다. 

#### MEVN/4장/sensor/src/store/mutations.js
```js
import * as types from './mutations-type'; 
  export default {
    [types.CHANGE_SENSOR_CHART](state, payload) {    
        if(!state.sensors.length){ 
          state.sensors = payload; 
        }else {
          state.sensors.shift(); 
          state.sensors.push(payload);
        } 
    }
} 
```
mutations입니다. type에 해당하는 mutation이 담겨있습니다. 우리는 처음 10개의 센서데이타 배열을 받은 후 10개를 유지하며 새로운 데이타는 `push` 그 이전의 데이타는 shift를 통해 뺄 것입니다. 

#### MEVN/4장/sensor/src/store/mutations-type.js
```js
export const CHANGE_SENSOR_CHART = 'CHANGE_SENSOR_CHART' 
```
mutations에는 수많은 mutation 함수들이 들어갑니다. 저는 actions와 mutation을 구분할 수 있게 actions의 경우는 대문자 + types를 쓰지않습니다. 
 * 취향에 따라 actions-type를 만드는 사람들도 있습니다. 


#### MEVN/4장/sensor/src/store/state.js 
```js
export default {
    sensors : []
}
```
자 state는 sensors 하나만 넣으면 끝이 납니다.   

#### MEVN/4장/sensor/src/store.js  
```js
import Vue from 'vue'
import Vuex from 'vuex'
import actions from './store/actions.js'
import mutations from './store/mutations.js'
import state from './store/state.js'
Vue.use(Vuex)

export default new Vuex.Store({
  state,
  mutations,
  actions
})

```
그 이후 store에 이렇게 설정해 놓으면 끝입니다. 자 이렇게 vuex - store에 관한 모듈화가 끝이 났습니다. 

이제부터는 config 설정입니다. 

#### MEVN/4장/sensor/src/config/index.js  
```js
export default{
    host : "http://127.0.0.1", 
    port : 12010, 
    margin : {top: 50, right: 50, bottom: 50, left: 50}, 
    chartWidth : 300,
    chartHeight : 400
}
```
우리는 센서 차트라는 그림을 그릴 것인데 그것에 해당하는 width와 height를 config에 설정해주면 나중에 유지보수하는데 굉장히 좋습니다. 또한 센서데이타를 받아올 서버의 정보, host, port를 적어 놓습니다. 

### 4.6  실시간 센서시각화사이트 : 차트 컴포넌트 
이제 차트를 구현해보겠습니다.    

#### MEVN/4장/sensor/src/components/Chart.vue
```html
<template>
  <div :class="'Chart Chart-' + _key">
  </div>
</template>

<script>
  import config from '../config' // - (1)
  import * as d3 from 'd3' // - (2)
  const margin_value = 1;

  import {
    mapState
  } from 'vuex'
  export default {
    name: 'Chart',
    props: { // - (3)
      _key: String,
      color: String
    },
    data() {
      return {
        svg: "",
        xScale: "",
        yScale: "",
        xAxis: "",
        yAxis: "",
        line: ""
      }
    },
    mounted() {
      this.setAreaAndScale(this._key); // - (4)
      let cnt = 0;
      this.$store.subscribe((mutation, state) => {// - (5)
        if (mutation.type === "CHANGE_SENSOR_CHART") {  
          if (!cnt) this.initDraw(this.sensors, this._key);
          else this.draw(this.sensors, this._key);
          cnt = 1; 
        }

      })
    },
    methods: {
      setAreaAndScale(key) {
        this.svg = d3.select(`.Chart-${key}`).append("svg")
          .attr("width", config.chartWidth + config.margin.left + config.margin.right)
          .attr("height", config.chartHeight + config.margin.top + config.margin.bottom)
          .append("g")
          .attr("transform", `translate(${config.margin.left},${config.margin.top})`)
        this.xScale = d3.scaleTime().range([0, config.chartWidth])
        this.yScale = d3.scaleLinear().range([config.chartHeight, 0])

        const timeFormat = d3.timeFormat("%H:%M")
        this.xAxis = d3.axisBottom(this.xScale).tickFormat(timeFormat)
        this.yAxis = d3.axisLeft(this.yScale)
        this.line = d3.line().x(d => this.xScale(d.time)).y(d => this.yScale(d[key])).curve(d3.curveMonotoneX)

      },
      initDraw(data, key) { 
        //data는 string형태로 오기 때문에 여기서 new Date 객체로 바꿔주어야 한다. 
        data.forEach(function (d) {
          d.time = new Date(d.time)
        });
        //scale에는 extent또는 0부터 max까지 할 수있다. 
        this.xScale.domain(d3.extent(data, d => d.time))
        //yScale.domain([0, d3.max(data, d => d.temp)])  
        const _min = d3.min(data, d => d[key])
        const _max = d3.max(data, d => d[key])
        this.yScale.domain([_min - margin_value, _max + margin_value])

        //data를 통해 path를 그리는데 3가지 방법이 있다. 
        // svg.append("path").datum(data).attr("d", line)
        // svg.append("path").data([data]).attr("d", line) 
        this.svg.append("path")
          .attr("d", this.line(data))
          .attr("class", "line")
        this.svg.append("g")
          .attr("class", "x axis")
          .attr("transform", `translate(0,${config.chartHeight})`)
          .call(this.xAxis);

        this.svg.append("g")
          .attr("class", "y axis")
          .call(this.yAxis);
      },
      //draw에서는 데이터 처리가 아닌 data를 통해서 차트틀 그리는 것에 대해 집중해야 한다. 
      draw(data, key) {   
        data.forEach(function (d) { // - (6)
          d.time = new Date(d.time)
        });

        this.xScale.domain(d3.extent(data, d => d.time)) // - (7) 
        const _min = d3.min(data, d => d[key])
        const _max = d3.max(data, d => d[key])
        this.yScale.domain([_min - margin_value, _max + margin_value])
 
        var svg = d3.select(`.Chart-${key} svg`).transition();
        svg.select(".line")  
          .duration(750)
          .attr("d", this.line(data));// - (8) 
        svg.select(".x.axis")  
          .duration(750)
          .call(this.xAxis);
        svg.select(".y.axis")  
          .duration(750)
          .call(this.yAxis);
      }
    },
    computed: {
      ...mapState([
        'sensors'
      ])
    }
  }
</script>

<style>
  .Chart .line {
    fill: none;
    stroke: #f89e35;
    stroke-width: 2px;
  }
  .Chart-humi .line{ 
    stroke: #42b983; 
  } 
  .Chart-wv .line{ 
    stroke: #262d3d; 
  } 
  div.tooltip {
    position: absolute;
    text-align: center;
    padding: 5px;
    font-size: 12px;
    font-weight: bold;
    background: #f99e1a;
    border: 0px;
    border-radius: 8px;
  }

  .tooltip p {
    margin: 0;
    padding: 0;
  }

  circle {
    fill: rgba(40, 53, 79, .95);
  }
</style>
```
 > toolip은 추후 수정예정

코드를 보면서 각각 설명하겠습니다
1)`import config from '../config'`를 통해 아까 설명했던 config를 가져와 width, height 등을 설정합니다. 
2)`import * as d3 from 'd3'` D3는 common모듈방식과 ES6방식을 모두 지원합니다. ES6방식을 사용하여 D3를 가져옵니다.
3)` props: { ` D3는 특정한 DOM에 svg나 다른 것들을 **붙여서** 그림을 만들어 냅니다. 이 Chart.vue는 재사용되기 때문에 예를 들어 똑같은 클래스에 붙이게 되면 그림이 겹쳐지게 됩니다. 그렇기 때문에 각각의 컴포넌트를 구분할 _key가 필요하며 각각의 컴포넌트마다 다른 색깔을 넣기 위해 color를 props로 받아옵니다. 
4)`this.setAreaAndScale(this._key); `먼저 그림을 그릴 영역을 설정합니다. 이 때 전역변수로 설정할 수 있지만 `this.line`등으로 vue 인스턴스에 거는 이유가 있습니다. 바로 같은 화면에 component를 3개를 놓는다고 했을 때 그 컴포넌트에 전역변수를 걸어버리면 한번밖에 선언을 안하고 그 메소드가 동작할 때 line함수에 다른 값이 할당이 되게 됩니다. 즉, 컴포넌트마다 각기 다른 변수를 할당하지 못하기 때문에 각기 다른 효과를 원한다면 vue인스턴스에 할당을 해야 합니다. 
5)`this.$store.subscribe((mutation, state) `를 통해 mutation을 감지할 수 있습니다. 감지해서 처음에는 initDraw, 그 다음에는 draw로 그림을 그립니다. 
6) 이 처리를 하는 이유는 뭘까요? 우리가 받는 데이타는 string입니다. 서버로 부터 객체를 받는 것이 아니죠. 그렇기 때문에 string화 된 데이타를 new Date를 통해 객체로 만들어 주어야 합니다. 
7) 그림을 그리기 앞서 새로운 데이터에 따라 범위 설정을 다시 해줍니다. 그 후 
8) this.line에 data 인자를 넣어 새로운 그림을 만듭니다. 


 > 참고 : line 그리기

D3.js는 유연하므로 path를 이용한 라인은 3가지의 방법으로 그릴 수 있습니다. 
 
 ----

1)svg.append("path").datum(data).attr("d", line)
2)svg.append("path").data([data]).attr("d", line) 
3)svg.append("path").attr("d", this.line(data)).attr("class", "line")

 ----
 
#### MEVN/4장/sensor/src/views/SensorChart.js  
위의 완성된 Chart.vue를 쓸 부모 컴포넌트입니다. 
```html
<template>
  <div> 
    <div v-for="c in charList" class="chartWrap card">
      <h2>{{c.text}}</h2> 
      <Chart :_key="c.value" :color = "c.value" :key="c.value"></Chart>
    </div> 
  </div>
</template>

<script>
// @ is an alias to /src
import Chart from '@/components/Chart.vue'

export default {
  name: 'SensorChart',
  components: {
    Chart
  }, 
    data() {
      return { 
        charList : [ 
           {"color" : "red", "value": "temp", "text" : "온도"}, 
           {"color" : "green", "value": "wv", "text" : "풍속"}, 
           {"color" : "blue", "value": "humi", "text" : "습도"}, 
        ]
      }
    },
    mounted() { 
    },
    methods: { 
    }  
}
</script>
<style>
.chartWrap{
  display:inline-block;
}
.chartWrap h2{
    border-bottom: 2px solid #aaa;
    padding-bottom: 10px;
    margin: 0;


} 
</style>
```

### 4.7  실시간 센서시각화사이트 : 소켓플러그인제작 

#### MEVN/4장/sensor/src/plugins/socketPlug.js 
우리는 실시간 통신을 합니다. 그러기 위해선 socket.io-client를 client에 설정을 해놔야죠. 그러기 위한 플러그인을 제작합니다. 
```js
import Vue from 'vue';
import io from 'socket.io-client';
export default {
    install(Vue, {
        host,
        port
    }) {
        const socketClient = io(`${host}:${port}`);
        Vue.prototype.$socket = socketClient;
        console.log("complete")
    }
}
```
#### MEVN/4장/sensor/src/main.js 
```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import socketPlugin from './plugins/socketPlug.js'
import config from './config' 
Vue.config.productionTip = false

Vue.use(socketPlugin, {host : config.host, port : config.port}) 
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```
그 이후 위의 예처럼 Vue.use로 socketPlugin을 vue 인스턴스에 할당하면 됩니다. 

#### MEVN/4장/sensor/src/router.js 
```js
import Vue from 'vue'
import Router from 'vue-router'
import SensorChart from './views/SensorChart.vue'  
Vue.use(Router)

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [
    {
      path: '/',
      name: 'SensorChart',
      component: SensorChart
    },
    {
      path: '/map',
      name: 'map', 
      component: () => import('./views/Map.vue')
    },{
      path: '/number',
      name: 'number', 
      component: () => import('./views/Number.vue')
    },{ 
      path: '*',
      name: '404', 
      component: () => import('./views/Lost.vue')

    }
  ]
})

```
참고로 router 구성은 위와 같습니다. 먼저 우리가 할당한 라우터 말고 다른 곳을 들어가면 lost페이지가 뜨게끔 마지막에 *으로 404로 할당한 것을 주의깊게 보시면 됩니다. 

완성된 모습입니다. sensor에 관한 차트가 아름답게 animation화 되어 움직이는 것을 볼 수 있습니다. 

![센서차트](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_센서.gif) 

 
