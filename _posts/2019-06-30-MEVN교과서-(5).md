---
layout: post
title: 'MEVN교과서 (5)'
author: kundol
comments: true
date: 2019-06-30 12:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (5)

---    

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_4장.jpg)
## 4. 실시간 데이터시각화사이트제작  
이제 드디어 실시간 데이터시각화사이트를 제작할 것입니다. 데이터를 시각화를 하기 위해서는 시각화 라이브러리가 필요합니다. D3.js, chart.js 등 많은 라이브러리를 비교하교 장점과 단점을 비교할 것입니다. 그 후 D3.js로 간단하게 사용법을 알아보고 지도, 증가하는 숫자모듈을 만들고 RESTAPI사용법에 대해서 알아보겠습니다. 

실시간통신을 위해서는 websocket사용은 필수입니다. 하지만 오래된 브라우저를 위한 polling이라는 기법또한 알아볼 것입니다. 그 후 디자인을 어떻게 짤 것인지 알아보고 마지막으로 차트컴포넌트와 전에 만든 증가하는 숫자 모듈로 하드웨어 모니터링 시스템까지 완벽하게 알아보겠습니다.

### 4.1 시각화 라이브러리 D3.js
어떠한 데이터를 시각화하는 것은 중요한 일입니다. 같은 데이타라도 다르게 보여줄 수 있으며 효과적으로 내가 주장하는 바를 강하게 나타낼 수 있습니다. 

![콜레라지도](https://w.namu.la/s/6c3158c18fe2d603f52f9ea42944939679abd221f8e2ca97363175550b93ed4ac7f72f404523f13215118118cd6be01873b897a767d89693fadf2597ffe54aba1c54f4f2adc949746580eb079ff7e99b9f29ab4ab94faff1e833031556a2c559)
실제로 데이타 시각화는 사람을 살리는 일도 합니다. 

빅토리아 여왕 시대의 의사인 존스노우는 콜레라가 수인성 전염병이라는 것을 파악하기 위해 펌프가 있는 지역들을 위처럼 시각화 했고 이를 통해 콜레라가 펌프와 상관관계여부를 파악하고 규칙성을 찾아내었습니다.  

이러한 시각화를 도와주는 좋은 도구인 시각화라이브러리중 하나인 D3.js를 소개합니다.
D3를 사용하면 임의의 데이터를 DOM (Document Object Model)에 바인딩 한 다음 문서에 데이터 기반 변환을 적용 할 수 있습니다. 예를 들어 D3을 사용하여 숫자로 이루어진 배열에서 HTML 테이블을 생성 할 수있고 바차트, 선차트 등을 만들 수 있습니다.  이외에도 지도, flow, treemap, pie chart, 상호작용, 애니메이션 등 무궁무진하게 정말 많은 시각화그림들을 만들 수 있습니다.
매우 작은 용량의 라이브러리로 정말 작은 부분 하나하나 세세하게 커스터마이징이 가능한 장점을 가지고 있습니다. 

#### 4.1.1 D3의 구조 및 다른 시각화라이브러리
무언가 프로젝트를 하기 위해 Stack을 설정할 때 다른 라이브러리와의 비교는 필수입니다. 그렇다면 현존하는 라이브러리와 D3.js를 비교해보겠습니다. 

2019년 7월 28일 기준입니다. 각 라이브러리의 최신버전을 통해 비교했습니다.

| 라이브러리 | 용량(min기준) | 러닝커브 | 활용도 |
|:--------|:--------| 
| chart.js	| 153kb | 쉬움 | 보통 |
| echarts.js | 729kb | 매우쉬움 | 보통 |
| three.js	| 562kb | 보통 | 높음 | 
| D3.js	| 237kb | 보통 | 매우높음 |

#### chart.js 버전 : 2.8.0
chart.js는 영역차트, 바차트, pie차트 등 차트에 국한 되어있습니다. 단순히 차트만 구현한다면 chart.js는 좋은 선택입니다. 

라인차트를 구현하는데 이정도의 script만 있으면 됩니다.
```js
var ctx = document.getElementById('myChart').getContext('2d');
var chart = new Chart(ctx, { 
    type: 'line', 
    data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [{
            label: 'category', 
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }]
    }, 
    options: {}
}); 
```
#### echarts.js 버전 : 4.2.1
echarts.js는 사용하기가 매우 쉽습니다. 
라인차트를 구현하는데 이정도의 script만 있으면 됩니다. 또한, geomap, Radar Chart, Heatmap, Graph, Treemap, flow 등 여러가지를 구현할 수 있습니다. 필자도 토이 프로젝트를 할 때 빠르게 차트를 구현하기 위해 echarts를 구현할 정도로 정말 쉽고 빠르게 만들 수 있습니다. 써보면 아시겠지만 chart.js보다 쉽습니다. 하지만 용량이 상당히 거대하기 때문에 큰 프로젝트에서는 추천하지 않습니다.
```js
option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};  
var myChart = echarts.init(document.getElementById("container"));
myChart.setOption(option, true);  
```

#### three.js 버전 : 0.106.2
three.js는 가장 유명한 자바스크립트 3D 라이브러리 중 하나입니다. 무겁기도 하고 하드웨어의 성능을 많이 잡아 먹기 때문에 모바일에서 이를 활용한 앱을 켰을 때 버벅거리는 증상이 나타나기도 합니다. 정말 많은 3D 차트 등을 구현할 수 있습니다. 자바스크리브로 3D를 구현하자면 필수적인 라이브러리입니다. 

#### D3.js 버전 : 5.9.7
D3.js는 3D는 아니지만 2D로 구현이 가능한 모든 시각화적인 것들을 구현할 수 있습니다. 차트, 맵은 기본이며 중력도 구현이 가능하며 워드클라우드, 플로우, 못하는 것이 없습니다. 하지만 D3.js를 이용하기 위해서는 데이타가 어떻게 그려지는지 원리부터 차근차근 알아가야 쓸 수 있습니다. chart.js나 echart.js처럼 간단히 데이타만 넣고 알아서 차트가 그려지지는 않습니다. 

그러나 이러한 번거로움을 뒤로한채 최고라고 말할 수 있는 이유는 237kb라는 작은 용량으로 정말 다양한 시각화적인 요소를 표현할 수 있다는 점과 매우 작은 부분 까지 커스터마이징하기가 쉽다는 것입니다. 그리고 만든사람이 무려 json의 창시자, 마이클 보스톡입니다. 최신 리액티브 프로그래밍을 반영하는 점이나 빠르게 업데이트하는 면도 눈여겨볼만한 부분입니다.

물론 chart.js나 echart.js로도 가능하지만 설계될 때 그렇게 커스터마이징을 설계하지 않았는지 커스터마이징을 하려면 chart.js 내부안에 들어가서 바꿔야 하거나 echart.js로 들어가 바꿔야합니다. 

### 4.2 D3.js : 지도매핑모듈
D3.js로는 많은 것을 만들 수 있습니다. 그 중에 하나가 바로 지도입니다. 

#### 4.2.1 topojson과 geojson비교
지도를 그리기 앞서 topojson과 geojson에 대해 알아봅니다. topojson이나 geojson 모두 지도를 그리기 위한 재료이자 지리적 정보들을 담고 있는 데이타 입니다. 다양한 지리적 데이터 구조를 표현하기 위해 인코딩된 json입니다.

좀 더 자세히 설명하자면, 지도를 그리는데 있어 레스터 방식과 벡터 방식이 있습니다. 레스터 방식은 이미지를 확대하면 깨지는 픽셀단위의 그림을 생각하면 되고 벡터 방식은 픽셀데이터가 아닌 점, 선 , 면 등 기하학적인 모양을 저장하며 확대하더라도 "깨지지 않는" 데이터 방식을 말합니다. 이 벡터 방식을 가지고 있는 지리데이타 포맷중에 geoJSON, topoJSON 등이 있으며 오늘은 topojson을 쓸 것입니다.  

topojson은 geojson에 비해 파일 사이즈가 작은 장점을 가지고 있으며, 기하학적인 조정을 json파일에 가한다면 geojson을 쓰고, 그렇지 않다면 심플한 topojson을 씁니다. 또한 geojson은 coordinate속성을 반드시 있어야 하며 경계정보가 중복되어서 나타납니다. 

하지만 topojson은 경계는 arc속성으로 이루어져 중복이 되지 않으며 위상(topology)에 따라 인코딩됩니다. 따라서 topojson이 geojson보다 약 10배정도 가볍습니다. 

#### 4.2.2 D3.js를 이용한 지도그리기 및 줌이벤트
이제 실제 코드로 넘어가서 하나하나 살펴보도록 하겠습니다. 코드가 약간 길기 때문에 차근차근 살펴보겠습니다. 

```js
import * as d3 from 'd3';
import * as topojson from 'topojson';
```
D3와 topojson을 `import` 시킵니다. 
이 불러오는 방법은 ES6모듈 포맷방식입니다.  

 > 참고 : 자바스크립트 모듈문법

자바스크립트 모듈문법 중 CommonJS모듈과 ES6모듈 포맷이 있습니다.
 * UMD와 AMD, System.register 모듈 포맷 방식은 여기서 설명하지 않습니다.

CommonJS 포맷은 Node.js에서 사용되며 `require`와 module.exports를 사용해서 의존성과 모듈을 정의합니다. 아래와 같은 형식이죠.
```js
const a1 = require('./a1.js')
const a2 = require('./a2.js')

module.exports = function (){

}
```
ES6 모듈 포맷은 import와 export를 사용합니다. 
```js
//특정 함수인 mapC만을 가져올 수 있으며
import { mapC } from 'fxjs';
//전체를 다 불러서 d3란 네임스페이스를 지정할 수 있습니다.
import * as d3 from 'd3';

export default curry(function mapC(f, iter) {
  return takeAllC(mapLazy(f, iter));
}); 
```
```js
const koreaMap = require('../map/skorea_municipalities_topo_simple.json');
const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_municipalities_geo);
const center = d3.geoCentroid(_map);
```
우리나라 topojson파일을 로드하고 `topojson.feature`을 통해 _map이라는 변수에 맵에 관련된 정보를 할당합니다. 그리고 그 맵의 중앙값을 설정합니다.

```js 
const width = 1000;
const height = 1000;
const svg = d3
.select('.d3')
.append('svg')
.attr('width', width).attr('height', height);
const map = svg.append('g'); 
```
기본 셋팅입니다. 우리가 그릴 캔버스를 설정해 놓읍시다. `class="d3"`를 가지고 있는 DOM에 `svg`태그를 `append`시키고 그 영역에 width의 값과 height의 값을 설정합니다. 그리고 그 svg에 우리가 map을 만들것이기 때문에 많은 요소들이 들어갑니다. 그러므로 group으로 감싸줘야 하므로 g태그를 붙입니다. 

이것이 D3로 시각화하는 첫단계입니다. 
1. 재료를 선택하고(topojson) 
2. 그 재료를 쓸 캔버스를 설정(select, append, attr)

```js
let projection = d3.geoMercator()
.scale(1)
.translate([0, 0]); 
```
이 지도의 투사법은 메르카토르 투사법을 씁니다. 지구는 동그라한 구형태이기 때문에 이를 평면에 펼쳐서 보기 위해서는 투사법이 존재하며 많은 투사법이 있지만 우리가 많이 보는 지도가 바로 메르카토르 투사법을 쓴 지도 입니다. 메르카토르투사법, 초기 스케일, 초기 translate를 설정해서 초기 projection 이라는 투사법이라는 객체를 셋팅합니다. 
 > 이외에도 Orthographic이라는 투사법도 있습니다. 
```js
const path = d3.geoPath().projection(projection);
const bounds = path.bounds(geojson);
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height; 
const scale = 1 /Math.max(widthScale, heightScale);
const xoffset = width/2 - scale * (bounds[1][0] + bounds[0][0]) /2 + 10; 
const yoffset = height/2 - scale * (bounds[1][1] + bounds[0][1])/2 + 80; 
const offset = [xoffset, yoffset];
projection.scale(scale).translate(offset);
```
이제 topojson이란 위경도의 정보들을 이용, 미리 설정해 놓은 투사법으로 패스를 땁니다. 우리가 보고 싶은 것은 이 패스의 중점을 보고 싶습니다. 우리나라의 중점을 말이죠 그렇기 위해서 xoffset과 yoffset등을 설정합니다. 추후 좀 더 자세히 설명하겠습니다. 

```js
d3.geoPath().projection(projection)
```
아까 만들어 놓은 projection, 투사법으로 우리가 그리는 지도인 path 객체를 따냅니다. svg중 path요소로 지도를 그릴것이며 이제 그 준비단계가 끝났습니다. 
```js
const bounds = path.bounds(geojson);
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height; 
path.bounds(geojson)
```
우리는 이 path로 부터 중심을 잡고 싶습니다. 즉 경계를 잡고 싶다는 것이죠. 그러하려면 bounds를 써야 합니다.


#### bounds
bounds의 1차원배열은 path의  xmax와 xmin을 가리킵니다. bounds[0][x].. 의 0에서 0, 1을 통해 xmax와 xmin을 나타낼 수 있습니다.  즉, 최소경도, 최대경도(longitude)를 가리키게 됩니다. 
bounds의 2차원배열은  ymax와 ymin을 가리킵니다. bounds[x][0]..의 0에서 0, 1을 통해 ymax와 ymin을 가리킵니다. 즉, 최소위도, 취대 위도를 가리킵니다. (latitude)

#### scale

그 다음 스케일을 정의해줍니다. 이 스케일은 지도에서 축척을 의미합니다. 넓은 우리나라 땅덩어리를 우리는 작은 화면에 표시해야 합니다.  일단 우리가 구한것은 path의 가장자리를 구한 것입니다. 

이것중에서 가장 최대값을 
```js
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height;  
const scale = 1 /Math.max(widthScale, heightScale); 
```
이렇게 이용해서 축척을 만들어줍니다. 1 : 5만배의 지도를 표시할 때 1 : 50000이라고 나타냅니다. 그걸 우리는 1 / maxScale로 나타낸 것입니다.    

#### translate
```js
const xoffset = width/2 - scale * (bounds[1][0] + bounds[0][0]) /2 + 10; 
const yoffset = height/2 - scale * (bounds[1][1] + bounds[0][1])/2 + 80; 
const offset = [xoffset, yoffset];
projection.scale(scale).translate(offset);
``` 
그 다음엔 위의 코드처럼 translate를 정의해주어야 합니다. 우리가 흔히 css로 어떠한 영역을 가로, 세로 중앙 정렬할 때 어떻게 할까요?  
```css
.center {
  position: absolute;
  left: 50%;
  top: 50%; 
  transform: translate(-50%, -50%); 
}
```
위의 코드처럼 translate로 일단 사물을 옮기고 그 사물의 "크기의 50%" 만큼 또 옮기면 됩니다. 똑같이 우리가 보여주는 크기의 반인 bounds의 반을 x, y - offset으로 셋팅하고 translate를 합니다.  
```js
map
.selectAll('path').data(geojson.features)
.enter().append('path') 
.attr('d', path);  
``` 

#### 자몽을 놓을 위도 경도에 따라 매핑하기
우리는 자몽이라는 아이콘을 놓을 것입니다.  
```js 
  const mapInfo = [
    {
      "name":"서울",
      "lat" : "37.532600",
      "lon" : "127.024612"
    },
    {
      "name":"대전",
      "lat" : "36.3730178",
      "lon" : "127.2483736"
    }
  ] 
```
위의 코드처럼 자몽을 놓을 위경도 데이타를 만듭니다. 
```js
const icons = svg.append('g').selectAll('svg')
.data(mapInfo)
.enter()  
.append("svg:image")
.attr("width", 50)
.attr("height", 50)
.attr('x' ,  d=> projection([d.lon, d.lat])[0])
.attr('y' ,  d=> projection([d.lon, d.lat])[1] - 100)
.attr('opacity', 0)
.attr("xlink:href", require("../icons/grapefruit.svg")) 
.on('click', d =>{
  console.log(d)
})
.transition()
.ease(d3.easeElastic)
.duration(2000)
.delay((d, i)=> i * 50)
.attr('opacity', 1)
.attr('y' ,  d=> projection([d.lon, d.lat])[1])
```  
이렇게 매핑을 하면 됩니다. 우리가 만들어 놓은 위경도 자료 만큼 svg를 붙이는(append) 하는 것입니다. 저렇게 attr을 이용해서 가로 세로, x좌표, y좌표, 투명도를 설정해주면 됩니다. .on을 이용해서 클릭이벤트도 설정할 수 있습니다. transition을 이용해 애니메이션도 만들었습니다. 2초(2000밀리세컨드) 만큼동안 자몽이 떨어지는 예제입니다. delay((d, i) => i * 50)을 통해 자몽의 개수만큼 차례대로 지연시간을 걸어 놓습니다. 그렇다면 차례대로 자몽이 떨어지게 됩니다. 예를 들어 자몽1은 0, 자몽2는 50밀리세컨드만큼 늦어지게 되는 것입니다. 
 
#### projection 
```js
  function projection(point) {
    point = projectRotate(point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
    return [point[0] * k + dx, dy - point[1] * k];
  }
```
 * v5에서 달라진 부분존재 추후 수정 예정

projection 메소드가 궁금할 것같아서 준비했습니다.  위경도에 해당하는 값을 배열로 받아서 첫번째에 그 투사법으로 추출되는 x, 경도를 반환하고 y, 위도를 반환합니다.  

​ 
#### 줌이벤트 
```js
const zoomed = () =>{
  map.attr('transform', d3.event.transform)
  icons.attr('transform', d3.event.transform)
}
const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
svg.call(zoom)
```
줌이벤트는 간단합니다. 이렇게 줌을 걸어주고자 하는 group에 transform 특성에 해당 event를 추가하고 zoom이 큰 svg에서 발동할 때마다 미리 설정해 놓은 이벤트들이 작동하게끔 설정해주면 됩니다.   
call은 자바스크립트의 call을 생각하면 됩니다.
#### call
```js
const 큰돌 = {
    "이름": "큰돌"
}

function editmyresume(능력, 힘) {
    this.능력 = 능력
    this.힘 = 힘
} 
editmyresume.call(큰돌, "Vue.js", "팔굽혀펴기") 
console.log(큰돌)
```
어떠한 함수를 실행하는데 객체를 넣어서 기본값을 설정할 수 있습니다. 

#### 4.2.3 지도 매핑모듈과 zoom이벤트

### 4.3 D3.js : 증가하는 숫자
#### 4.3.1 d3.pie소개
#### 4.3.2 d3 interporate 
#### 4.3.3 증가하는 숫자 만들기  
  
### 4.4  실시간 센서시각화사이트 : REST API 구축
#### 4.4.1 REST API 특징
#### 4.4.2 CORS 및 주의사항
#### 4.4.3 요청 제한 및 IP 설정   
#### 4.4.4 센서생성 서버 REST API 구축
 
### 4.5  실시간 센서시각화사이트 : 실시간통신과 디자인
#### 4.5.1 websocket방식과 polling 방식 비교
#### 4.5.2 socket.io를 이용한 간단한 채팅 예제
#### 4.5.3 Vuex 및 프로젝트 뼈대 구축
#### 4.5.4 디자인 가이드 구축

### 4.6  실시간 센서시각화사이트 : 차트 컴포넌트 
#### 4.6.1 차트 컴포넌트제작
#### 4.6.2 고정된 데이타를 기준으로 차트 
#### 4.6.3 업데이트되는 데이타를 기준으로 차트
#### 4.6.4 tooltip 이벤트
#### 4.6.5 REST API와 연동되어 실제 데이터와 차트구축
#### 4.6.6 메모이제이션 알고리즘을 적용하여 서버요청 최적화 

### 4.7  실시간 센서시각화사이트 : 모니터링 모듈 
#### 4.7.1 CPU, 하드웨어 모니터링 모듈 제작