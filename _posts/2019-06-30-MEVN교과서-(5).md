---
layout: post
title: 'MEVN교과서 (5)'
author: kundol
comments: true
date: 2019-06-30 12:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (5)

---    

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_4장.jpg)
## 4. 실시간 데이터시각화사이트제작  
이제 드디어 실시간 데이터시각화사이트를 제작할 것입니다. 데이터를 시각화를 하기 위해서는 시각화 라이브러리가 필요합니다. D3.js, chart.js 등 많은 라이브러리를 비교하교 장점과 단점을 비교할 것입니다. 그 후 D3.js로 간단하게 사용법을 알아보고 지도, 증가하는 숫자모듈을 만들고 실시간통신과 차트모듈을 만들어보겠습니다.  

실시간통신을 위해서는 websocket사용은 필수입니다. 하지만 오래된 브라우저에서는 웹소켓자체가 구동되지 않습니다. 이를 위한 polling이라는 기법또한 알아볼 것입니다. 그 후 실제로 구현해보고 차트컴포넌트와 전에 만든 증가하는 숫자 모듈을 활용해 하드웨어 모니터링 시스템까지 완벽하게 알아보겠습니다.

### 4.1 시각화 라이브러리 D3.js
어떠한 데이터를 시각화하는 것은 중요한 일입니다. 같은 데이타라도 다르게 보여줄 수 있으며 효과적으로 내가 주장하는 바를 강하게 나타낼 수 있습니다.  
![콜레라지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2375B83653D9EED42D.jpeg)   
실제로 데이타 시각화는 사람을 살리는 일도 합니다. 

빅토리아 여왕 시대의 의사인 존스노우는 콜레라가 수인성 전염병이라는 것을 파악하기 위해 펌프가 있는 지역들을 위처럼 시각화 했고 이를 통해 콜레라가 펌프와 상관관계여부를 파악하고 규칙성을 찾아내었습니다.  

이러한 시각화를 도와주는 좋은 도구인 시각화라이브러리중 하나인 D3.js를 소개합니다.
D3를 사용하면 임의의 데이터를 DOM (Document Object Model)에 바인딩 한 다음 문서에 데이터 기반 변환을 적용 할 수 있습니다. 예를 들어 D3을 사용하여 숫자로 이루어진 배열에서 HTML 테이블을 생성 할 수있고 바차트, 선차트 등을 만들 수 있습니다.  이외에도 지도, flow, treemap, pie chart, 상호작용, 애니메이션 등 무궁무진하게 정말 많은 시각화적인 요소들을 만들 수 있습니다.
매우 작은 용량의 라이브러리로 정말 작은 부분 하나하나 세세하게 커스터마이징이 가능한 장점을 가지고 있습니다. 

#### 4.1.1 D3와 다른 시각화라이브러리 비교
무언가 프로젝트를 하기 위해 Stack을 설정할 때 다른 라이브러리와의 비교는 필수입니다. 그렇다면 현존하는 라이브러리와 D3.js를 비교해보겠습니다. 

2019년 7월 28일 기준입니다. 각 라이브러리의 최신버전을 통해 비교했습니다.

| 라이브러리 | 용량(min기준) | 러닝커브 | 활용도 |
|:--------|:--------| 
| chart.js	| 153kb | 쉬움 | 보통 |
| echarts.js | 729kb | 매우쉬움 | 보통 |
| three.js	| 562kb | 보통 | 높음 | 
| D3.js	| 237kb | 보통 | 매우높음 |

#### chart.js 버전 : 2.8.0
chart.js는 영역차트, 바차트, pie차트 등 차트에 국한 되어있습니다. 단순히 차트만 구현한다면 chart.js는 좋은 선택입니다. 

라인차트를 구현하는데 이정도의 코드만 있으면 됩니다.
```js
var ctx = document.getElementById('myChart').getContext('2d');
var chart = new Chart(ctx, { 
    type: 'line', 
    data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [{
            label: 'category', 
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }]
    }, 
    options: {}
}); 
```
#### echarts.js 버전 : 4.2.1
echarts.js는 사용하기가 매우 쉽습니다. 
라인차트를 구현하는데 이정도의 코드만 있으면 됩니다. 또한, geomap, Radar Chart, Heatmap, Graph, Treemap, flow 등 여러가지를 구현할 수 있습니다. 필자도 토이 프로젝트를 할 때 빠르게 차트를 구현하기 위해 echarts를 구현할 정도로 정말 쉽고 빠르게 만들 수 있습니다. 써보면 아시겠지만 chart.js보다 쉽습니다. 하지만 용량이 상당히 거대하기 때문에 큰 프로젝트에서는 추천하지 않습니다.
```js
option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};  
var myChart = echarts.init(document.getElementById("container"));
myChart.setOption(option, true);  
```

#### three.js 버전 : 0.106.2
three.js는 가장 유명한 자바스크립트 3D 라이브러리 중 하나입니다. 무겁기도 하고 하드웨어의 성능을 많이 잡아 먹기 때문에 모바일에서 이를 활용한 앱을 켰을 때 버벅거리는 증상이 나타나기도 합니다. 정말 많은 3D 차트 등을 구현할 수 있습니다. 자바스크리브로 3D를 구현하자면 필수적인 라이브러리입니다. 

#### D3.js 버전 : 5.9.7
D3.js는 3D는 아니지만 2D로 구현이 가능한 모든 시각화적인 것들을 구현할 수 있습니다. 차트, 맵은 기본이며 중력도 구현이 가능하며 워드클라우드, 플로우, 못하는 것이 없습니다. 하지만 D3.js를 이용하기 위해서는 데이타가 어떻게 그려지는지 원리부터 차근차근 알아가야 잘 쓸 수 있습니다. chart.js나 echart.js와는 달리 간단히 데이타만 넣으면 알아서 차트가 그려지지는 것과는 다르죠.  

원리를 알아가는 점은 번거러울 수도 있습니다. 하지만 조금만 노력을 기울인다면 D3.js는 최고의 선택일 것입니다. 237kb라는 작은 용량으로 정말 다양한 시각화적인 요소를 표현할 수 있다는 점과 매우 작은 부분 까지 커스터마이징하기가 쉽기 때문입니다. 그리고 만든사람이 무려 json의 창시자, 마이클 보스톡입니다. 최신 리액티브 프로그래밍을 반영하는 점이나 빠르게 업데이트하는 면도 눈여겨볼만한 부분입니다.

아래의 예제를 보시면서 [D3API주소](https://github.com/d3/d3/blob/master/API.md)를 보고 진행을 하셔도 좋고 도통 모르겠다 하시는 분들은 부록E로 넘어가서 D3.js의 기본적인 예제를 공부하시면 됩니다. 

### 4.2 D3.js : 지도매핑모듈
D3.js로는 많은 것을 만들 수 있습니다. 그 중에 하나가 바로 지도입니다. 

#### 4.2.1 topojson과 geojson비교
지도를 그리기 앞서 topojson과 geojson에 대해 알아봅니다. topojson이나 geojson 모두 지도를 그리기 위한 재료이자 지리적 정보들을 담고 있는 데이타 입니다. 다양한 지리적 데이터 구조를 표현하기 위해 인코딩된 json입니다.

좀 더 자세히 설명하자면, 그림을 그리는데 있어 레스터 방식과 벡터 방식이 있습니다. 레스터 방식은 이미지를 확대하면 깨지는 픽셀단위의 그림이며 벡터 방식은 픽셀데이터가 아닌 점,선,면 등 기하학적인 모양을 저장하며 확대하더라도 "깨지지 않는" 데이터 방식인 수학적 함수관계에 의해 만들어진 이미지방식을 말합니다. 이 벡터 방식을 가지고 있는 지리데이타 포맷중에는 geoJSON, topoJSON 등이 있으며 이번에 topojson을 쓸 것입니다.  

topojson은 geojson과는 달리 경계정보를 arc속성으로 이루어진 중복되지 않는 위상(topology)정보에 따라 인코딩 되므로 중복되는 geojson 보다 파일 사이즈가 작은 장점을 가지고 있습니다.(데이타의 범위마다 다르지만 약 10배정도 가볍다고 합니다.) 하지만 데이타에 기하학적인 조정을 가한다면 geojson을 써야 합니다. 
 

#### 4.2.2 D3.js를 이용한 지도그리기 및 줌이벤트
이제 실제 코드로 넘어가서 하나하나 살펴보도록 하겠습니다. 코드가 약간 길기 때문에 차근차근 살펴보겠습니다. 4장에 미리 만들어 놓은 코드가 있습니다. 2장과는 다른 부분이 있어 다운받아서 진행하는 것을 추천드립니다.  

`npm install --save d3` 와 `npm install --save topojson`를 통해 우리가 필요한 도구, 외부 라이브러리들을 미리 준비합니다. 

#### 전체코드 : MEVN/4장/sensor/src/views/Map.vue 
```html
    
<template>
  <div class="Map"> 
    <div class="d3"></div>
  </div>
</template>
<script>
  import * as d3 from 'd3';
  import * as topojson from 'topojson'; 
  export default {
    name: 'Map', 
    mounted() {
      this.draw();
    },
    methods: {
      draw() { 
        const koreaMap = require('../assets/skorea-provinces-2018-topo-simple.json');
        const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_provinces_2018_geo);  

        const width = 600;
        const height = 1000;
        const svg = d3
          .select('.d3')
          .append('svg')
          .attr('width', width).attr('height', height);

        const projection = d3.geoMercator()
          .scale(1)
          .translate([0, 0]);

        const path = d3.geoPath().projection(projection);
        const bounds = path.bounds(_map);

        const widthScale = (bounds[1][0] - bounds[0][0]) / width;
        const heightScale = (bounds[1][1] - bounds[0][1]) / height;
        const scale = 1 / Math.max(widthScale, heightScale);

        const xoffset = width / 2 - scale * (bounds[1][0] + bounds[0][0]) / 2 + 10;
        const yoffset = height / 2 - scale * (bounds[1][1] + bounds[0][1]) / 2 + 80;
        const offset = [xoffset, yoffset];
        projection.scale(scale).translate(offset);

        const map = svg.append('g')
          .selectAll('path').data(_map.features)
          .enter().append('path')
          .attr('d', path);
          
        const mapInfo = [{
            "name": "서울",
            "lat": "37.532600",
            "lon": "127.024612"
          },
          {
            "name": "대전",
            "lat": "36.3730178",
            "lon": "127.2483736"
          }
        ]

        const icons = svg.append('g').selectAll('svg')
          .data(mapInfo)
          .enter()
          .append("svg:image")
          .attr("width", 50)
          .attr("height", 50)
          .attr('x', d => projection([d.lon, d.lat])[0])
          .attr('y', d => projection([d.lon, d.lat])[1])
          .attr('opacity', 1)
          .attr("xlink:href", require("../assets/grapefruit.svg"))

        const zoomed = () => {
          map.attr('transform', d3.event.transform)
          icons.attr('transform', d3.event.transform);
        }
        const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
        svg.call(zoom)
      }
    }
  }
</script>
<style>
  .hello {
    width: 100%;
  }

  .d3 {
    background: #eee;
    width: 618px;
    height: 1000px;
    margin: 0 auto;
  }

  path {
    fill: #ed8b70;
    stroke: #de6a6c;
  }
</style>
```

하나하나 차근차근 알아보도록 하겠습니다. 
```js
import * as d3 from 'd3';
import * as topojson from 'topojson';
```
D3와 topojson을 `import` 시킵니다. 
이 불러오는 방법은 ES6모듈 포맷방식입니다.  

 > 참고 : 자바스크립트 모듈문법

자바스크립트 모듈문법 중 CommonJS모듈과 ES6모듈 포맷이 있습니다.
 * UMD와 AMD, System.register 모듈 포맷 방식은 여기서 설명하지 않습니다.

CommonJS 포맷은 Node.js에서 사용되며 `require`와 module.exports를 사용해서 의존성과 모듈을 정의합니다. 
```js
const a1 = require('./a1.js')
const a2 = require('./a2.js')

module.exports = function (){

}
```
위와 같은 형식입니다.

ES6 모듈 포맷은 import와 export를 사용합니다. 
```js
//특정 함수인 mapC만을 가져올 수 있으며
import { mapC } from 'fxjs';
//전체를 다 불러서 d3란 네임스페이스를 지정할 수 있습니다.
import * as d3 from 'd3';

export default curry(function mapC(f, iter) {
  return takeAllC(mapLazy(f, iter));
}); 
```

#### 1) topojson을 이용한 지도정보 설정
```js
const koreaMap = require('../map/skorea_municipalities_topo_simple.json');
const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_municipalities_geo); 
```
우리나라 topojson파일을 로드하고 `topojson.feature`을 통해 _map이라는 변수에 맵에 관련된 정보를 할당합니다.  

#### 2) 그림을 그릴 영역설정
```js 
const width = 600;
const height = 1000;
const svg = d3
.select('.d3')
.append('svg')
.attr('width', width).attr('height', height); 
```
기본 셋팅입니다. 우리가 그릴 캔버스를 설정해 놓읍시다. `class="d3"`를 가지고 있는 DOM에 `svg`태그를 `append`시키고 그 영역에 width의 값과 height의 값을 설정합니다. 그리고 그 svg에 우리가 map을 만들것이기 때문에 많은 요소들이 들어갑니다. 그러므로 group으로 감싸줘야 하므로 g태그를 붙입니다. 

이것이 D3로 시각화하는 첫단계입니다. 
1. 재료를 선택하고(topojson) 
2. 그 재료를 쓸 캔버스를 설정합니다(select, append, attr)

#### 3) projection 설정
```js
const projection = d3.geoMercator()
.scale(1)
.translate([0, 0]); 
```
이 지도의 투사법은 메르카토르 투사법을 씁니다. 지구는 동그라한 구형태이기 때문에 이를 평면에 펼쳐서 보기 위해서는 투사법이 존재하며 그 중 메르카토르 투사법을 쓸 것입니다. 메르카토르투사법, 초기 스케일, 처음에 이 투사법을 가진 프로젝터를 얼마나 이동시킬 것인가를 정하고 projection 이라는 변수에 객체를 셋팅합니다. 지구를 어떤 프로젝터로 멀리서 켜서 비친 지점들을 지도로 나타낸다고 상상하면 쉽습니다. 

 > 이외에도 Orthographic이라는 투사법도 있습니다. 
 
#### 4) bounds
```js
const path = d3.geoPath().projection(projection);
const bounds = path.bounds(geojson); 
```
`projection`을 통해 그리는 지도인 path 객체를 만들고 bounds를 통해 y축 끝값, x축 끝값을 걸정합니다. 이를 통해 그 path의 중앙설정을 할 수 있습니다. 이는 우리나라 지도의 중앙이겠죠?

bounds의 1차원배열은 path의  xmax와 xmin을 가리킵니다. bounds[0][x].. 의 0에서 0, 1을 통해 xmax와 xmin을 나타낼 수 있습니다.  즉, 최소경도, 최대경도(longitude)를 가리키게 됩니다. 
bounds의 2차원배열은  ymax와 ymin을 가리킵니다. bounds[x][0]..의 0에서 0, 1을 통해 ymax와 ymin을 가리킵니다. 즉, 최소위도, 취대 위도를 가리킵니다. (latitude)

 > bounds 그림 추가 (수정예정)

#### 5) scale
 
```js
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height;  
const scale = 1 /Math.max(widthScale, heightScale); 
```
그 다음 스케일을 정의해줍니다. 이 스케일은 지도에서 축척을 의미합니다. 넓은 우리나라 땅덩어리를 우리는 작은 화면에 표시해야 합니다.  일단 우리가 구한것은 path의 가장자리를 구한 것입니다. 
이것중에서 가장 최대값을 구하고 이를 이용해서 축척을 만들어줍니다. 5만배의 축소율을 가진 지도를 표시할 때 1 : 50000이라고 나타내며 이는 1 / 50000이라고도 합니다. 똑같이 우리는 축척을 1 / maxScale로 나타낸 것입니다.    

#### 6) translate
```css
.center {
  position: absolute;
  left: 50%;
  top: 50%; 
  transform: translate(-50%, -50%); 
}
```
어떠한 물건을 중앙에 놓으려면 어떻게 해야 할까요? 우리는 위의 코드처럼 left와 top을 50%씩 설정하고 자신의 크기만큼 translate를 -50%씩 주면 됩니다. 우리가 흔히 css로 어떠한 영역을 가로, 세로 중앙 정렬할 때 쓰는 방법이죠. 
```js
const xoffset = width/2 - scale * (bounds[1][0] + bounds[0][0]) /2 + 10; 
const yoffset = height/2 - scale * (bounds[1][1] + bounds[0][1])/2 + 80; 
const offset = [xoffset, yoffset];
projection.scale(scale).translate(offset);
``` 
지도도 또똑같습니다.  
 
위의 코드처럼 translate로 일단 사물을 옮기고 그 사물의 "크기의 50%" 만큼 또 옮깁니다. 똑같이 우리가 보여주는 크기의 반인 bounds의 반을 xoffset, yoffset으로 지정하고 translate를 통해 **중앙**으로 옮기면 됩니다. 

#### 7) selectAll
```js
map
.selectAll('path').data(_map.features)
.enter().append('path') 
.attr('d', path);  
``` 
D3.js에서 가장 중요한 구조가 뭐냐고 묻는다면 단연코 `.selectAll(요소).data(데이타).enter().append(요소)` 일 것입니다. 데이타 만큼의 가상 DOM을 생성 후 selectAll, 그 DOM에 데이타의 개수만큼(data) 특정 요소들을 붙이는 (enter & append)것을 이 4가지의 메소드 체인으로 구성할 수 있습니다. _map.features라는 지역적정보를 바탕으로 path를 만들 수 있습니다.

#### 8) 자몽을 놓을 위도 경도에 따라 매핑하기 
```js 
  const mapInfo = [
    {
      "name":"서울",
      "lat" : "37.532600",
      "lon" : "127.024612"
    },
    {
      "name":"대전",
      "lat" : "36.3730178",
      "lon" : "127.2483736"
    }
  ] 
```
우리는 자몽이라는 아이콘을 놓을 것입니다. 자몽에 해당하는 lat(위도), lon(경도)를 설정합니다.  
```js
const icons = svg.append('g').selectAll('svg')
.data(mapInfo)
.enter()
.append("svg:image")
.attr("width", 50)
.attr("height", 50)
.attr('x', d => projection([d.lon, d.lat])[0])
.attr('y', d => projection([d.lon, d.lat])[1])
.attr('opacity', 1)
.attr("xlink:href", require("../assets/grapefruit.svg"))
```  
이렇게 매핑을 하면 됩니다. 우리가 만들어 놓은 위경도 자료 만큼 svg를 붙이는(append) 하는 것입니다. 저렇게 attr을 이용해서 가로 세로, x좌표, y좌표, 투명도를 설정해주면 됩니다.  
 
#### projection 
```js
  function projection(point) {
    point = projectRotate(point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
    return [point[0] * k + dx, dy - point[1] * k];
  }
```
 * v5에서 달라진 부분존재 추후 수정예정

projection 메소드가 궁금할 것같아서 준비했습니다.  위경도에 해당하는 값을 배열로 받아서 첫번째에 그 투사법으로 추출되는 x, 경도를 반환하고 y, 위도를 반환합니다.  

​ 
#### 줌이벤트 
```js
const zoomed = () =>{
  map.attr('transform', d3.event.transform)
  icons.attr('transform', d3.event.transform)
}
const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
svg.call(zoom)
```
줌이벤트는 간단합니다. 이렇게 줌을 걸어주고자 하는 group에 transform 특성에 해당 event를 추가하고 zoom이 큰 svg에서 발동할 때마다 미리 설정해 놓은 이벤트들이 작동하게끔 설정해주면 됩니다. call은 자바스크립트의 call을 생각하면 됩니다.

#### call
```js
const 큰돌 = {
    "이름": "큰돌"
}

function editmyresume(능력, 힘) {
    this.능력 = 능력
    this.힘 = 힘
} 
editmyresume.call(큰돌, "Vue.js", "팔굽혀펴기") 
console.log(큰돌)
```
어떠한 함수를 실행하는데 객체를 넣어서 기본값을 설정할 수 있습니다. 

이제 다 만들었습니다.  결과물은 다음과 같습니다. 

![자몽지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_지도.gif)  


이렇게 D3.js를 이용해서 가벼운 지도예제를 만들어 보았습니다. 그 외에도 많은 것들을 D3.js로 구현할 수 있습니다. 다양한 예제들은 https://bl.ocks.org/mbostock 를 통해 볼 수 있습니다.
 
### 4.3 D3.js : 증가하는 숫자
좀 더 재밌는 예제를 만들어보도록 하겠습니다. 보통 게이지가 차면서 숫자가 증가하는 애니메이션 많이들 보죠? 그러한 것을 구현해보겠습니다.  

#### 전체코드 : MEVN/4장/sensor/src/views/Number.vue 
필수적인 코드만 차근차근 살펴보겠습니다. 
```html
<template>
  <div class="hello">
    <h2>커져가는 원속의 숫자 + 게이지</h2>
    <svg></svg> 
  </div>
</template>

<script>
  import * as d3 from 'd3';   
  export default {
    name: 'HelloWorld3',
    data() {
      return { 
      }
    },
    mounted() {
      this.showCircle();
    },
    methods: {
      showCircle() {  
        const width = window.innerWidth - 20;
        const height = window.innerHeight - 20; 
        const radius = Math.min(width, height) / 3;    
        const format = d3.format(".0%");  
        const group = d3.select("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
        const textDOM = group.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", ".3em");
          
        const arc = d3.arc()
          .innerRadius(radius * 0.7)
          .outerRadius(radius); 
        const pieGenerator = d3.pie().sort(null)
        const background = group.append("path")
          .data(pieGenerator([1])) 
          .attr("class", (d, i) =>"backColor") 
          .attr("d", arc)

        const foreground = group.append("path")
          .data(pieGenerator([0, 100])) 
          .attr("class", (d, i) =>`frontColor${i}`) 
          .attr("d", arc)
 

        function arcTween(pie){
          return function(d){ 
            const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
            const interpolateText  = d3.interpolate(0,pie[0].value); 
            return function(t){
              d.endAngle = interpolate(t);
              textDOM.text(format(interpolateText(t) / 100));
              return arc(d);
            }
          } 
        }   
        foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
      }
    }
  }

</script> 
<style>
  path.backColor {
    fill: #ff9c00;
  }
  path.frontColor0 {
    fill: #545f73;
  }
  path.frontColor1 {
    fill: #ff9c00;
  }  

  text {
    font-size: 7em;
    font-weight: 400;
    line-height: 16em;
    fill: black;
    font-family:오버워치;
  }
  @font-face {
    font-family: 오버워치;
    src: url(../assets/koverwatch.woff2);
  } 

</style>

```
#### 4.3.1 화면 설정 및 반지름설정
```js
const width = window.innerWidth - 20;
const height = window.innerHeight - 20; 
const radius = Math.min(width, height) / 3;  
```
현재 위도우의 width와 height에 맞춰 width, height를 잡고 그에 따라 반지름을 잡습니다.
#### 4.3.2 format설정 
```js
const format = d3.format(".0%"); 
``` 
d3.format을 이용하면 쉽게 어떠한 숫자에 포맷을 설정할 수 있습니다. 예를 들어 `1f`는 소수점1자리까지, `.0%`는 퍼센트 단위로도 가능합니다.  
#### 4.3.3 영역설정
```js
const group = d3.select("svg")
.attr("width", width)
.attr("height", height)
.append("g")
.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");     

const textDOM = group.append("text")
.attr("text-anchor", "middle")
.attr("dy", ".3em");
```
전과 똑같이 svg를 선택(select)를 하고 attr-width, height로 영역을 설정하고 transform 으로 중앙정렬합니다.  그리고 증가하는 숫자를 담을 text라는 요소를 설정합니다. 

#### 4.3.4 파이 제너레이터
```js
const arc = d3.arc()
.innerRadius(radius * 0.7)
.outerRadius(radius); 
const pieGenerator = d3.pie().sort(null)
const background = group.append("path")
.data(pieGenerator([1])) 
.attr("class", (d, i) =>"backColor") 
.attr("d", arc)

const foreground = group.append("path")
.data(pieGenerator([0, 100])) 
.attr("class", (d, i) =>`frontColor${i}`) 
.attr("d", arc)
``` 
숫자를 중심으로 증가하는 원을 만들기 전에 설정을 해야 합니다.`d3.arc().innerRadius(radius * 0.7).outerRadius(radius)` pie를 설정할 때 안쪽반지름(inner), 바깥쪽의 영역(outer)를 설정합니다. 안쪽을 0.7로 설정을 했으므로 안이 좀 비어있는 파이를 만들 수 있습니다.  그리고 `pieGenerator`를 이용해서 특정 배열을 통해 pie 제너레이터를 만듭니다. 그 제너레이터로 정확한 도넛형태의 모양을 그릴 수 있습니다.  

#### 4.3.5 애니메이션
```js
function arcTween(pie){
  return function(d){ 
    const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
    const interpolateText  = d3.interpolate(0,pie[0].value); 
    return function(t){
      d.endAngle = interpolate(t);
      textDOM.text(format(interpolateText(t) / 100));
      return arc(d);
    }
  } 
}   
foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
```
대망의 애니메이션입니다. 
interpolate는 2가지의 값을 이용해서 0부터 1까지의 값에 매핑을 합니다. 예제를 보면 쉽습니다.  
```js
var i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20
```
보간하다라는 뜻을 가진 이 interpolate는 주어진 2개의 값을 이용해서 그 사잇값들을 만듭니다.
이를 이용해서 우리는 애니메이션을 만들 수 있습니다. `pieGenerator([0, 100])`에서 부터 `pieGenerator([80, 20])`까지의 애니메이션을 하기 위해 `arcTween`이라는 것을 만들었습니다. 애니메이션을 사용하려면 매 순간순간마다 프레임이 있어야 하며 `arcTween`을 이용하면 매 순간 원에 해당한 정확한 path를 만들 수 있기 때문이죠

![증가하는 숫자](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_number.gif) 
  
### 4.4  실시간 센서시각화사이트 : 설계
이제부터 실시간 센서시각화사이트를 본격적으로 만들어 볼 것입니다. 
#### 4.4.1 아키텍처 구축
아키텍처를 구축해야 합니다. 어떻게 만들 것인지 그림으로 그려보는 것이 중요합니다. 
![아키텍처](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처.png) 

아주 간단한 아키텍처입니다. 센서를 내보내는 REST API를 통해 JSON형태의 센서를 받아 MongoDB에 저장한 후 그 값을 뽑아 내어 상태저장소인 Vuex를 통해 상태를 변이시키고 이를 통해 Chart로 표출하는 아키텍처입니다.

 > 참고

사실 아키텍처는 회사에서 정해주거나 팀원들끼리 정한 약속에 의한 양식에 맞춰 작성하는 것이 일반적입니다. 하지만 혼자 만들 때는 이렇게 아무렇게나 그려보면 됩니다. 아무렇게나 그려도 프로젝트를 설계할 때 그리는 것은 매우 중요하며 습관이 되어야 합니다.
보통 아키텍처를 그릴 때 아마존에서 사용하는 아이콘을 자주 사용합니다. 
![아키텍처_아마존](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처_아마존.png)
이 아이콘은 [아이콘링크](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/아마존아이콘.ppt) 를 통해 바로 다운 받을 수 있습니다. 참고하시길 바랍니다. 
 
#### 4.4.2 실시간 통신 : websocket방식과 polling 방식 비교  
실시간 통신이란 보통 Websocket으로 통신한다는 것은 HTTP를 기반으로 설정된 **ws프로토콜**을 통해 양방향통신을 하는 것을 말합니다.WebSocket 객체를 통해 양방향통신을 하는데 이 객체는 서버와의 WebSocket 연결을 생성하고 관리할 수 있는 API 들을 제공하며 가장 유명한 라이브러리로는 Socket.io가 있습니다. 하지만 오래된 브라우저의 경우(IE8이하) 미지원되므로 이 때는 websocket이 아닌 polling 방식, 주기적인 요청 또는 long polling, RESPONSE 받게 되면 REQUEST를 다시 요청(무한 재귀함수)로 구현해야 합니다. 

 > Q : Ajax랑 다른점이 뭔가요? 
 
클라이언트에서 요청하지 않아도 서버에서 클라이언트에게 원하는 시간대에 원하는 데이타를 줄 수 있다는 점입니다. 

#### 4.4.3 센서생성 서버 구축
센서데이타서버를 구축하는 방법은 크게 3가지가 있습니다. 첫번째는 정말 센서를 사서 구축하는 것이며 두번째는 기상청 Open API를 받는 것이며 세번째는 방재기상포털의 있는 파일을 통해 구축하는 방법입니다. 우리는 세번째 방법으로 해보겠습니다. 날짜는 2019년 8월2일 기준으로 했으며 지역은 제가 사는 강동구를 중심으로 했습니다. 방재기상포털은 https://data.kma.go.kr 에 가면 정말 쉽게 자료들을 다운받을 수 있으며 여기서 구축하는 예제의 파일은  MEVN/4장/sensor/RESTAPI/data/20190802_강동구.csv 에 저장해 두었습니다.  

```js
id,time,temp,wv,humi
402,2019-08-02 00:01,26.2,.4,85.7
...
```
데이타입니다. 한국말로 되어있는 것을 영어 key값으로 수정했습니다. 이를 mongoDB에 저장할텐데 MongoDB에 저장할 때 key값의 용량도 함께 들어가기 때문에 키값을 축소시키는 것이 중요합니다. windvelocity는 wv로 수정했고 humidity는 humi를 썼습니다. 

센서를 만드는 로직은 이렇게 cnt라는 전역변수를 통해 구현할 수도 있으며 제너레이터를 이용해서도 구현할 수 있습니다. 
먼저 cnt를 이용한 예제입니다. 

일단 먼저 유저를 추가합니다. 
```js
db.createUser({  
 user:"dabin",
 pwd:"dabin12010",
 roles:[  
  {  
     role:"readWrite",
     db:"sensor"
  }
 ],
 mechanisms:[  
  "SCRAM-SHA-1"
 ]
})
```
다빈, dabin이라는 이름을 가진 user를 추가했습니다. 이 때 sensor라는 DB를 만들지 않았다면 test라는 DB에 자동적으로 user가 추가가 됩니다.  

 > sensor DB 생성하기
 
0. mongo shell을 구동합니다.
1. sensor데이타베이스로 이동 `use sensor` 
2. 데이타베이스확인 : `show dbs` 아직 sensor가 생성되지 않았습니다.
3. 데이타베이스 생성, db.sensor.insert({"kundol" : 1})
4. 데이타베이스확인 : `show dbs` sensor DB가 생성되었습니다!

이제 앞서 설명한 createUser을 하면 sensor에 다빈이가 추가된 것을 볼 수 있습니다. `db.getUsers()`로 유저를 확인할 수 있습니다.

socket으로 conenction또는 reconnection이 될 때 유니크한 id(string)을 가집니다. 이를 이용해 연결된 user의 수 등의 로직을 구현할 수 있습니다. 이외에 클라이언트에서 지정해준 인자로 서버에서 관리할 수 있습니다.  

주석을 달 때는 첫번째 문자는 대문자로 해줘야 합니다.
서버에 들어가 node server.js로 서버를 구동시키고 클라이언트에서는 npm run serve를 통해 테스트 서버를 구동시킵니다.
#### MEVN/4장/sensor/서버/server.js
```js
const express = require('express')
const app     = express()
const cors    = require('cors')
const http    = require("http").createServer(app)
const io      = require('socket.io')(http)
const util    = require('./util')()
const sensorController = require('./controller/sensor')
const path    = require('path')  
const _path   = path.join(__dirname, '..', './dist')  
const PORT    = 12010 
const mongoose = require('mongoose')
//계정 설정 MongoDB 계정 보안 설정 이야기 
const USER = 'dabin'
const PWD = 'dabin12010'
const HOST = 'localhost:27017'
const DB = 'sensor'
const mongodbURL = `mongodb://${USER}:${PWD}@${HOST}/${DB}`
mongoose.connect(mongodbURL, {useNewUrlParser: true}); 
mongoose.set('useFindAndModify', false);
let userList = [];
const main = async()=>{
  //app 객체 설정 
  app.use('/', express.static(_path))  
  app.use(cors()) 
  mongoose.connect(mongodbURL, {useNewUrlParser: true}) 
  .then(() =>  console.log('connection succesful'))
  .catch((err) => console.error(err)) 
  //io 객체 설정 
  io.on('connection', (socket) =>{  
    console.log(`User connected :: ${util._date()} ID : ${socket.id}`)   
    userList.push(socket.id) 
    socket.on('chat message', (msg) =>{
      console.log('message: ' + msg);
    }); 
    socket.on('disconnect', () => {  
      console.log(`User disconnected :: ${util._date()} ID : ${socket.id}`)  
      userList.splice(userList.indexOf(socket.id),1); 
    });  
  }); 
  const jsonArray = await util.readCSV(); 
  setInterval(async () => {   
    const sensor = await sensorController.emitSensorAndSave(io, jsonArray); 
    console.log(`Emit user Current Sensor And Save DB :: ${util._date()} ${JSON.stringify(sensor)}`) 
  }, 10 * 1000);   

  http.listen(PORT, ()=> console.log(`센서서버가 시작됩니다. http://127.0.0.1:${PORT} :: ${util._date()}`));
}

main();  
``` 

#### MEVN/4장/sensor/서버/controller/senser.js
```js
const Sensor = require('../models/sensor.js'); 
const _ = require("fxjs/Strict"); 
const save = async(data)=> {
    const ret = await Sensor.findOneAndUpdate({
        "cnt" : {
            $eq : data.cnt
        }}, {
            $set : data
        }, {
            upsert: true, 
            multi: true, 
            new : true, 
            setDefaultsOnInsert: true
        }
    ).lean()
    return ret;  
};
// 전역변수로 증가시키는 setNextData
let cnt = 0;   
const setType = data =>{
    for(let key in data){
        if(key == 'time')data[key] = new Date(data[key])
        else data[key] = Number(data[key])
    } 
    return data; 
}
const setNextData = (jsonArray) =>{
    const l = jsonArray.length;    
    let data = jsonArray[cnt];  
    data = {cnt : cnt, ...setType(data)} 
    cnt = (cnt + 1) % l; 
    return data;    
}  

// 이터레이터로도 만들 수 있다. 
function *setCntIterator() {  
    let cnt = 0; 
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
} 

const iterator = setCntIterator(); 
const setNextDataIterator = (jsonArray) =>{
    const l = jsonArray.length;      
    const cnt = _.go(
        iterator, 
        _.take(1));
    let data = jsonArray[cnt % l]; 
    data = {cnt : cnt, ...setType(data)};
    return data;    
}


//testModule
exports.emitSensorAndSave = (io, jsonArray)=>{
    return new Promise((resolve, reject) =>{
        const data = setNextData(jsonArray) 
        //const data = setNextDataIterator(jsonArray) 
        io.emit(data); 
        save(data); 
        resolve(data)
    }) 
} 
```

#### MEVN/4장/sensor/서버/models/senser.js
```js
const Sensor = require('../models/sensor.js'); 
const _ = require("fxjs/Strict"); 
const save = async(data)=> {
    const ret = await Sensor.findOneAndUpdate({
        "cnt" : {
            $eq : data.cnt
        }}, {
            $set : data
        }, {
            upsert: true, 
            multi: true, 
            new : true, 
            setDefaultsOnInsert: true
        }
    ).lean()
    return ret;  
}

// 전역변수로 증가시키는 setNextData
let cnt = 0;   
const setType = data =>{
    for(let key in data){
        if(key == 'time')data[key] = new Date(data[key])
        else data[key] = Number(data[key])
    } 
    return data; 
}
const setNextData = (jsonArray) =>{
    const l = jsonArray.length;    
    let data = jsonArray[cnt];  
    data = {cnt : cnt, ...setType(data)} 
    cnt = (cnt + 1) % l; 
    return data;    
}  

// 이터레이터예제
function *setCntIterator() {  
    let cnt = 0; 
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
} 

const iterator = setCntIterator(); 
const setNextDataIterator = (jsonArray) =>{
    const l = jsonArray.length;      
    const cnt = _.go(
        iterator, 
        _.take(1));
    let data = jsonArray[cnt % l]; 
    data = {cnt : cnt, ...setType(data)};
    return data;    
}

exports.emitSensorAndSave = (io, jsonArray)=>{
    return new Promise((resolve, reject) =>{
        const data = setNextData(jsonArray) 
        //const data = setNextDataIterator(jsonArray) 
        io.emit(data); 
        save(data); 
        resolve(data)
    }) 
} 

```
#### MEVN/4장/sensor/서버/util/index.js
```js
const csvFilePath = '../data/20190802_강동구.csv' 
const csv         = require('csvtojson') 
const path        = require('path')  
const _path       = path.join(__dirname, csvFilePath)  
 
const _form = date => ("00" + date).slice(-2)   
module.exports = () => {
    return {
        async readCSV() {
            //const jsonArray = await csv().fromFile(csvFilePath);
            return await csv().fromFile(_path);
        }, 
        _date(){
            const d = new Date(); 
            return `${d.getFullYear()}-${_form(d.getMonth() + 1)}.${_form(d.getDate())} ${_form(d.getHours())}:${_form(d.getMinutes())}:${_form(d.getSeconds())}`
        }
    };
} 
```

그다음은 제너레이터를 이용한 예제입니다. 

자 이렇게 1초마다 센서데이타가 io.emit으로 연결된 모든 단말기에 전달되는 서버를 만들었습니다. 

 > 참고 : socket, broadcast, io.emit 차이

### 4.5  실시간 센서시각화사이트 : 실시간통신과 디자인 
백엔드를 구축했으니 이제 프론트엔드를 구축할 것입니다. 

#### 4.5.1 Vuex 및 프로젝트 뼈대 구축
Vuex를 써야 하는 이유는 간단합니다. 컴포넌트끼리 데이터를 주고 받으려면 props, emit으로 주고 받게 되는데 프로젝트가 커진다면 데이터를 전달하고 받는 컴포넌트간의 갯수가 많아지고 체크하기도 어렵기 때문입니다. 
중앙집중화된 어떠한 데이타들의 관리 / 어떠한 데이타들이 변환되는 것을 감시(watch)하고 싶다면 쓰는 것입니다. Vuex를 쓸 때는 비동기적인 것은 actions에 그 외 동기적인 것은 mutations에 넣어야 합니다. 그리고 state의 상태변이에 있어서는 꼭 mutations를 써야 합니다. 즉, actions에서 직접적으로 state를 수정하면 안됩니다. actions에서 mutation으로 commit을 통해 넘겨줘야 하며 mutations에서 state를 수정해야 합니다. 또한 반드시 모듈화를 해야 합니다. 
 

코드를 보면서 설명하도록 하겠습니다. 
#### 4.5.2 디자인 구축
이제 디자인을 좀 수정할 차례입니다. 많은 CSS 라이브러리와 프레임워크가 있지만 저는 절대 쓰지 않습니다. 왜냐하면 실력이 감소하기 때문입니다. 삼성, LG, 네이버, 다 독자적으로 만든 CSS 라이브러리나 자체 디자인으로 웹앱을 만듭니다. 간단한 프로젝트라면 추천드리지만 실력을 키우기 위해서는 스스로 CSS를 다룰줄 알아야 합니다. 네비게이션 중앙정렬, 카드효과를 구축해보겠습니다.  (반응형)

### 4.6  실시간 센서시각화사이트 : 차트 컴포넌트 
이제 차트를 구현해보겠습니다. 

#### 4.6.1 차트 컴포넌트제작
서버로부터 10개이상의 데이타가 들어왔을 때 차트가 그려지게 만들었습니다. 

#### 4.6.2 tooltip 이벤트 
이제 툴팁을 추가해보겠습니다.  

### 4.7  실시간 센서시각화사이트 : 모니터링 모듈 
이제 이러한 차트를 응용해서 하드웨어적인 부분을 모니터링 하는 모듈을 만들어 보겠습니다. 
#### 4.7.1 CPU, 하드웨어 모니터링 모듈 제작
일단 하드웨어적인 상태들을 json객체로 변환해주는 좋은 npm이 있습니다. 
