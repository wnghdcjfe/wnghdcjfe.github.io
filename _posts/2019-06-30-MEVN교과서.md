---
layout: post
title: 'MEVN교과서'
author: kundol
comments: true
date: 2019-06-30 20:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서

---  
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo.jpg) 

## 할일 목록   
 - [ ] bounds 그림 추가
 - [ ] projection deep dive 추가
 - [ ] svg.call 부분 deep dive(다른 돔 Q : 추가)
 - [ ] aggregate, mapReduce 예제 추가
 - [ ] 파이제너레이터 설명 추가  
 
# 이 책의 장점
기본적인 라이브러리 설명에 그치는 책보다는 좀 더 실무에 도움이 되는 책이 되고자했습니다. 2년 6개월의 MEVN 프로젝트 경험을 살린 코드로써 필수적인 것들만 담아냅니다. 프로젝트 설계시의 패러다임설정과 아름답게 코드를 짜는 법, 라이브러리 비교하고 보다 경험적인 코드를 녹이고자 했습니다. 

또한, 실시간 데이터 시각화 프로그램뿐만 아니라 작가소개플랫폼제작을 통해 보다 대중적인 웹 애플리케이션을 만드는데 도움이 되고자했습니다. 
 
 
# 지은이의 말
이 책에는 이러한 내용이 중점적으로 있습니다. Vue.js, D3.js, Node.js 그리고 MongoDB를 이용해 웹앱을 만드는 방법을 살펴봅니다. REST API와 실시간 통신, D3.js를 이용한 시각화 방법, 메시지큐, 로그처리, UX자동화, 크로스 브라우징 그리고 nginX까지 알아보게 될 것입니다. 이를 통해 실전적인 실력을 기르고자 하는 개발자들에게 심층적인 도움이 되었으면 합니다. 

인터넷에 간단히 검색해서 찾을 수 있는 내용들은 최대한 배제해고 경험 중심의 코드, 이해하기 어려운 지식들을 쉽게 설명한 내용만이 가득한 책이 되고자 노력했습니다. 또한 책의 코드가 그대로 실현되게끔 3번이상의 테스트를 거쳐 책의 코드 그대로 실행이 가능하게끔 노력했습니다.

아울러 이 책에 나오는 모든 예제코드들은 https://github.com/wnghdcjfe/MEVN 를 통해 다운 받을 수 있습니다. 또한 궁금한 사항이 있다면 언제든지 jhc9639@naver.com으로 보내주시면 빠르게 답을 드리겠습니다. 공통된 질문이 많다면 유투브 강의도 제작할 예정입니다. 이 책을 통해 열심히 고민하시고 삽질하시고 언제든지 메일을 보내주시기 바랍니다. 

또한, 책에 틀린 내용이나 지적할 부분이 있다면 귀담아 듣겠습니다. 조언 부탁드립니다. 

# 독자대상
이 책을 보려면 다음 기술에 대한 기본 지식이 있어야 합니다. 
 - HTML5
 - 자바스크립트
 - CSS 

위 3가지 기본기술을 쌓는데 도움을 주는 책으로는 **윤인성의 모던웹 디자인을 위한 HTML5 + CSS3 입문**, **모던웹을 위한 Javascript + JQeury 입문**을 추천드리며 웹사이트로는 자바스크립트Info, https://javascript.info/, 포이마웹, https://poiemaweb.com/, 큰돌의 터전, https://kundol.kr/ 을 추천드립니다. 


# 목차
## 1. 준비하기
### 1.1 VS CODE 환경설정
 - 개발환경구축
 - 확장도구 설정
 - 단축키설명

## 2. MEVN
### 2.1 Node.js
- Node.js의 기본 
- Pm2 라이브러리 설정 

### 2.2. Express
 - HTTP 요청에 응답하는 미들웨어 설정가능
 - HTTP 메소드, URL 기반으로 하는 라우팅설정  
 - 쉬운 서버구동 

### 2.3. Vue.js
- SPA와 Vue.js 
- SPA의 장점
- SPA와 단점 
- Vue-cli 설정
- Webpack

### 2.4. MongoDB
- MongoDB의 구조
- MongoDB의 특징
- MongoDB의 한계
- Mongoose와 MongoDB node.js 드라이버
- MongoDB 설치와 계정(유저 추가)
- MongoDB mongoose를 이용한 CRUD
- aggregate와 mapReduce 성능비교 

## 3. 코드최적화와 패러다임
### 3.1 함수형프로그래밍
- 함수형프로그래밍의 특징 
- 함수형프로그래밍 응용예제 

### 3.2 자바스크립트 최적화  
- 함수선택, parsInt와 ~~의 성능비교
- 함수선택, 객체를 복사하는 방법의 선택    
- 서버요청최적화 - 메모이제이션과 서버요청최소화 
- UX향상 : LAZY load와 이미지크기 축소    

### 3.3 CSS 최적화 

## 4. 실시간 데이터시각화사이트제작  

### 4.1 시각화 라이브러리 D3.js
- D3와 다른 시각화라이브러리 비교

### 4.2 D3.js : 지도매핑모듈
- topojson과 geojson비교
- D3.js를 이용한 지도그리기 및 줌이벤트

### 4.3 D3.js : 증가하는 숫자만들기
- 화면 설정 및 반지름 설정
- format설정 
- 영역설정
- 파이 제너레이터
- 애니메이션
  
### 4.4  실시간 센서시각화사이트 : 설계
- 아키텍처 구축    
- 실시간 통신 : websocket방식과 polling 방식 비교 
- 센서생성 서버 구축 
 
### 4.5  실시간 센서시각화사이트 : 클라이언트
- Vuex 및 프로젝트 뼈대 구축 

### 4.6  실시간 센서시각화사이트 : 차트 컴포넌트 
- 차트 컴포넌트제작  

### 4.7  실시간 센서시각화사이트 : socketio플러그인
- socketio플러그인제작

## 5. 미술작가소개플랫폼 제작
### 5.1 아키텍처
- 아키텍처 설계
- REST API 설계 
- 요청 제한 및 IP 설정 
- 스키마 구축
- 디렉토리 및 이벤트 설계 

### 5.2 JWT 인증방식 및 구축
 - JWT 소개
 - postman을 통한 테스트 

### 5.3 로그인 연동  
 - 로그인페이지구축 
 - naver, kakao, facebook 로그인 
 - JWT를 통한 인증

### 5.4 작가별 미술품정보 입력모듈 구축
- 이미지 업로드 모듈 
- summernote를 통한 입력 모듈제작
- toast UI editor를 통한 입력 모듈제작

### 5.5 개발보안 
- XSS, CSRF토큰 등 보안 주의사항 
- axios의 validateStatus, cancelToken 활용

### 5.6 DB구축 
- DB 저장 모듈제작 

### 5.7 이미지게시판
- 이미지 게시판 페이지 구축
- 무한 스크롤 이벤트
- Lazy load 적용 

### 5.7 결제시스템
- 네이버페이 SDK를 이용한 거래연동
- 카카오페이 SDK를 이용한 거래연동
- PAYCO SDK를 이용한 거래연동
 
## 부록 A. 안정적인 서버를 위한 구축과정
### A.1 로그시스템
- 실시간 로그시스템
- 로그 자료조회

### A.2 오류처리 
- 모나드이용 예제 
- uncaughtException 처리방법

### A.3 메시지큐 
- AMQP(Advanced Message Queueing Protocol)를 활용한 메시지큐로 서버불안정화 대비
- 메시지큐 만들어보기
- RabbitMQ 이용예제

## 부록 B. UX 테스트 자동화 프로그램 
- requests를 통한 과부화 테스트
- nightmare.js를 통한 테스트 프로그램 구축

## 부록 C. 크로스 브라우징
- CSS, JS 낮은 IE를 위한 변환
- BABEl
- 벤더 프리픽스제거 

## 부록 D. 웹개발자에게 꼭 필요한 상식들
- promise 사용법
- JavaScript this의 이해
- JavaScript 호이스팅
- JavaScript 실행컨텍스트와 클로저
- 브라우저 렌더링의 이해
- axios 와 비동기통신 

## 부록 E. D3.js의 기초
 
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/MEVN_1장.jpg)

# 1. 준비하기
무엇이든 시작하기 위해선 준비단게가 필요합니다. 운동을 하기 위해서는 웜업이 필요하고 사랑을 하기 위해선 순수한 마음이 필요합니다. 웹앱을 만들기 위해서는 편리한 에디터가 필요합니다. 많은 에디터가 있지만 저는 VS CODE를 추천하며 지금부터 VS CODE 환경설정 방법에 대해 살펴보겠습니다. 

VS Code는 마이크로소프트에서 개발되었으며 윈도우, macOS, Linux 운영체제에서 원할하게 실행됩니다. 2018년 개발 도구중 인기도 1위를 차지(stackoverflow 설문조사)했으며 Git 연동을 직접지원하여 Git을 통한 개발환경구축도 용이한 것이 특징입니다. 

설치는 https://code.visualstudio.com/ 를 통해 OS에 맞는 VS CODE 를 설치하면 됩니다.  

## 1.1 VS CODE 환경설정
설치후 그대로 이용할 수 있지만 우리는 커스터마이징해서도 사용할 수 있습니다. 자주 사용하는 폰트와 테마를 통해 자신의 개발환경을 만드는 것이 중요합니다. 

### 1.1.1 개발환경구축
Dracula Official 테마와 VS ICON 테마와 폰트로는 D2 Coding 폰트를 적용시켜보도록 하겠습니다. 설정 방법도 간단합니다. 
![테마설치](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/1_테마설치.PNG)
1. 마켓플레이스에서 Dracula Official을 선택해서 다운받습니다. 
2. `f1`을 누른 후 dracula 를쳐서 테마를 설정합니다. 

![테마설정](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/1_테마.png)
이처럼 색테마, 아이콘 테마도 위와 똑같이 설정할 수 있습니다. 

![폰트설정](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/1_폰트.PNG)   
폰트는 D2Coding폰트를 다운 받은 후 파일 >  기본설정 > 설정에 들어가서 D2Coding 폰트를 설정하면 됩니다. 

### 1.1.2 확장도구 설정
VS CODE는 많은 확장도구들이 장점입니다. 마켓플레이스에서 사용하고 싶은 확장도구들을 설치합시다. 

저는 주로 3가지의 확장도구를 사용합니다. 
 - 코드를 아름답게 배치해주는 Beautify
 - 색깔을 쉽게 파악할 수 있는 Color Highlight
 - HTML 태그들을 쉽게 생성할 수 있는 HTML Snippets  

설치되어있는 확장프로그램입니다. 
![그림1_1](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/plan/img/1_1.PNG)  

이 확장프로그램은 각각의 확장프로그램의 설명을 보고 따라하면 됩니다. 예를 들면, beautify 적용은 이렇게 하면 됩니다. 

![그림1_2](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/plan/img/1_2.png) 
 1. F1을 누르고 
 2. beautify를 칩니다(be만 쳐도 됩니다.)
 3. 엔터를 누릅니다.

![그림1_3](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/plan/img/1_3.PNG) 

들여쓰기가 되어있지 않은 코드가 

![그림1_4](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/plan/img/1_4.PNG) 

이렇게 들여쓰기가 되는 것을 볼 수가 있습니다. 

### 1.1.2 단축키설명   
자주 사용되는 단축키를 정리하자면 다음과 같습니다.
 - Ctrl + F : 텍스트 찾기
 - Ctrl + / : 주석(반대도 가능합니다.)
 - Ctrl + z : 실행 취소 
 - Tab : 들여쓰기
 - Shft + Tab : 반대로 들여쓰기
 - Alt + Shift : 같이 누르면서 드래그를 하면 세로 형태로 선택이 된다.
 - Ctrl + B : 왼쪽 EXPLORER창 해제 또는 설정

  
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/MEVN_2장.jpg)

# 2. MEVN
MEVN은 MongoDB, Express.js, Vue.js 그리고 Node.js를 이용해서 만드는 웹 어플리케이션이며 MEVN스택이라고 불립니다. 

## 2.1 Node.js
### 2.1.1 Node.js의 기본
Node.js는 Chrome V8 Javascript 엔진으로 빌드 된 비동기 이벤트 주도 Javascript 런타임, 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되며 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적인 서버사이드 플랫폼이자 코드를 실행할 수 있는 Javascript 런타임을 뜻합니다.

 > 런타임 : 프로그램이 실행되고 있을 때 그 프로그램이 존재하는 공간
 
즉, Node.js는 자바스크립트 프로그램이 실행되고 있을 때 그 프로그램이 존재하는 공간을 말합니다. 
따라서 Node.js를 이용해서 자바스크립트란 언어로 코드를 짜고 프로그램을 동작시켜 간단한 알고리즘이나 게임을 만들 수 있으며 Electron을 통해 데스크톱애플리케이션도 만들 수 있습니다. 

이 많은 특징을 가진 node.js를 이용해 우리는 서버를 만들 것입니다. 기본적으로 node.js를 이용해 서버를 만들자면 node.js 의 내장 객체 중 하나인 `http`를 이용해야 합니다. 

Node.js가 제공하는 내장객체들의 정보들은 node.js API인(https://nodejs.org/api/) 를 참고하면 됩니다. 
 
##### MEVN/1장/simple_http.js
```js
const http = require('http');    
const PORT = 12010; 
const server = http.createServer((req, res) => {  
  res.setHeader('Content-Type', 'text/plain; charset=utf-8'); 
  res.end('안녕하세요 MEVN프로젝트입니다.'); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
위의 코드처럼 쉽게 브라우저 URL에 http://127.0.0.1:12010/ 통해 **안녕하세요 MEVN프로젝트입니다.** 라는 문자열을 반환하는 서버를 만들 수 있습니다. 
 
##### MEVN/1장/simple_http2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
이 책에서는 JSON이라는 형식의 데이타를 주고 받습니다. http://127.0.0.1:12010/ 라는 요청이 들어오면 JSON을 반환하는 서버를 만들었습니다. 이름이라는 key를 가지고 큰돌이라는 value를 가지는 `JSON객체`를 반환하는 서버를 만들었습니다.  

-------

 > 참고 : json과 직렬화

json이란 JavaScript Object notation으로써 경량 데이타 교환방식을 뜻합니다. 읽고 쓰기 쉽고 파싱하며 생성하기 쉬운 장점이 있습니다. 
`{"이름" : "큰돌"}` 이러한 구조를 가진 json을 json object라고 하며`[{"이름":"큰돌"},{"이름":"큰돌2"}]`의 구조를 가진 JSON을 JSON Array라고 합니다.
JSONObject로 만들어야 key를 통해 value를 참조할 수 있으며 JSON.parse(obj)라는 메소드를 이용합니다. 반대로 문자열을 만들 때는 `JSON.stringify(obj)`라는 메소드를 사용합니다. 
이 JSON에는 2가지 규칙이 있습니다. 
1. JSON에는 주석이 들어갈 수는 있지만 주석이 들어가지 않는 것을 권장합니다. 
2. 기본 자료형은 다음과 같습니다. Number, String, Boolean, Array, Object, null 입니다. 이 기본 자료형이 아닌 것들은 **직렬화**가 되지 않으며 기본값으로 추천하지 않습니다. 

 > 직렬화란 외부의 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술을 말합니다. 


JSON직렬화는 JSON.stringify(obj)를 통해 문자열로 만들어 구현할 수 있습니다. 하지만 위의 자료형이 아닌 것은 직렬화가 안되겠죠. 예를 들어 `JSON.stringify({ "이름": undefined })` 이 객체는 직렬화가 되지 않습니다. 

따라서 직렬화라는 확장성을 위해 value의 값을 undefined로 초기화하는 것을 권장하지 않습니다. null이나 0, -999, 프로젝트에서 약속된 초기값으로 초기화하는 것을 권장합니다.
 
-------
 
##### MEVN/1장/simple_json.js
```js
const obj = {
  "이름" : "큰돌", 
  "나이" : 27,
  "나이2" : undefined
}
console.log(obj.이름) //큰돌
const _name = "이름"
console.log(obj[_name]) //큰돌
console.log(obj['이름']) //큰돌
console.log(obj['나이2'])  
```  
또한, JSON은 .을 통해 해당 value에 접근이 가능합니다. 변수를 통해 value에 접근하는 것은 []를 씁니다. 변수를 쓰지 않는 것은 .을 쓰며 변수를 통해 쓰는 것은 [name]을 통해 참조하는 것을 권장합니다.

이름이라는 key를 통해 큰돌이라는 value을 뽑아 낼 수 있으며 `_name`이라는 변수를 선언한 후 []에 담아서 뽑아 내는 것을 볼 수 있습니다.

다시 말하자면 .을 통해 해당 value에 접근이 가능합니다. 변수를 통해 value에 접근하는 것은 []를 씁니다. 변수를 쓰지 않는 것은 .을 쓰며 변수를 통해 쓰는 것은 [name]을 통해 참조하는 것을 권장합니다.

### 2.1.2 Pm2 라이브러리 설정
만약 node.js로 만든 서버가 죽는다면 어떤 일이 벌어질까요? 다시 회사에 출근해서 다시 서버를 구동시켜야 하죠 하지만 node.js로 만든 서버를 관리하기 위한 process관리자 라이브러리인 Pm2를 사용하면 그런 일은 벌어지지 않습니다.


 > 참고 : forever도 있지 않나요? 
 ---------
 
서버가 죽으면 다시 켜주는 forever이라는 라이브러리도 있지만 pm2가 멈춘 프로세스관리, 좀 더 깔끔한 UI, CPU클러스터 모드, 모니터링측면에서 더 좋습니다.

 ---------
 
일단 먼저 죽는 서버를 만들어보겠습니다. 잘못된 데이타가 들어왔을 때 필터를 안해주거나 예상치 못한 데이터에 관한 핸들러를 구축하지 않았을 경우 애러가 발생되며 그 애러는 서버를 죽게 만들 수도 있습니다.
##### MEVN/1장/simple_pm2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
}); 

setTimeout(()=>{ 
  //애러를 발생시켜서 1초마다 서버가 죽게 만듭니다.
  JSON.parse("{Z")
}, 1000)
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
위의 코드는 `JSON.parse`를통해 이상한 문자열을 JSON object로 만들다가 서버가 **죽는 코드**입니다. 

실행을 시키면 1초 만에 서버가 죽는 것을 볼 수 있습니다. `JSON.parse("{Z")`에서 애러가 생기는 것은 자명하죠. 하지만 **pm2**로 구동을 시키면 서버가 죽어도 자동으로 살아나는 것을 볼 수 있습니다. 서버가 죽으면 자동으로 서버를 무한으로 실행하는 프로그램입니다. 
살리는 것을 볼 수 있습니다. 
그렇다면 PM2를 설치해보도록 하겠습니다.  

`npm install -g`의 -g는 global로 전역으로 설치한다는 뜻입니다. 이렇게 전역으로 설치한 후애는 `pm2`라는 명령어를 쓸 수 있습니다. 

```
npm install pm2 -g
```

pm2를 이용해 전에 만든 simple_http를 구동시켜봅시다.  이렇게 구동하면 절대 죽지 않습니다. 정확히 말하면 죽지만 좀비처럼 다시 되살아나기를 반복합니다. 우리가 해야 할 일은 이렇게 임시조치로 살아나는 서버로 긴급상황을 막고 추후 로그를 보고 오류를 해결하면 되는 겁니다. 

 > 로그를 구축하거나 로그를 확인하는 것은 추후 5장과 부록에서 다룰 것입니다. 

```
pm2 start simple_pm2.js
```

구동이 된 후 `pm2 list` 를 통해 깔끔한 UI로 어떠한 앱이 실행되었나 보여주며 cpu, 메모리 사용량 등을 볼 수 있습니다. 
![pm2 list화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_list.PNG) 

한 앱에 대한 실시간 모니터링은  `pm2 monit`를 치면 다음과 같은 화면이 나오면서 할 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monit.PNG) 

종료나 pm2 관리하는 list에서 삭제는 다음과 같은 명령어로 할 수 있습니다. 
```js 
// 서버중단
// pm2를 이용한 서버 중단 Name, 또는 ID로 중단할 수 있습니다. 
pm2 stop simple_pm2
pm2 stop 0

// 삭제
pm2 delte simple_pm2
pm2 delte 0 
```

이외에도 `pm2 monitoring` 이라는 명령어를 사용하고 회원가입, 로그인을 하면 특정 웹애플리케이션이 띄워지고 그 안에서 CPU사용량, 메모리, HTTP로그, 이벤트 루프, 사용되는 Heap Size 등을 더 아름답게 확인할 수 있습니다.  

 > 이는 Free-trial버전으로 2주간 무료이며 그 이후에는 유료로 쓸 수 있습니다. 

![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monitoringUI.PNG) 

서버가 죽으면 다시 서버 재시작이 가능하고 `pm2 monit`을 통해 왠만한 모니터링을 할 수 있으며 클러스터링또한 가능하다는 점에서 pm2는 **안전한 서버구동**에 있어서 필수적이고 좋은 선택입니다. 
또한 부가서비스로 애러가 생기면 등록된 이메일로 애러알림까지 제공해주니 실시간관리측면에서 아주 좋습니다. 

 > 물론 서버가 안 죽게 만들어야 하는 것은 필수입니다.  


## 2.2. Express
node.js 에서 동작하는 웹개발 프레임 워크 중 많이 쓰이는 유연한 프레임워크입니다.  
핵심기술로는 이 3가지가 핵심기술입니다.  

1. HTTP 요청에 응답하는 **미들웨어** 설정가능
2. HTTP 메소드, URL 기반으로 하는 라우팅설정  
3. 쉬운 서버구동

이 있습니다. 이외에도 Jade란 템플릿을 통해 쉽게 웹페이지를 생성할 수 있지만 이 책에서는 사용하지 않으므로 설명을 하지 않습니다.

 > 라우팅 : 클라이언트가 요청 및 요청 예정되는 경로를 설정하는 작업

 > 미들웨어 : 중간에 껴놓은 소프트웨어, 여기서는 네트워크요청처리시 거쳐가는 중간 기능을 말합니다.

## 2.2.1. HTTP 요청에 응답하는 미들웨어 설정가능
```js
const app = express();

// --- 1번로직

app.use((req, res, next)=>{  
  console.log('Time:', Date.now());
  next();
});

// --- 2번 로직
``` 
이렇게 1번과 2번 로직 사이에 끼어놓는 로직을 미들웨어라고 합니다. `use`를 통해 미들웨어가 모든 요청에 대해 미들웨어를 추가했습니다. `app.get` 등을 이용해 특정한 HTTP 요청을 다루는 것이 아닌 use를 통해 모든 요청을 처리할 수 있습니다. 

모든 요청에 대해 중간에 거는 미들웨어를 추가하는 것입니다. 이를 이용하면 이런게 가능합니다. 

```js
var logger = require('morgan');
app.use(logger('tiny'));
```

이렇게 morgan이라는 로그 시스템 라이브러리를 놓게 되면 모든 요청에 대한 로그를 쉽게 파악할 수 있습니다. 

똑같이 `app.use(cors())`를 하면 HTTP 요청을 할 때 CORS를 허용한다는 것을 쉽게 설정할 수 있습니다. 

이처럼 중간에 어떤 로직을 설정하고 그 로직을 거쳐가고 싶어할 때 쓰이는 것이 바로 미들웨어입니다. 와퍼버거에 치즈를 추가하면 맛있듯이 미들웨어를 잘 추가하면 좋은 프로그램을 만들 수 있습니다. 

## 2.2.2. HTTP 메소드, URL 기반으로 하는 라우팅설정  

### 예1) get요청과 req.params
```js
app.get('/users/:userName/books/:bookName', (req, res)=>{
  console.log(req.params)
  //{"userName":"승철","bookName":"논어"}
  res.send(req.params)
}) 
``` 
이렇게 미들웨어를 설정한 후 사용자가 예를 들어 URL을  http://127.0.0.1:12010/users/승철/books/논어 라고 요청을 보냈다면 req.params로 받아서 쉽게 처리할 수 있습니다. 
저 console.log에는 올바르게 `{"userName":"승철","bookName":"논어"}` 라는 객체가 찍히게 됩니다. 
또다른 예를 들자면`users/love/books/something`라는 get 요청시 `req.params`에는 `{"userId":"love","bookId":"something"}`라는 값이 담기게 됩니다. 이외에도 post, put 등 다른 HTTP 메소드의 요청 또한 처리할 수 있습니다.


### 예2) /book이라는 url의 get, post, put 요청을 처리하는 함수
```js
app.route('/book')
  .get((req, res)=> {
    res.send('Get a random book')
  })
  .post((req, res)=> {
    res.send('Add a book')
  })
  .put((req, res)=> {
    res.send('Update the book')
  })
```

## 2.2.3. 쉬운 서버구동 
### 2장 simple_express.js
```js
const express = require('express');
const path = require('path')
const app = express();
const _path = path.join(__dirname, './dist')
console.log(_path)
app.use('/dist', express.static(_path))  
app.listen(12010, ()=> {
  console.log('너의 서버는? 12010!');
});
``` 
위의 코드처럼 `app.listen(12010)` 만으로 쉽게 서버를 구축할 수 있습니다. 예제 코드입니다. 

 > 항상 이렇게 app이라는 객체에 담는 것을 눈여겨 보시기 바랍니다.

/dist라는 요청을 받았을 때 dist폴더의 index.html을 보여주는 서버를 만들었습니다.
`__dirname`은 JS가 실행되는 현재 위치를 가리키는 Node.js의 전역 변수입니다. `path.join`을 사용해서 현재 서버를 구동한 위치로부터의 dist폴더를 제공한다라는 것을 아름답게 만들수 있습니다.

여기서 `express.static`은 정적 컨텐츠를 사용자에게 제공할 때 사용되는 메서드입니다. 특정 path에 해당하는 자료들을 사용자가 접근가능하게끔 합니다.

이렇게 서버를 구동한 후, http://127.0.0.1:12010/dist 에 가보면 아름다운 제 처음 서버가 완성됩니다. 

![2_simple_server](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_simple_server.PNG) 

#### path와 join, resolve
node.js의 path라는 모듈은 파일, 디렉토리의 관한 path들을 조작할 수 있는 좋은 모듈입니다. 
path를 다루는 메서드 중 많이 쓰이는 메서드는 join과 resolve입니다. 

| 메서드 | 설명 | 
|:--------|:--------|
| resolve	| 받은 인자들을 통해 절대 경로를 반환합니다.	|
| join	| 받은 인자들을 연결합니다.	| 

```js
const path = require('path')
const _resolve = path.resolve('.', 'dist', 'css')
const _join = path.join(__dirname, 'dist', 'css')
console.log(_resolve)
console.log(_join)
// C:\Users\LUCID\Desktop\개발\dist\css
// C:\Users\LUCID\Desktop\개발\dist\css
```
위의 _resolve와 _join 둘다 같은 경로를 반환합니다. resolve는 저 코드를 실행시킨 위치로부터 전체경로를 반환하고 join은 그저 경로들을 연결해서 반환합니다.  
 

## 2.3. Vue.js
### 2.3.1 SPA와 Vue.js  
Vue.js는 자바스크립트 프레임워크 중 인기있는 프레임워크 중 하나입니다. 재사용가능한 컴포넌트, 정말 쉬운 문법, React보다 빠르며, 중앙 집중식 상태관리 저장소인 vuex, Angular의 장점만 뽑은 점 등이 장점입니다. 저는 Vue.js가 React.js보다 반드시 더 커질 것이라고 믿는 개발자 중 한명입니다. 쉽고 빠르고 데이터 중심의 사고를 할 수 있어 좋습니다. 일부 개발자들은  Vue.js가 큰 프로젝트에서는 맞지 않는다고 하지만 저는 Vue.js가 나온 초창기부터 도전적으로 큰 프로젝트에 도입하였으며 대한민국 전비행단에 설치되고 향후 10년이상 쓰이는 프로그램에 Vue.js를 썼으며 정말 안전하고 성능도 좋은 결과를 경험했습니다.  

 - [기본가이드](https://vuejs.org/v2/guide/)
 - [DEEPDIVE](https://medium.com/@oneminutejs/a-deep-dive-in-the-vue-js-source-code-0-table-of-contents-170dcc3c8ec)

이 책에서는 Vue.js의 기본가이드를 설명해주지는 않으며 위의 기본가이드만으로도 충분히 마스터할 수 있습니다.  
 
Vue.js는 기본적으로 단일 페이지 애플리케이션(Single Page Application, SPA)이란 특징을 가지고 있습니다. 
SPA는 기본적으로 단일 페이지로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다는 장점이 있습니다.

link tag를 사용하는 전통적인 웹 방식은 새로운 페이지 요청 시마다 정적 리소스가 다운로드되고 전체 페이지를 다시 렌더링하는 방식을 사용하므로 새로고침이 발생되어 사용성이 좋지 않습니다. 그리고 변경이 필요없는 부분를 포함하여 전체 페이지를 갱신하므로 비효율적입니다. 

### 2.3.2 SPA의 장점 
SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하고 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 반응속도 등 UX가 향상되어 네이티브 앱과 유사한 사용자 경험을 제공할 수 있습니다. MPA와는 반대되는 특징들을 가지고 있습니다.

### 2.3.3 SPA의 단점, 1. 초기구동속도
초기 구동 속도, SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느릴 수 밖에 없습니다. 

### 2.3.3 SPA의 단점, 2. SEO문제
SPA는 서버 렌더링 방식이 아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이기 때문에 자바스크립트를 구동하지 않은 웹크롤러에 대해서는 크롤링이 되지 않습니다. 

 > SEO와 초기구동속도를 고려한다면 개발할 당시에는 SPA로 개발을 하고 배포할 때는 서버사이드 렌더링처럼하는 프레임워크인 NUXT 등을 사용하면 됩니다. 

### 2.3.4 Vue-cli 설정
자 이제 Vue.js를 이용한 프로젝트를 구축해보도록 하겠습니다.  
먼저 Vue-cli를 설치합니다.`npm install -g @vue/cli-init`

`vue create sensor` 을 통해 프로젝트를 생성합니다. 
![vuecli셋팅](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_vuecli.PNG) 
이렇게 셋팅합니다. 

이렇게 설정한 후 sensor폴더에 들어가 README.md를 봅니다. 
`npm install` 로 의존성 라이브러리를 모두 다운받은 후 `npm run serve`로 개발환경을 실행할 수 있고 `npm run build`로 빌드를 할 수 있습니다. 
`npm install` 후 `npm run serve`로 개발환경을 실행시킵니다. 

![시작되는화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_vue-cli-start.PNG) 

자 처음으로 Vue-cli로 만들어진 앱이 탄생했습니다! 이제 이걸로 개발을 하면 됩니다. 

### 2.3.5 Webpack

![webpack](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_webpack.PNG) 
우리는 Vue-cli와 Webpack이라는 것을 이용해서 테스트 개발환경을 구축했습니다. 이렇게 하면 Vue로 모듈적으로 개발을 하고 빌드할 때는 html, js, css **정적파일**로 번들이 되어 나오게 됩니다.

Webpack이란 웹에서 사용되는 모든 자원(html, js, css, vue, img) 등을 번들링 해주는 도구입니다. 번들링이란 여러개의 파일들을 하나의 파일로 묶는 포장작업을 의미합니다. 

이를 활용하면 개발할 때는 여러개의 모듈로 개발을 해서 쉽게 개발을 하다가 배포할 때는 하나의 파일로 최적화를 시켜서 배포를 할 수 있습니다. 
Gulp나 Grunt도 이러한 포장작업 도구들이지만 Webpack이 제일 좋다고 알려져 있습니다. 

웹에는 Vue라는 확장자가 있을 수 없습니다. 우리가 볼 수 있는 화면들은 모두 html, js, css로 이루어져 있습니다. 하지만 개발을 할 때는 편리하게 vue라는 도구를 쓰고 그 다음 배포할 때 우리가 볼 수 있는 html, js, css로 확장자를 바꿔서 제공할 수 있습니다. 이를 번들이라고 하며 Webpack을 통해 할 수 있습니다.  

 > Q : Vue-cli2가 좋나요? Vue-cli3이 좋나요?
 
 ----

우선적으로 Vue-cli3이 성능상 좋지만 만약 webpack에서 번들(build) 또는 테스트환경(dev)을 설정할 때 커스터마이징이 필요하다면 Vue-cli2를 사용하는 것이 좋습니다. 물론 Vue-cli3에서도 커스터마이징을 제공하지만 추상화되어있기 때문에 완전한 커스터마이징을 하기에는 쉽지 않습니다. 어떠한 명령에 따라 어떤 파일을 넣고 어떠한 문자열을 바꾸고 그 이후 webpack 을 통해 번들한다면 vue-cli2를 이용하는 것이 좋습니다. 
 
 ----

## 2.4. MongoDB
MongoDB란 NoSQL DBMS의 한 종류이자 NoSQL도큐먼트 지향 데이터베이스 시스템입니다. 

 > NoSQL이란 NotOnly SQL을 말합니다. 세상에 SQL만 있다는게 아니라는거죠.

MySQL 처럼 전통적인 테이블-관계 기반의 RDBMS가 아니며 SQL을 사용하지 않습니다. 유연하게 데이타를 저장할 수 있으며 Binary JSON형태인 BSON으로 저장이 되며 데이터 처리를 할 때는 JSON으로 처리를 할 수 있습니다. 

대용량INSERT에 대한 요건이 커지면서 NOSQL DBMS가 도입 시작되었고 방대한 양의 데이터를 충분히 빠른 속도로 처리할 수 있는 데이터베이스이자 먼저 NoSQL, Not Only SQL이며 관계형 DB가 아닌 유동인 DB라는 특징이 있습니다. 

NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것(Scale-out : 수평적 확장)을 목표로 등장하였습니다. NoSQL의 등장으로 작고 값싼 장비 여러 대로 대량의 데이터와 컴퓨팅 부하를 처리하는 것이 가능하게 되었고 유연성, 확장성 등이 RDBMS에 비해 좋습니다.

### 2.4.1 MonogoDB의 구조 
![몽고DB구조](/img/20190509_m.png)
여기서 중요한 부분은 스토리지엔진입니다. 이 엔진은 디스크에서 데이터를 어떻게 가져오고 어떻게 최적으로 저장할 것인지를 결정합니다. 3.2이상은 wiredTiger가 default이며 이외에도 MMAPv1, RocksDB가 있습니다.

서버안에 MongoDB자체가 전체 메모리의 메모리 버퍼를 전체의 50%를 쓰게 됩니다. 때문에 한 서버안에 프라이머리 / 세컨더리 **두개 절대 놓지 않는 것**이 중요합니다.

![MongoDB트랜젝션](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_MongoDBTransaction.png)  
트랜젝션이 일어나게 되면 `Jounal log`에 쌓이고 `Buffer pool`로 들어가 체크포인트, 그리고 `eviction`작업이 일어나게 됩니다.
이 때, 메모리가 부족할 경우 `eviction`이 잘되지 않고 메모리버퍼를 아예 지우는 작업을 하고 심할 경우 데몬이 죽게 됩니다.  
 - eviction : 메모리버퍼에서 필요없는 데이타를 삭제하는 작업
 - 체크포인트 : 메모리 버퍼와 디스크사이의 데이터 불일치를 해소하기 위해 메모리에서 디스크로 data 동기화를 하는 작업

 > 저널링 : 변경이록을 저장해서 롤백을 할 수 있도록하기 위함, 이 롤백은 ACID 중 지속성에 해당하는 것입니다.


### 2.4.2 MonogoDB 특징
MongoDB의 특징은 정말 많지만 크게 10가지만 뽑아 보았습니다.  

1. 그리고 한개의 DATA 구조는 key - value 형태로 이루어져 있으며 _id라는 고유한 아이디를 가집니다. 
2. 스키마 없이 데이터모델을 구현하지 않은채 그냥 유동적으로 데이타를 삽입할 수 있습니다. 
- 스키마 : 데이타베이스를 구성하는 속성, 관계 등 데이타 값들이 갖는 type들을 명시 해놓은 것을 말합니다. 
- 장점 : 다양한 서비스로부터 데이타를 쌓을 때 유동적으로 쌓을 수 있음
- 단점 : RDBMS인 경우에는 `int, char[14]`인 경우에는 18바이트 그러나 몽고디비는 한 도큐먼트로 칼럼이름또한 바이트에 추가가 되기때문에 바이트가 더 커집니다. 즉, 공간적인 소모가 많습니다.
3. `min, max, aggreate, mapReduce` 등 강력한 함수로 데이터를 뽑아내고 조합하는 등의 활동을 할 수 있습니다. `data`들을 모아서 초최대값을 뽑아내거나 최소값 등등의 행위를 할 수 있습니다.  
4. `ReplicaSet`을 이용해 이중화가 가능합니다. 
5. `BJSON(Binary JSON)` 형태로 저장합니다. JSON이 아니므로 lean()을 통해 순수 JSON을 만듭니다. 또한 JSON Object를 인자로 받아 추가하고 결과값을 JSON Object로 반환할 수 있습니다.
6. `geoSpartial` 인덱스를 써서 `2Dimension`좌표탐색에 활용이 가능합니다. 이것을 인덱싱이 자유롭다고 합니다.
7. `$lookup`을 통한 `collection join`이 가능합니다.
8. 쿼리정렬시 메모리 관련 애러가 발생할경우 다음과 같이 해결할 수 있습니다.
- 정렬 작업에 인덱스를 활용하고 적절하고 `limit`를 검
- 메모리 공간을 크게 놓음
- `find`명령어 대신 `aggregate`명령을 사용하고 `allowDiskUse`옵션을 `true`로 설정하는 것 
9. 도큐먼트에서 _id 라는 필드가 자동으로 그 도큐먼트의 프라이머리 키로 선정됩니다. 나머지의 인덱스는 세컨더리 키로 선정됩니다
10. 인덱스의 기본 정렬은 항상 오름차순으로 구현돼 있지만 이 인덱스를 읽는 방향에 따라서 오름차순 또는 내림차순의 효과를 얻을 수 있으며 인덱스에서 각 필드의 정렬을 오름차순, 내림차순 으로 결정할 수 있으며 대부분의 인덱스는 B-Tree를 적용합니다.(인덱스 정렬은 B-tree에서만 가능) 

 > 이 외 별로 중요하진 않지만 알아두면 좋은 MongoDB 지식들

1. 3.0, 3.2.x 이하 버전에서는 WireTiger 엔진 사용시 문제가 발생합니다. 3.4 이상버전을 권장합니다.
2. Background Index생성시 DB 자체에 Lock이 걸리며 쿼리지연이 발생되는데 이는 주로 새벽에 생성됩니다.
3. TDE 플러그인을 통해 엔터프라이즈버전에서 제공하는 보안적용이 가능합니다. 이 보안적용은 응용프로그램으로 보안이 가능(`bcrypt`모듈 등으로 암호화 하는 것)하지만 범위검색의 경우 수행이 불가한 것을 해결해줍니다.
4. 3.2이상 wired Tiger엔진이 default로 사용됩니다.
- LSM_Tree(로그 기반 병합트리)를 이용 읽기 성능을 포기하고 그만큼의 저장 성능을 향상시킨 솔루션 / 느린 읽기 성능을 보완하기 위해 블룸 필터를 사용 
5. 샤딩환경에서 index 설정시 각 샤딩환경안에서만 유니크합니다. 
6. Mongoose는 빠르지가 않아서 성능에 민감하다면 권장하지 않으며 Node.js 2.x 드라이버를 권장합니다. (3.x는 커넥션 문제가 발생됩니다.) 하지만 Mongoose를 많은 기업이 사용합니다.

 > 참고 : 같은 NoSQL인 Hbase와 비교

조회조건에 따라서 세컨더리 인덱싱이 필요하는데 Hbase는 그걸 하지 못하며 하둡에 올라가서 물리적으로 분리가 되어있으나 MongoDB는 샤드 단위로 논리적으로 분리가 되어있으며 wired tiger로 높은 수준의 ACID를 할 수 있습니다. 

또한 MongoDB는 JSON 형태로 쿼리를 만들고 BJSON 형태로 DB에 삽입, 추출이 가능합니다. 그렇기 떄문에 Type 변환이 일어나지 않으며 이를 통해 **JSON데이타를 주고받을때** 성능적으로 MongoDB는 더 나은 선택이 됩니다.   

 > 참고 : MongoDB의 ObjectId

각 document는 _id라는 고유한 키를 갖는게 특징입니다. 각 document를 생성하면 _id라는 primary key가 생성됩니다. 이외에 저장이 되는 키값은 secondary key로 저장됩니다.  
이 키는 12byte로 아래로 구성이 됩니다. 
 1. 4-byte의 초단위의 시간
 2. 5-byte의 랜덤value
 3. 3-byte의 random value로 부터 순차적인 값 
  
### 2.4.3 MongoDB의 한계
1. BSON document로 저장이 되는데 **최대 16mb의 크기**를 가지며 이 이상일 경우에는 GridFS API를 통해 저장을 해야 합니다. 또한 **리턴되는 result또한 16mb 이하**여야 합니다. 
2. 또한 BSON document **깊이의 최대는 100level 까지**입니다. 
3. db의 **name은 64자**보다 작아야 합니다. 
4. index의 **사이즈는 1024byte보다 작아야** 합니다. 
 
## 2.4.4 Mongoose와 MongoDB node.js 드라이버 성능비교
node.js를 이용해 mongoDB를 쓰려면 라이브러리가 필요합니다. 대표적으로 mongoose와 mongoDB node.js 드라이버가 있습니다. 드라이버가 더 빠르고 쓰기에는 mongoose가 더 쉽습니다. 또한 드라이버의 경우 3.x는 커넥션 부분의 버그가 있다고 알려져있어서 production모드에서 2.x를 많이 쓴다고 알려져있습니다. mongoose를 쓰는 기업들도 많지만 성능에 민감하다면 mongoDB node.js 드라이버를 써야 하는 것이죠. 자세한 사항은 [Mongoose와MongoDB벤치마크](https://medium.com/@bugwheels94/performance-difference-in-mongoose-vs-mongodb-60be831c69ad)를 참고하시길 바랍니다. 


### 2장/mongodb/models/photo.js 
```js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const PhotoSchema = new Schema({
  albumId: Number,
  id: Number,
  title: String, 
  url : String, 
  thumbnailUrl : String
});

module.exports = mongoose.model('Photo', PhotoSchema); 
```
MongoDB는 스키마를 만들지 않아도 데이타가 마구잡이로 들어갈 수 있습니다. 예를 들어 다양한 서비스로부터 DB를 구축한다면 스키마를 만들면 안되겠죠. 하지만 한가지 형태의 데이타를 받을 때는 스키마를 만드는 것이 유지보수성 측면에서 좋습니다. Photo라는 스키마를 만들었습니다. 
### 2장/mongodb/simple_mongoose.js
```js
const mongoose = require('mongoose');
const Photo = require('./models/photo.js'); // (3.1)
const fs = require('fs')
const path = require('path') 
const mongoDB = 'mongodb://127.0.0.1/my_database';
mongoose.connect(mongoDB, { useNewUrlParser: true }) // (1)
.then(() =>  console.log('connection succesful'))
.catch((err) => console.error(err));
const _path = path.join(__dirname, './data/photos.json')
const main = async()=>{
    const t = JSON.parse(fs.readFileSync(_path).toString()); // (2)
    console.time('5000건의 데이타 삽입')
    Photo.insertMany(t, function(error, docs) { // (3.2)
        console.timeEnd('5000건의 데이타 삽입')
    });
}  
main();
```
5000건의 데이타 삽입하는 예제를 만들었습니다. 코드를 설명하자면 다음과 같습니다. 
1) mongoDB에 연결합니다. 
2) 버퍼형태로 받아오는 JSON파일을 문자형태로 바꾸고 JSON.parse를 통해 JSON Object로 바꿉니다. (그래야 collection에 들어갑니다.)
3) 미리 설정해 놓은 photo model을 이용하여 데이타를 삽입합니다.

예제를 실행하면 약 1초정도의 시간이 걸립니다. 이렇게 mongoose가 그렇게 느린 것은 아닙니다. 자신이 진행하는 프로젝트에 있어 들어오는 나가는 데이타의 양을 예상 및 확인하고 성능을 고려하여 벤치마크 후 드라이버 또는 mongoose를 정하는 것을 추천드립니다. 

예제 데이타는 [JSONPlaceholder](https://jsonplaceholder.typicode.com/)사이트를 이용했습니다. 이 사이트를 이용하면 예제 데이타를 쉽게 만들어 낼 수 있습니다.


## 2.4.5 MongoDB 설치와 계정(유저 추가) v4.0.11
### MongoDB 설치
MongoDB CRUD를 하기전 설치하는 방법과 계정추가 방법을 알아보도록 하곘습니다. 먼저 설치입니다. https://www.mongodb.com/download-center/community 에 들어가서 MongoDB Server community를 설치하면 됩니다. 이 후 `mongo` 및 `mongod`를 아무 path에서도 실행가능하게끔 변수 설정을 합니다. 변수설정으로 들어가 path에 C:\Program Files\MongoDB\Server\4.0\bin
를 추가합니다. (이는 독자의 컴퓨터마다 다를 수 잇으며 MongoDB를 찾고 bin폴더까지의 경로를 찾아 추가하면 됩니다.) 이 후 컴퓨터를 재시작 하면 모든 준비가 끝이 납니다. 

 > 참고사항

 ----

 - 시스템변수 또는 사용자(계정) 변수 둘다 가능합니다. 시스템은 다른 계정에 대해서도 가능한 것이며 user에 대한 사용자 변수는 그 계정에 대해서만 path를 설정하는 것을 말합니다. 
 - bin : 리눅스 파일 시스템 구조 중 bin폴더에 명령들을 저장해 놓는 것이 일반입니다. 똑같이 MongoDB도 기본적인 명령어들이 들어가 있습니다. 
 - 현재 버전은 설치 이후 컴퓨터를 키면 자동적으로 mongoDB가 실행이 됩니다. 

 ----

MacOS는 Homebrew 등을 통해 설치한 후, `mongod --config /usr/local/etc/mongod.conf` 또는 그냥 `mongod`를 통해 MongoServer을 구동시키면 됩니다. 

### MongoDB 제거
가끔 설치가 잘 되지 않는 경우가 있습니다. 그것은 이전의 설치된 MongoDB버전 탓일 수도 있습니다. 그 때는 이 3가지의 방법으로 깔끔하게 지울 수 있습니다.
1. 환경변수 > path > 삭제
2. 내PC > C드라이브 > MongoDB 폴더 삭제
3. 프로그램 제거 > MongoDB관련 프로그램 제거 이 후 재시작


### 유저추가
KISA에서 나온 SW보안지침(2017)에 따르면 **애플리케이션에서 DB연결을 통해 데이터를 처리하는 경우 최소 권한이 설정된 계정을 사용해야 한다.취약한 애플리케이션으로 인해 침해사고가 발생하더라도 나머지 부분에 대해 공격자가 액세스 권한을 가지지 않도록 애플리케이션에서 사용하는 DB연결 계정은 해당 애플리케이션이 사용하는 데이터에 대한 읽기, 쓰기, 삭제, 업데이트 권한만 설정한다.** 라고 되어있습니다. 

즉, 그냥 연결을 하는 것이 아니라 최소한의 **권한을 가진 계정**을 통해 쿼리를 구현해야 합니다. 
위의 설명한 예 중 `const mongoDB = 'mongodb://127.0.0.1/my_database'; mongoose.connect(mongoDB, { useNewUrlParser: true })`은 계정 없이 연결한 예입니다. 하지만 production 모드에는 그래서는 안되겠죠? 이후 4장에서는 계정을 추가하여 할 것입니다.

먼저 MongoDB는 유저에 대한 SCRAM인증방법을 Default로 제공하며 
 - SCRAM-SHA-1
 - SCRAM-SHA-256

이 두가지의 방법을 제공합니다. 

 > SCRAM(Salted Challenge Response Authentication Mechanism) : 서버에 사용자 인증을 제공하는 현대적인 암호 기반 시도 응답 인증 방법
 
1. 먼저 추가할 DB를 선택합니다. use DB명입니다.
2. 유저를 생성합니다. db.createUser({user : 유저이름, pwd : 패스워드, roles : 권한}) 

#### 예제 1. root
role에는 userAdminAnyDatabase와 root, readWrite, read, Write 가 있습니다.  userAdminAnyDatabase와 root는 admin이라는 DB에서만 가능하며 readWrite, read, Write는 전체 DB에서 가능합니다.
```shell
> use admin
> db.createUser({ user: "root" , pwd: "root123", roles: ["userAdminAnyDatabase"], mechanisms : ["SCRAM-SHA-1"]})
``` 
admin이라는 DB에 root라는 이름을 가진 사용자를 추가했습니다.


#### 예제 2. 일반 유저  
```shell
> use sensor
> db.createUser({  
 user:"dabin",
 pwd:"dabin12010",
 roles:[  
  {  
     role:"readWrite",
     db:"sensor"
  }
 ],
 mechanisms:[  
  "SCRAM-SHA-1"
 ]
})
```  
sensor라는 DB에 다빈이라는 이름을 가진 사용자를 추가했습니다.

#### 예제 3. 일반 유저 role 과 db추가
```shell
> use sensor
> db.createUser({  
 user:"dabin",
 pwd:"dabin12010",
 roles:[  
  {  
     role:"readWrite",
     db:"sensor"
  }, 
  {  
     role:"read",
     db:"photo"
  }, 
 ],
 mechanisms:[  
  "SCRAM-SHA-1"
 ]
}) 
```
위의 코드 처럼 role과 DB별로 각각 다르게 추가할 수도 있다. 

  > 참고 : 이외 계정(user)관련 명령어

 ----

 - 전체유저확인 : db.getUsers() 
 - 유저삭제 : db.dropUser("dabin") ""안에 user이름을 넣어서 삭제 
 - 유저 찾기 : db.getUsers({ filter: { mechanisms: "SCRAM-SHA-256" } })를 통해 filter 
 
 ----

## 2.4.6 MongoDB Mongoose를 이용한 CRUD
mongoDB는 스키마를 정하지 않아도 데이타가 마구잡이로 들어가는 것이 장점입니다. 실제로 네이버에서 많은 서비스들을 통합적으로 관리하는 로그DB를 생성할 때 스키마가 모두 다르기 때문에 그 이유로 mongoDB를 통해 데이터를 쌓았다고 합니다. 많은 서비스를 통합적으로 관리하는 것에서는 스키마레스, 스키마가 없는 것이 좋지만 보통 DB를 만들 때 스키마를 정합니다. 정하지 않는다면 추후 관리가 어려운 측면이 있기 때문입니다.

### 2장/mongodb/models/photo.js
```js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const PhotoSchema = new Schema({
  albumId: Number,
  id: Number,
  title: String, 
  url : String, 
  thumbnailUrl : String
});

module.exports = mongoose.model('Photo', PhotoSchema); 
```
Photo라는 document의 스키마를 구축 했습니다. 참고로 Photo로 만들면 복수형태로 MongoDB에 저장이 됩니다. Photo > Photoes이며 person을 저장하면 people로 변환되어 저장이 됩니다. MongoDB의 재밌는 특징 중 하나입니다. 

이제 이 스키마를 통해 모델을 만들고 그 모델을 통해 데이타를 삽입, Create, 조회, Read, 수정, Update, 삭제, Delete를 해보겠습니다.
먼저 공통적인 코드를 작성해보겠습니다. 바로 connection 부분입니다. 추가한 계정정보와 host, 연결한 DB명을(sensor)을 통해 mongodbURL을 완성한 후 연결하면 됩니다. 
```js

const mongoose = require('mongoose')
const USER = 'dabin'
const PWD = 'dabin12010'
const HOST = 'localhost:27017'
const DB = 'sensor'
const mongodbURL = `mongodb://${USER}:${PWD}@${HOST}/${DB}` 
mongoose.set('useFindAndModify', false);
mongoose.connect(mongodbURL, {useNewUrlParser: true}) 
.then(() =>  console.log('connection succesful'))
.catch((err) => console.error(err))
const Photo = require('../models/photo.js'); 
```
이 공통적인 부분은 아래의 모든 코드의 공통적으로 쓰이며 생략했습니다. 

## 1. Create
### 2장/mongodbs/simple_save.js
```js
...

const main = async()=>{ 
    const _data = {
        "albumId": 12010,
        "id": 12010,
        "title": "큰돌",
        "url": "https://via.placeholder.com/600/13454b",
        "thumbnailUrl": "https://via.placeholder.com/150/13454b"
    } 
    const new_photo = new Photo(_data) 
    const t = await new_photo.save();
    console.log(t)
}  
main();
```
전에 테스트를 할 때 insertmany와는 달리 save의 경우 하나의 document만 insert가 가능하고 class를 통해 객체를 만들 듯 Photo라는 클래스에 _data라는 초기값을 받아 만든 new_photo를 통해 데이타를 삽입시킬 수 있습니다. 

## 2. Read
### 2장/mongodbs/simple_read.js
```js
...

const main = async()=>{  
  const t = await Photo.findOne({
      "title" : {
        $eq : '큰돌'
      }, 
      "url" : {
        $eq : 'jhc9639@naver.com'
      }
    }).lean();
  console.log(t)
}  
main();
```
이렇게 findOne을 통해 쉽게 title이 큰돌, url이 jhc9639@naver.com 인 것을 찾아 낼 수 있습니다. 하나만 찾을 때 findOne을 사용하며 여러개를 찾고 싶을 때는 find를 사용합니다. 위의 코드처럼 JSON객체를 편집하듯 key와 value를 맞춰주면 됩니다. `"title" : {$eq : '큰돌'}` 처럼 {field : 객체} 로 설계를 하면 됩니다. $eq는 해당값과 일치하는 값을 가진 document를 찾는 것이며 그 외에  $ne : 일치하지 않음,$in : 안에 포함되어 있음 등이 있습니다.  

또한, [MongoDB Query](https://docs.mongodb.com/manual/reference/operator/query/)를 보며 공부하실 것을 추천합니다.  

 > 참고 : lean()

 ---- 
코드의 끝에 lean()이라는 메소드 체인이 걸려있는데 무려 성능차이에서 4배를 일으키는 이 lean()은 순수 자바스크립트 객체를 리턴하는데 쓰입니다. 이것을 쓰지 않는다면 Mongoose의 getters/setters 가 담긴 Mongoose Documents를 리턴하기 때문에 find로 docs를 받을 때 JSON.parse를 무조건 해줘야 합니다. 하지만 이 소주를 추가한다면 그럴 필요 없이 JSON Object로 받을 수 있습니다.
 ----


## 3. Update
어찌보면 가장 많이 쓰이는 구절입니다. 솔직히 이 Update만 있으면 만능입니다. 예를 들어 이 데이타가 있는지 없는지를 파악한 후 없으면 삽입, 있으면 이 특정 데이터로 수정하게 하는 로직도 구현할 수 있으며 응용이 무궁무진 합니다. 

어떠한 key값을 가진 항목이나 항목들을 update 시킵니다. 

update의 구조는 다음과 같습니다. 
```js
update({where},{set},{option}) 
```
where, 어떤 한 값을 찾아서, set, 뭘 어떻게, option, 어떤 옵션하에 변화시킬지를 정해서 document를 변화시킬 수 있습니다. 
이 때 where과 set은 필수이며 option은 선택입니다.

먼저 옵션입니다. 
1. upsert,  앞의 쿼리를 통해 찾는 값이 없다면 값을 insert합니다. 
2. multi,  update를 할 때 한가지만이 아닌 그 전부를 업데이트합니다. 앞의 설정을 안하면 그 key에 맞는 값 한가지만 업데이트 됩니다. 
3. new, 쿼리수행후 갱신된 값을 반환합니다. 새로운 값으로 저장한 뒤 확인할 때 쓰입니다. 
4. setDefaultsOnInsert, 쿼리를 날릴 때 default값을 insert하게 해줍니다.

```js
{
  upsert: true  
  multi : true  
  new : true 
  setDefaultsOnInsert: true 
}
```

이렇게 JSON 형태로 true, 또는 false의 값을 가진채로 쓰이게 됩니다.  

### 2장/mongodbs/simple_update.js
​
```js
...
const main = async()=>{  
    const t = await Photo.updateMany({
        "title" : {
          $eq : '큰돌'
        }
      }, {
        $set : {
          "url" : 'jhc9639@naver.com'
        }
      }, {
        upsert: true, 
        multi: true, 
        new : true
      }).lean();
    console.log(t)
}  
main();

```
큰돌이라는 title을 가진 document의 url을 변경시켰습니다. 옵션을 주어 그 값이 없다면 insert, 해당되는 값이 많다면 전부 반영, 리턴되는 값은 업데이트된 값으로 설정했습니다.  
 
```js
...
const main = async()=>{  
  const t = await Photo.updateMany({
      "title" : {
        $in : ['큰돌', '홍철', '현영','승철']
      }
    }, {
      $set : {
        "url" : 'jhc9639@naver.com'
      }
    }, {
      upsert: true, 
      multi: true, 
      new : true
    }).lean();
  console.log(t)
}  
main();
```
$in을 사용하면 "그 중 하나 값이 포함되어있다면"을 구현할 수 있습니다. 여러개의 이름이라는 값을 가졌다면 그 값을 update시킵니다.  
```js
...
const main = async()=>{  
  const t = await Photo.updateMany({
      "title" : {
        $in : ['큰돌', '홍철', '현영','승철']
      }
    }, {
      $push : {
        "something" : {
              $each : [1, 2, 3]
        }
      }
    }, {
      upsert: true, 
      multi: true, 
      new : true
    }).lean();
  console.log(t)
}  
main();
``` 
이외에도 만약에 그 값이 Array이며 push를 하고 싶다면 이렇게 $set부분에 $set이 아닌 $push를 집어 넣으면 됩니다. 

```js
...
const main = async()=>{  
  const t = await Photo.updateMany({
      "title" : {
        $in : ['큰돌', '홍철', '현영','승철']
      }
    }, {
      $set: {
        "something2" : 1
      }, 
      $addToSet : {
        "something" : {
              $each : [1, 2, 3]
        }
      }
    }, {
      upsert: true, 
      multi: true, 
      new : true
    }).lean();
  console.log(t)
}  
main();
``` 

만약에 어떠한 값은 이렇게 set, 정하고 어떠한 값은 push를 하는데 만약에 그 배열이 있다면 있는 것은 그대로 내버려두고 없는 것만 push 하고 싶다면 위와 같이 하면 됩니다. set과 addToSet이 있죠? set으로 어떠한 값을 변경시키고, addToSet으로 중복되는 값은 제외한채 push를 할 수 있습니다. 이렇게 쉽게 json을 설계하듯 query를 마음대로 수정해서 쓰면 됩니다.  

## 4. Delete
```js
Photo.deleteMany({}).lean();  
Photo.collection.drop()  
```
제거는 이렇게 하면 됩니다.이렇게 간단하게 CRUD를 살펴보았습니다.  

## 2.4.7 aggregate와 mapReduce 성능비교 
MongoDB에서의 집적된 결과물을 내기 위한 방법은 크게 2가지입니다.
 - aggregate
 - mapReduce 

이외에 수작업으로 map, filter, reduce를 이용해서 만들 수도 있지만 성능상 좋지 않은 선택입니다. 예를 들어 어떠한 값을 추출한다고 했을 때 그 document들을 모두 메모리상에 올리고 그 다음에 작업하는 것보다는 monogoDB에서 주어지는 API인 aggregate, mapReduce를 사용하는 것이 더 빠릅니다.


### 1. aggregate
pipeline기반의 프레임워크입니다. 여러단계의 파이프라인을 통해서 직접된 결과물을 낼 수 있습니다. 또한 mapReduce 대신 쓰일 수 있습니다. 

#### aggregate와 mapReduce의 차이
 - mapReduce가 더 유연하다 : aggregate는 컴파일된 C++코드를 실행하고 mapReduce는 javascript해석기로 실행되므로 mapReduce가 더 유연하고 더 복잡한 것을 구현해낼 수 있습니다.
 - aggregate가 더 빠르다 : mapReduce작업은 BSON이 지원하는 32, 64비트 정수에 대해 자바스크립트 정수타입인 64bit IEEE754방식으로 변환해서 JSON직렬화 과정을 수행해서 로직을 수행하고 그 다음 다시 BSON으로 변환해야 하기 때문에 느립니다. 하지만 aggregate는 BSON에 이러한 변환작업을 가하지 않고 쿼리를 수행합니다. 그래서 약 10배정도 빠르다고 합니다. (다른 분들의 테스트결과를 보면 약 3 ~ 5배정도 빠릅니다.)
 - 상황에 맞게 쓰자 : 더 복잡한 상황의 경우 mapReduce를 쓰는 게 좋고 그렇지 않을 경우는 aggregate를 쓰는 것이 좋습니다. 예를 들어 매시간마다 최대, 최소치를 뽑고 십다면 mapReduce를, 전체시간 중 1분간격의 데이타로 어떠한 결과물을 만들어내는 경우 aggregate를 쓰는 것이 좋습니다. 물론 test를 해서 결정을 해야 합니다.
 
두개 다 공통적으로 `console.log`가 먹히지 않습니다. MongoDB 내부에서 동작하기 때문입니다. 하지만 `print()` 또는 `--logpath D:\path\to\log.txt`로 디버깅할 수 있으며 MongoDB Shell을 통해 디버깅을 합니다.  

#### aggregate 코드 예제 
```js
//status라는 키가 a라는 것만 찾아서 total이라는 amount라는 키를 가진 값을 모두 더한 도큐먼트를 생성합니다. 
db.orders.aggregate([
	{$match : {status : "a"}}, 
	{$group : { _id : "$cust_id", total : {$sum : "$amount"}}}
]) 
//group을 통해 하나의 값으로 만들 수 있다. 
db.articles.aggregate( [
  { $match: { $or: [ { score: { $gt: 70, $lt: 90 } }, { views: { $gte: 1000 } } ] } },
  { $group: { _id: null, count: { $sum: 1 } } }
]);

//group을 하지 않으면 좀 더 복잡한 쿼리를 만들 수 있다.
db.companies.aggregate([
  {$match: {author: "dave"}},
  {$sort: {author: 1}},
  {$skip: 10},
  {$limit: 5},
  {$project: {
    _id: 0,
    author: 1}}, 
])

//이렇게 좀 더 복잡하게 할 수 있다. time의 값을 분단위로 뽑아내서 minute라는 것을 만들고 0초마다의 데이타를 뽑아낸다.
db.companies.aggregate([
  {$match: {score: {$gte : 1, $lte : 100}}},
  {$sort: {author: 1}},
  {$skip: 10},
  {$limit: 5},
  {$project: {
    _id: 0,
    time : 1, 
    author: 1, 
    minutes : {$minute : "$time"} 
 }}, 
 {
     $match : {$minutes : {$eq : 0}}
 }
])

``` 

### 2. mapReduce  
좀 더 복잡한 쿼리를 위한다면 mapReduce를 써야 합니다. mapReduce는 이런식으로 구현할 수 있습니다.
```js
db.orders.mapReduce(
	function() {emit(this.cust_id, this.amount); }, 
	function(key, values){ return Array.sum(values)}, 
	{
		query : {status : "a"}, 
		out : "order_totals"
	}
) 
```  


> 참고 : DB에 필요한 지식들

 ---- 
#### 샤딩
데이터베이스 서버를 확장하려면 데이터베이스의 데이터가 여러 서버로 분산될 수 있게 미리 응용 프로그램을 설계하고 개발하는 것을 말합니다.
 - 스케일 업 : 단일서버 증가
 - 스케일 아웃 : 여러대의 서버로 확장  

#### ACID
ACID(원자성,일관성,독립성,지속성)는 데이터베이스 트랜젝션이 안전하게 수행되는 것을 보장하는 특성의 집합입니다. 데이터베이스에서 데이터에 대한 하나의 논리적 실행단계를 트랜잭션이라고 합니다.

 - 원자성(Atomicity): 트래잭션과 관련 된 일들이 모두 수행되었는지 아니면 모두 실행이 안되었는지를 보장하는 능력 
 - 일관성(Consistency) : 시스템이 가지고 있는 고정요소는 트랜잭션 전과 후가 동일해야 함
 - 독립성(Isolation) : 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음(참조를 하지 못한다)
 - 지속성(Durability) : 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있음

#### DR
Disaster Recovery 서비스는 재해 복구 시스템입니다. 

IDC별, 전산실별, 지점별 등 지역적으로 분리된 서버들에 대해 무정지 서비스 가능하게 하며 데이터의 이중화 구성이 가능합니다. 갑작스런 네트워크의 단절, 네트워크 노드의 불안정, 장비의 다운, 정전 등으로 인한 문제를 해결합니다. auto failover도 같은 뜻입니다. 

 > IDC : 인터넷 데이터 센터(Internet data center)
 
#### 쿼리튜닝 
쿼리를 튜닝한다는 것은 처리에 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말합니다.
인덱스 선택을 얼마나 많이 하느냐 / 필요한 것 대비 얼마나 많은 도큐먼트를 읽느냐에 따라 **잘하느냐를 판단**할 수 있습니다. 

 ----

이제까지 MEVN 스택을 모두 알아보았습니다. 이것을 기반으로 바로 코드를 짜며 프로젝트를 구현할 수 있지만 그전에 "어떻게" 짜느냐 를 정하는게 중요합니다. 같은 로직이라도 어떻게 짜느냐에 따라 성능이 달라지고 개발자들이 웃음을 짓게 만드는 코드가 탄생하거나 화나게 하는 코드를 탄생시킬 수 있습니다. 어떻게 짜는지 그리고 프로젝트 구축에 있어서 중요한 점이 무엇인지 이제부터 알아보도록 하겠습니다.
 
 

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/MEVN_3장.jpg)

## 3. 코드최적화와 패러다임
코드를 짤 때 그저 주어진 로직만을 짜면 안됩니다. 항상 코드를 짤 떄는 그 코드의 확장성, 유연성, 성능 등을 모두 고려해야 합니다.  

### 3.1 함수형프로그래밍
그렇다면 어떻게 짜야 할까요? 한 프로젝트당 코드 패러다임을 정해놓고 짜는 것이 중요합니다.패러다임이란 어떻게 짤 것인지를 규정한 것을 말합니다. 객체지향형으로, MVC패턴으로 ,함수형프로그래밍으로 짜자 등을 일컫습니다. 예를 들어 CSS의 경우 `margin: 0 px`는 `margin : 0` 으로 놓자 등이 해당합니다.  

저는 코드를 짤 때 함수형프로그래밍으로 짜는 것을 추천하며 이 책에서는 함수형프로그래밍으로 모든 소스코드를 짜도록 하겠습니다.

### 3.1.1 함수형프로그래밍의 특징 
함수형프로그래밍은 작은 순수함수들의 집합으로 최소의 부수효과를 누리는 패러다임입니다.

좀 더 자세히 말하자면 함수들을 작게 쪼개서 블록을 쌓듯이 로직을 구현하고 다형성을 높이고 고차함수를 활용하여 재사용성을 높이고 참조투명성을 통해 부수효과가 줄어들어 유지보수성을 증대시키는 함수형 프로그래밍에 대해서 알아보겠습니다. 함수형프로그래밍을 하면 단순하고 간결한 흐름 중심의 모델이 되고 서술부와 평가부가 분리되어 지연평가가 가능합니다.   
 
 > 다형성, 어떠한 인자든 가능한 것 
 
 > 참조투명성: 함수의 출력은 오로지 그 함수에 입력된 값에만 의존성을 가진다는 의미
 
 > 추상화를 높이다. : 다형성을 증가시켜 특정 데이터형에서 분리한다는 것


함수형 프로그래밍에는 여러가지 특징들이 있습니다. 그 특징들을 살펴보겠습니다.  

#### 1. 순수함수와 참조 투명성 
순수함수란 동일한 입력을 받아서 동일한 출력을 하는 것을 말합니다. 참조투명성의 성질을 가지고 있습니다.   
```js
const PURE = (a, b)=>{
    return a + b; 
} 
const not_PURE = (a)=>{
    return a += 10;  
}
```
위의 `PURE`는 순수함수고 아래 `not_PURE`는 순수함수가 아닙니다. 
외부의 인자를 변화시키지 않고 값이 일정해야 합니다. 10을 더하는 함수지만 외부의 a의 값을 증가시켜서 부수효과가 생기게 했습니다. 
이는 순수함수가 아닙니다. 예를 들어 Math.max는 순수함수입니다. 무조건 들어온 인자들을 토대로 최대값을 반환하기 때문입니다. 외부의 값들은 상관하지 않고 그저 들어오는 인자값만을 이용해서 결과를 도출해내는 것이 순수함수입니다. 

하지만 프로젝트를 하다 보면 전역변수를 쓸 때가 있습니다. 그러나 함수형프로그래밍을 한다면 1) 최대한 지역변수만을 써서 구현해야 합니다. 그리고 2) 인수로 넘기는 값의 본체조차 수정되면 안됩니다. 3) 인자로 넘기는 값이 객체라면 원본객체에 변이를 일으키지 않도록 주의해야 합니다. `deep copy`를 한 후 변이를 하던가 등의 방법을 써야 합니다.  
```js
var c = 0;
//받은 인자자체가 변함
function f(){
  return c++;
}
//인자를 변화시키지 않고 +1을 할 수 있다.
const f = c => c + 1
```
이렇게 인자를 변화시키지 않아야 합니다. 

#### 2. 고차함수
함수가 다른 함수를 인자로 받아서 어떠한 로직을 생성하는 함수를 말합니다.  

 > 고차함수는 함수를 값자체로 넘길 수 있는 **일급객체**여야만 가능합니다. 자바스크립트는 일급객체인 특징이 있어 가능한 것입니다. (고계함수 = 고차함수)

#### 2.1 map
map은 함수 a를 받는 고차함수입니다. 

 > map이나 filter는 어떠한 값 [a]를 받아 새로운 []를 리턴하는 모나드 함수의 일종입니다. 

```js
const a = (a)=>{
    return a + 10; 
}
const b = [1, 2, 3].map(a)
console.log(b)
```

#### 2.2 함수를 실행하여 리턴하는 `_call` 
```js
const _call = (a, b) => a() + b() 
```
**일급객체**란 함수를 변수에 담을 수 있고 함수나 메서드의 인자로 넘길 수 있으며 함수나 메서드에서 리턴을 할 수 있는 것을 말합니다. 
그리고 자바스크립트의 함수는 일급함수입니다. 일급함수란 아무때나 선언이 가능하고 익명으로 선언이 가능하고 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있어서 위의 _call 함수처럼 인자를 받아 함수의 실행시점을 자유자재로 놓을 수 있습니다. 

#### 2.3 함수를 리턴하는 함수  
```js
//ES6
const a = val => () => val; 
//ES5
function a(val) {
  return function() {
    return val;
  }
}

var a_lazy = a(12010);
a_lazy();
// 12010 
```
위의 코드는 a라는 함수가 함수를 리턴하고 다시 a_lazy에다가 함수를 할당하는 코드입니다. 이렇게 함수를 안에서 다시 리턴하면 실행시점을 지연시킬 수 있습니다.  

#### 3. 커링
여러개의 파라미터 보다 적은 수의 파라미터를 받아 누락된 파라미터를 인자로 받습니다. 함수 하나가 n개의 인자를 받는 과정을 n개의 함수로 쪼개서 각각의 인자를 받고 그 인자가 다 채워지면 그때서야 함수를 실행하게 하는 것을 말합니다. 이렇게 **지연되는실행**이 가능한 이유는 내부함수가 외부함수의 컨텍스트가 소멸이 되도 외부함수의 실행환경을 참조할 수 있는 클로저 덕분입니다. 내부함수는 파라미터가 완성될 때까지 실행시점을 미룰 수 있습니다. 이는 `Point-free`로 로직을 구현하는데도 효과적입니다.


#### 3.1 ramda를 이용한 예 
```js
const R = require('ramda')  
const a = R.add(1)
const b = a(2)
console.log(b) //3 
``` 
함수형 프로그래밍을 도와주는 Ramda.js 라이브러리를 이용한 예입니다. R.add의 경우 처음에 인자 1을 넣고 나중에 2를 넣어 인자가 완성이 되었을 때 **실행**을 할 수 있게 합니다.  

#### 3.2 ramda를 이용한 예 
```js
const addFourNumbers = (a, b, c, d) => a + b + c + d;

const curriedAddFourNumbers = R.curry(addFourNumbers);
const f = curriedAddFourNumbers(1, 2);
const g = f(3);
g(4); //=> 10 
```
위 코드처럼 어떠한 함수를 만들고 R.curry에 담는다면 그 함수를 토대로 만들어지는 커링함수가 완성됩니다.  

#### 3.3 커스텀커링
#### ES6 커링
```js
const k_curry = fn => a => b => fn(a, b); 
const f = k_curry((a, b) => a + b); 
const f_c = f(1);
const ret = f_c(2);
console.log(ret)
```
그렇다면 커링을 한번 만들어보겠습니다. 
`k_curry`라는 2개의 인자를 받을 수 있는 커리함수를 만들었고 그 커리로 `f`를 래핑, 감싸줍니다. 이제 f는 커링이 가능한 **더하기함수**가 됩니다. 
저런식으로 평가시점을 늦출 수 있습니다. ES6버전은 위와 같고 ES5버전은 아래와 같습니다. 

#### ES5 커링
```js
var k_curry = function(fn){
    return function(a){
        return function(b){
            return fn(a, b);
        }
    }
}
var f = k_curry(function(a, b){
    return a + b;
}); 
var f_c = f(1);
var ret = f_c(2);
console.log(ret)
``` 

또한 커링을 하게 되면 코드가 간결해집니다. 커링을 한다는 것은 `f(a)(b)`이런식으로 인자를 넣는다는 것인데 이를 이용하면 함수합성시 pipe 라인에서의 코드를 조금 더 간결하게 만들 수 있습니다. 이를 통해 **표현력**을 증가시킬 수 있습니다.   

```js
const {map, pipe, filter} = require('fxjs') 

//pipe를 사용하기 전 - 함수합성이 복잡합니다.
const f_1 = map(a => a + 1); 
const f_2 = filter(a => a % 2); 
const ret = f_2(f_1([1, 2, 3, 4]))
console.log(ret) // 3, 5 
```
먼저 pipe를 사용하지 않고 함수합성을 한 예입니다. f_1, f_2라는 순서로 합성이 이뤄지지만 보기도 힘듭니다. 이 때 파이프라인을 쓰면 간답힙니다. 또한 fxjs에서 제공하는 map과 filter는 커링이 되어있기 때문에 파이프라인에 넣을 때 간결하게 로직을 구축할 수 있습니다. 
```js
const f_pipe = pipe(
    map(a => a + 1), 
    filter(a => a % 2)
)
const _ret = f_pipe([1, 2, 3, 4])  
console.log(_ret) // 3, 5
```
pipe를 쓰니 좀 더 보기 좋아졌죠? 바로 이것입니다. 

#### fxjs내 map 함수
```js
module.exports = curry(function map(f, iter) {
  return takeAll(mapLazy(f, iter));
});
```


커링이 들어간 pipe의 예입니다. 함수에 인자를 넣을 필요없이 깔끔하게 로직을 구현할 수 있습니다. 
 
참고로 `fx.js`의 커리는 이런식으로 구현되어있습니다. 
`..._`로 **남은**인자를 받아서 만약에 남은 인자가 없다면 함수를 실행합니다. 즉, 인자가 **완성** 되었다면 실행하게끔 되어있습니다. 
```js
export const curry = f => (a, ..._) => _.length ? f(a, ..._) : (..._) => f(a, ..._);
```
 


#### 4. 함수 합성  
```js
const R = require('ramda') 
R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
```
합성시키는 것은 compose와 pipe가 있습니다. R.compose는 위의 코드처럼 오른쪽에서 왼쪽으로 로직이 흘러갑니다.
```js
const f = R.pipe(Math.pow, R.negate, R.inc); 
f(3, 4); // -(3^4) + 1
```
pipe는 왼쪽에서 오른쪽으로 흘러가며 커링이 적용된 덕에 `point-free` 형으로 짤 수가 있습니다. 보통 저는 `pipe`를 씁니다.

#### 5. 파괴적인 함수를 쓰지 않습니다. 
```js
const a = [1, 2, 3, 4, 5]  
let b = a.slice(1)
console.log(a, b)  
b = a.splice(1)
console.log(a, b)
/*
[ 1, 2, 3, 4, 5 ] [ 2, 3, 4, 5 ]
[ 1 ] [ 2, 3, 4, 5 ]
*/
```   
splice는 배열을 파괴합니다. 
하지만 slice는 파괴를 하지 않고 1을 제외한 나머지 배열 요소들을 추출해낼 수 있습니다. 
되도록 payload 또는 원본 요소를 파괴하지 않는 함수를 써야 합니다. 
#### 6. Point -free 
```js
const map = fn => list => list.map(fn); 
const add = x => y => x + y; 
const incrementAll = numbers => map(add(1))(numbers);
/* function with point-free */
const incrementAllWithPointFree = map(add(1));
var a = incrementAll([1, 2, 3]); // [2, 3, 4]
var b = incrementAllWithPointFree([1, 2, 3]); // [2, 3, 4]
console.log(a, b)
```
아까 말했던 Point-free, 무인수 프로그래밍입니다. 인자를 신경쓰지 않고 구현하는 것을 뜻합니다. 
커링이 적용된다면 인자를 집어넣지 않아도 됨을 뜻합니다.  

#### 7. 모나드
어떠한 값의 결과가 불확실하게 2가지형태 이상으로 나타날 수 있습니다. 이럴 때 컨테이너로 래핑하여 안전하게 연산을 하는 것을 말합니다. 함수형프로그래밍에서는 참조투명성, 입력과 출력이 동일하게 1 : 1 매칭이 되어야 하기 때문에 `try catch`를 쓰게 되면 로직을 담고 있는 컨테이너의 벨트의 라인이 2개로 분리되어 투명성을 잃게 되기 때문입니다. (물론 `try catch`를 써서 애러처리를 할 수도 있습니다만 함수형 프로그래밍에서 써야한다. 안써야 한다. 라고 하는 주장이 나눠집니다. 저는 쓸 때도 있고 안 쓸 떄도 있습니다.) 

`ramda-fantasy`의 `Either`라는 컨테이너박스에 담아서 
1. Right메소드로 성공처리로직을 
2. Left메소드로 애러처리로직을 구현해도 되고 Promise를 이용해도 됩니다. 

Promise 는 future Monad라고 합니다. 이런 형태의 값이라는 것을 설정해 놓고 비동기적인 상황에서 성공과 실패를 값으로 다루는 하나의 컨테이너 박스입니다. 콜백으로 넘기는 방식은 컨텍스트를 넘겨서 로직을 수행하고 Promise는 그것들을 하나의 "값"으로 받아서 로직을 수행합니다.

 > 콜백 : 어떤 함수가 어떠한 시점에서 다시 호출 되는 것

#### 7.1 Promise를 이용한 예
```js
const g = JSON.parse;
const f = k => k.temp; 
const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f)
const log = x => console.log(x)

fg('{"temp":36.5}').catch(_ => 'JSON PARSE is not working').then(log)
``` 

`{"temp":36.5}`라는 문자열을 g를 이용해서 JSON Object로 변환합니다. 이 때 Promise를 이용해서 오류가 있다면 then(f)가 아닌 catch로 넘어가게 합니다. 
#### 7.2 Promise를 이용한 예
```js
const log = console.log
const users = [{name : '큰돌'}, {name : '제호'}, {name : '우람'}, {name : '다빈'}] 
const getUserByName = (name) => users.find(u => u.name === name) || Promise.reject("객체에 없습니다.")
const g = getUserByName;
const f = ({name}) => `${name}이가 춤을 춥니다.`
const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f) 
fg("큰돌1").catch(_ => _).then(log)
//객체에 없습니다.

fg("큰돌").catch(_ => _).then(log)
// 큰돌이가 춤을 춥니다.

/*
큰돌이가 춤을 춥니다.
객체에 없습니다.
*/
```
아까 보았던 코드와 같은 구조이지만 다른 예제입니다. 

#### 8. 제너레이터와 이터레이터
제너레이터를 써서 순차적인 로직 구현과 지연효과를 쉽게 설계할 수 있습니다. 
```js
function *map(f, list){
    for(const a of list){
        yield f(a)
    }
}
``` 
list라는 배열의 요소 a를 대상으로 f를 순차적으로 실행(평가)하는 함수 map입니다. 이렇게 함수에 *를 붙으면 제너레이터가 되는데 제너레이터는 **이터레이터**를 손쉽게 만들 수 있으며 **코루틴**이 가능합니다.
#### 8.1 제너레이터의 코루틴
코루틴이란 뭘까요?
1. yeild문이 발동하면 스택프레임에 복사를 하고 콜스택에서는 제거를 합니다.
2. 그리고 next()문이 발동하면 스택프레임을 복원하여 실행해서 진입점을 개발자가 원하는 데로 실행이 가능하게 설계할 수 있습니다. 
 
 > 코루틴 : 진입점을 개발자가 원하는 데로 실행이 가능하게 설계하는 것 

이 코루틴 덕에 이터레이러를 이용해서 **지연평가**라는 것이 가능합니다.

 > 지연평가를 하면 range함수를 만드는데서 성능에서의 장점 로직구현이 좀 더 효율적이게 됩니다. 왜냐하면 파이프라인에서 제너레이터로 연결된 함수들이 합쳐지는 듯한 효과를 내기 때문입니다. 
 
#### 8.2 이터러블/이터레이터 프로토콜
 - 이터러블: 이터레이터를 리턴하는 `[Symbol.iterator]()`라는  키를 가진 값이자 반복할 수 있는 순차적인 객체
 - 이터레이터: `{ value, done }` 객체를 리턴하는 `next()` 를 가진 값
 - 이터러블/이터레이터 프로토콜: 이터러블을 `for...of`, `전개 연산자` 등과 함께 동작하도록한 규약

`...` 전개연산자는 적용되는 공간에서의 인수들(배열, key-value)에 따라 그 공간에 맞는 인수 또는 요소로 확장할 수 있게 합니다. 전개연산자는 이렇게 활용할 수도 있습니다. 예) `const [head, ...tail] = f();`

#### 8.3 제너레이터와 이터러블
제너레이터는 커스텀형 이터레이터로 함수자체가 이터러블을 생성합니다.
 
```js
const log = console.log
function* gen() {
    yield 10;
    if (false) yield 20;
    yield 30;
    return 90; 
}
let iter = gen();
log(iter.next())
log(iter.next())
log(iter.next())
/*
{ value: 10, done: false }
{ value: 30, done: false }
{ value: 90, done: true }
*/
 
log([...iter]); //[10, 30]

for (const a of iter) {
    log(a); //10, 30
} 
```
참고로 제너레이터는 리턴값을 가질 수있습니다. 그러나 순회할 때 대상에는 포함이 안되지만 `next()`메서드로 계속해서 호출하게 되면 `{value : 리턴값, done : true}`를 반환되게 하는 종결값으로 값이 끝내지게 됩니다.  
 
```js
const log = a => console.log(a)
function* gen() {
    yield 10;
    if (false) yield 20;
    yield 30;
    return 90; 
}
let iter = gen();
//log([...iter]); 
log(iter.next())
log(iter.next()) 
log(iter.next()) 
/*
{ value: 10, done: false }
{ value: 30, done: false }
{ value: 90, done: true }
*/
```

#### 8.4 객체로 만드는 제너레이터 
`[Symbol.iterator]()`라는 키를 넣어서 이터러블한 객체를 커스텀하게 만들 수 있습니다.
```js
var myIterable = {
    *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
    }
}
``` 

#### 9. 클로저 
클로저는 독특한 함수체제를 멋지게 활용할 수 있습니다. 
 - 프라이빗 변수를 모방 
 - 가상의 블록 스코프 변수를 생성  

 > 클로저 : 외부함수의 실행컨텍스트가 소멸해도 `[[scope]]`프로퍼티가 가리키는 **외부함수의 실행환경은 소멸하지 않고 참조할 수 있는 것을 말합니다.** 스코프체인이 형성될 때 `[[scope]]`로 참조할 수 있는데 이를 이용해 참조할 수 있는 것을 말합니다.

#### 9.1 클로저의 예
```js
var test = (function(){
    var count = 0; 
    return {
        increase: function(){
            count++;
        },
        decrease: function(){
            count--;
        },
        getValue: function(){
            console.log(count);
        }
    }  
})();
test.increase();
test.increase();
test.increase();
test.getValue();

var add = (function () {
    var counter = 0;
    return function () {
        counter += 1; 
        console.log(counter) 
    }
})();

add();
add();
add(); //1 2 3

//D3js에서의 예
function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}
``` 
이렇게 private 변수를 흉내내는 것 말고 어떤 시점에서의 시점을 이어가는 데도 쓰입니다. 이렇게 함수형 프로그래밍의 주된 9개의 특징을 살펴 보았습니다. 

### 3.1.2 함수형프로그래밍의 응용예제  
그렇다면 좀 더 응용한 예제를 살펴보도록 하겠습니다. 
#### 1. 배열안에서의 비동기 순서로직
아래를 그저 map이라는 함수를 써서 하면 순차적인 비동기 로직이 아니라 pending 6개가 찍혔다가 동시에 실행이 될 것입니다.
유인동이라는 개발자님이 만든 `partial.js`라는 라이브러리를 사용해보는 것이 어떨까요? 쉽게 비동기 순서 로직을 짤 수 있습니다.
```js
var _ = require('partial-js');
const delay = (val)=>{
    return new Promise((resolve, reject)=>{
        setTimeout(() => {
            resolve(val)
        }, 1000); 
    })
}
async function test3() {
  const list = [1, 3, 5, 6, 7, 9];
  console.log(list)
  return _.map(list, async function(val, i) {
    console.log(val, i); // 1초씩 순차적으로 실행됨
    return await delay(val * 10); // 1초씩 순차적으로 실행되고 정상적으로 결과를 꺼냄
  });
} 
test3().then((result)=> {
  console.log(result);
  // [10, 30, 50, 60, 70, 90]
});
``` 

#### 2. reduce를 통한 집계
이외에도 reduce를 통해 함수형 프로그래밍을 통하면 쉽게 집계된 데이타를 뽑아낼 수 있습니다. 아래의 예제는 20대 10대 별로 나누어서 count와 나이의 합계를 계산합니다.
```js
const _ = require('lodash') 
const users = [
    { id: 1, name: "홍철", age: 22 },
    { id: 2, name: "서영", age: 25 },
    { id: 3, name: "종선", age: 31 },
    { id: 4, name: "제호", age: 27 }, 
  ];

const a = _.reduce(users, (info, user)=> {
    const group = user.age - user.age % 10;
    info.count[group] = (info.count[group] || 0) + 1;
    info.total[group] = (info.total[group] || 0) + user.age;
    return info;
  }, { count: {}, total: {} }); 

console.log(a)

``` 

함수형 프로그래밍을 설명하면서 ramda, partial, lodash, fx.js를 이용한 예제를 들었는데요. 결과적으로 유인동개발자님이 만든 fx.js를 사용하는 것이 좋습니다. 유인동개발자님은 우리나라에서 함수형 프로그래밍을 제일 잘하는 사람 중 하나이며 lodash, ramda의 장점을 섞어 만든 partial.js의 장본인입니다. fx.js는 partial.js의 다음 버전 라이브러리입니다. 
당연히 사용하기도 편리하고 성능도 좋습니다. 앞으로 이어나갈 모든 코드들에는 fx.js가 포함될 예정입니다. 
함수형 프로그래밍을 조금 더 알고 싶다면 [유인동의 함수형프로그래밍](https://www.inflearn.com/course/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/#) 을 보기를 권장드립니다.  

### 3.2 자바스크립트 최적화 
우리는 하나의 패러다임 중 제가 추천하는 함수형프로그래밍을 살펴보았습니다. 그렇다면 자바스크립트의 최적화는 어떻게 진행이 될까요? 먼저 로직을 구성하는데 있어 어떤 것들을 맞추는 것이 중요합니다. 제가 생각하는 것들은 이러한 것이며 개인취향이 강하기 때문에 이런 것들은 팀원들과 상의 후 결정하면 됩니다. 이러한 것들이 미리 정해져 있는 eslint를 써서 정해도 됩니다.  

1. 함수, 변수명은 카멜표기법을 사용합니다. 팟홀표기법(underbar 표기법)도 있지만 저는 이걸 추천합니다.  
2. 간단하더라고 if { 중괄호를 사용해야 한다. 
3. 문자열은 무조건 템플릿문자열을 사용해야 합니다.
4. 한 컴포넌트, 모듈의 길이는 200줄 이하로 작성되어야 한다.
5. 배열순회의 경우 for-in 루프를 쓰지 않습니다. (객체 속성순회일경우에는 씁니다.) 왜냐하면 인스턴스, 프로토타입 체인까지 검색하므로 느립니다.
6. 정규표현식은 간단하게 씁니다. 예를 들어 ble|blue 대신 blu?e를 씁니다.
7. 세미콜론은 쓰거나 쓰지 않습니다. D3.js의 경우 쓰고, nightmare.js에서는 쓰지 않습니다. 

### 3.2.1 함수선택, parseInt와 ~~의 성능비교
예를 들어 실수형을 정수형으로 만드는 연산이 있습니다. 자바스크립트에서 대표적인 함수로는 parseInt를 뽑을 수 있습니다. 하지만 ~~이라는 비트연산자를 통하면 좀 더 빠르게 구할 수 있습니다. ~~는 ~라는 비트를 전체를 뒤집는 비트연산자를 한 번 더 한 것이며 이를 이용하면 더 빠르게 됩니다. 

[JSMATCH](http://jindo.dev.naver.com/jsMatch/index.html)라는 네이버에서 만든 비교사이트를 통해 비교해봅시다. 

#### A. parseInt
```js
for(let i = 0; i < 100000; i++){
	let a = 123.456789
	b = parseInt(a)
} 
```

#### B. ~~
```js
for(let i = 0; i < 100000; i++){
	let a = 123.456789
	b = ~~(a)
} 
```

![비교결과](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_parseInt.PNG)

`~~`가 조금 더 빠릅니다.

 > ~ = -(n + 1), 비트연산자를 통해 적용한 겨로가는 부호 있는 32비트 정수로 반환됩니다.  - ECMA5 SPEC (그렇기 때문에 2 ^ 31 + 1 이상은 쓸 수 없습니다.)


이러한 비트 연산자는 실제로도 많이 쓰입니다. 유명한 오픈소스인 D3.js의 184번째 줄(5.9.4버전)을 보면`n = Math.max(0, Math.ceil((stop - start) / step)) | 0,`이라는 코드가 있습니다. `| 0` 은 제가 ~~과 똑같은 역할을 하는 비트연산자 입니다. 실제로 ~~보다는 `| 0`이 더 성능이 좋습니다. 하지만 그렇게는 차이가 많이 나지 않으니 ~~를 써도 무방합니다. 

이외에도 indexOf보다는 includes가 성능에 좋으니 includes를 써야 하고 불필요한 객체 선언을 없애서 메모리소모를 줄여서 최적화 시키는 방법이 있습니다.  

### 3.2.2 함수선택, 객체를 복사하는 방법의 선택 
자바스크립트에서 객체를 할당하게 되면 주소값을 참조하게 되는 얕은 복사가 일어납니다. 그렇기 때문에 그 이후에 그 값을 변경하면 원래의 객체가 변화게 되어 사이드 이펙트가 일어날 수 있는 상황에 접하게 됩니다. 그래서 우리는 deepCopy라는 깊은 복사를 해야 하는데 객체의 깊이에 따라 좀 더 효율적인 방법이 있습니다.  

#### 스프레드 연산자와 Object.assign
아래의 2가지 방법은 JSON객체의 깊이가 1일 때까지 유효합니다.
```js
const a ={"b" : 1}
let b = {...a}
let c = Object.assign({}, a);
c.b = 3;
b.b = 3;
console.log(a)
//a는 바뀌지 않는다
```
하지만 아래처럼 깊이가 2이상일 경우 다시 얕은 복사처럼 바뀌게 됩니다.
```js
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
}
let b = {...a}
let c = Object.assign({}, a);
c.c.d = 3;
console.log(a)
//a가 바뀌게 된다. 
``` 
그렇다면 어떻게 깊은 복사를 해야 할까요?

#### 재귀함수
재귀함수 copy가 재귀적으로 작동하면서 해당 value가 object임을 검사함과 동시에 null이 아님을 검사해서 객체가 만약에 또 있다면 또다시 재귀함수를 실행시키는 형식입니다.
```js
const copy = o =>{ 
    let out = {}; 
    let value, key;  
    for(key in o){
        value = o[key];
        out[key] = (typeof value === "object" && value != null) ? copy(value) : value;
    }
    return out; 
}
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
} 
let b = copy(a)
b.c.d = 4; 
console.log(a)
```  
#### JSON.parse와 JSON.stringify
이렇게 아예 문자열로 만든 다음에 다시 객체형태로 반환하는 방법이 있습니다. 
```js
const a ={
    "b" : 1, 
    "c" : {
        "d" : 2
    }
} 
let b = JSON.parse(JSON.stringify(a))
b.c.d = 4; 
console.log(a)
``` 

그렇다면 스프레드 연산자와 `Object.assign`, 재귀함수 copy와 `JSON.parse(JSON.stringify)` 중에 뭘 써야 할까요? 그것은 프로젝트 때의 객체의 깊이와 객체안에 뭐가 담기는지 파악하고 성능테스트를 진행한 후 결정하면 됩니다. 

  > 필자는 프로젝트를 진행할 때 JSmatch를 통해 성능테스트를 했고 객체에 따라 JSON.parse가 더 좋을 때가 있고 copy가 더 좋을 때도 있었습니다.
 
### 3.2.3 서버요청최적화 - 메모이제이션과 서버요청최소화 
예를 들어 10mb짜리 API요청 10개와 100mb짜리 API요청 1개가 있습니다. 무엇이 빠를까요? HTTP2는 몰라도 HTTP에서는 전자가 더 느립니다. 서버요청은 최대한 줄여야 하며 중복되는 요청의 경우는 메모이제이션을 통해 재사용해야 합니다. 메모이제이션은 후에 실시간 데이터 프로젝트를 하며 살펴보도록 하겠습니다. 

### 3.2.4 UX향상 : LAZY load와 이미지크기 축소   
흔히들 UX를 향상시키자고 합니다. UX를 향상시킨다는 것은 홈페이지를 눌렀을 때 빠르게 뜨는 것이 포함이 됩니다. 여러가지가 있지만 이것은 제일 중요한 요소 중 하나입니다. 사용자가 처음 페이지를 켰을 때 필요한 것은 그렇게 많지 않습니다. 

**지금 사용자가 보고 있는 영역의 이미지만**이 필요할 뿐이고 그 아래의 이미지는 필요하지 않습니다. 그렇기 때문에 사용자가 보고 있는 영역의 이미지만 로드를 하면 될뿐이죠. 이렇게 추후 나중에 게으르게 이미지를 로드하는 것을  LAZY load라고 합니다. 

그렇다면 LAZY load는 어떻게 구현할까요? 
먼저 심플한 서버를 구축합니다. 
#### MEVN/3장/server.js 
```js
const express = require('express');
const path = require('path')
const app = express();
const _path = path.join(__dirname, './dist') 
app.use('/', express.static(_path)) 
app.listen(12010, ()=> {
  console.log('lazy 이미지서버 : 12010시작 http://127.0.0.1:12010');
});
```
전에 구축했던 서버랑 비슷합니다. dist라는 폴더를 사용자에게 제공하는 서버입니다. 

 > Q. 여기서 dist 폴더가 아닌 public이라는 폴더를 제공한다면 어떤 코드를 수정해야 할까요?

#### MEVN/3장/dist/index.html
```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./img_lazy.js"></script>

    <style> 
    ul{
        list-style-type: none; 
    }
    .cardWrap > li { 
        height: 500px; 
        margin-bottom: 100px;
        text-align: center;
    } 
    .cardWrap img{
        height: 100%;   
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    }
    </style>
</head>
<body> 
    <ul class="cardWrap">
        <li><img class="lazy" data-src="./img/1.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/2.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/3.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/4.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/5.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/6.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/7.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/8.jpg" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/9.gif" src="./img/substitution.jpg"alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/10.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/11.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/12.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/13.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/14.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li>
        <li><img class="lazy" data-src="./img/15.jpg" src="./img/substitution.jpg" alt="트와이스모모"></li> 
    </ul>
     
</body>
</html>
``` 
html을 만듭니다. 트와이스 모모를 좋아하기 때문에 모모이미지 카드들로 만들어진 html파일입니다. 
![lazy_load전](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy.PNG)

정말 이쁜 예제 입니다. 하지만 15장의 고화질 이미지를 한꺼번에 로드하는 것은 부하가 큽니다. 자 이제 lazyload를 구현해봅시다. 

그냥 `document.querySelectorAll("img.lazy")`를 하면 유사배열인 NodeList로 배열의 메소드인 filter나 forEach를 쓰지 못합니다. 따라서 배열로 만들어 주어야 하므로 빈배열에 slice로 얕은복사(shallow copy)를 하고 call을 통해 인자로 `document.querySelectorAll("img.lazy")` 넣으면 유사배열인 NodeList를 진짜배열로 만들 수 있습니다.

 200초마다 확인을 하면서 지금 내가 보는 화면을 `window.innerHeight`를 통해 파악해서 만약 이게 지금 lazyImage보다 더 멀리 있는 위치라면 lazy라는 클래스를 지우고 원래 이미지에 src에 할당합니다. dataset은 html의 `data-src="./img/15.jpg"`의 data-src를 말합니다. 이를 dataset.src로 접근을 할 수 있습니다. 

> slice는 얕은 복사로 빈배열이 아닌 객체가 들어가 있는 배열을 복사하면 원본 객체가 수정이 되면 복사한 객체도 수정이 됩니다. 빈배열을 복사했기 때문에 얕은 복사라도 상관이 없습니다. 단지 배열의 prototype 메소드인 filter 등을 사용할 수 있기 때문에 저렇게 구현했습니다. 

> 그렇다면 data-큰돌은 data.큰돌로 접근이 가능하겠죠? 여러모로 응용이 가능한 dataset입니다. 

그리고 할 때마다 lazyImages를 갱신시킵니다. 이미 지웠다면 신경쓸 필요가 없겠죠? 그 이후 만약 길이가 없다면, 다 완료가 되었다면 removeEventListener로 이벤트를 지웁니다. 이렇게 하면 스크롤 할 때 흐릿한 이미지가 분명한 트와이스 이미지로 바뀌면서 구현이 되고, 처음에 15장의 이미지를 동시에 받지 않고 볼 때마다 받는 lazy-load가 완성이 됩니다. 
이 예제는 저화질의 blur이미지 한장이 기본적으로 받아지지만, 각각 해당하는 이미지의 **저화질**이미지를 만들어서 구현하는 것이 일반적입니다. 15장의 이미지를 모두 로드한다쳐도 저화질이기때문에 데이타소모가 심하지 않습니다. 

```js
document.addEventListener("DOMContentLoaded", function() {
    let lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));  
    let active = false;   
    const lazyLoad = function() {   
      if (active === false) {
        active = true; 
        setTimeout(()=> { 
          lazyImages = lazyImages.map((lazyImage) => {  
            if ((lazyImage.getBoundingClientRect().top <= window.innerHeight && lazyImage.getBoundingClientRect().bottom >= 0) && window.getComputedStyle(lazyImage).display !== "none") { 
              lazyImage.src = lazyImage.dataset.src;  
              lazyImage.classList.remove("lazy");    
              return null;
            }else return lazyImage;
          }).filter(image => image);
          if (!lazyImages.length) {
            document.removeEventListener("scroll", lazyLoad);
            window.removeEventListener("resize", lazyLoad);
            window.removeEventListener("orientationchange", lazyLoad);
          }else active = false;
        }, 200);
      }
    }; 
    document.addEventListener("scroll", lazyLoad);
    window.addEventListener("resize", lazyLoad);
    window.addEventListener("orientationchange", lazyLoad);
  });
``` 

자 완성한 모습입니다. 
스크롤 하기전에는 blur 모모 이미지가 뜹니다.
![스크롤하기전](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy1.PNG)

그러나 스크롤 한 후에는 실제 모모 이미지가 뜹니다. 완성입니다!
![스크롤하기후](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/3_img_lazy2.PNG) 

라이브러리로는 lozad.js / yall.js 가 있습니다. 모두 똑같은 원리입니다. 보지 않는다면 placholder 이미지 또는 blur이미지를 셋팅하고 사용자가 본다면 실제로 보는 이미지를 놓으면 됩니다. 
이외에도 template를 사용하는 방법이 있지만 권장하지 않습니다. 

또한, 애초에 이미지의 용량을 줄이는 것도 중요합니다. 이미지 용량을 줄이는 사이트로는 https://compressjpeg.com/ 와 https://tinypng.com/ 를 추천합니다. 


 > 이 예제에서는 별도의 서버를 두었지만 굳이 서버를 두지 않고 index.html만 눌러도 잘 작동이 됩니다. 보다 실제 환경적인 예제를 위해 서버를 구축했습니다.

### 3.3 CSS 최적화 
자 이제 코드를 어떻게 짜는 지를 알았다면 스타일을 어떻게 짜는 것이 관건입니다. CSS를 팀원들끼리 어떻게 짜는지 맞추는게 추후 아름다운 코드를 위한 지름길입니다. 꼭 이렇게 안 맞춰도 됩니다. 하나의 예시입니다. 이런 식으로 프로젝트를 진행하기전 어떻게 코드를 짤 것인지를 맞춰야 합니다.

#### 1. 0은 px을 쓰지 않는다.
```css
article{
    margin:0;
    padding:0;
}
```

#### 2. short hand를 사용한다. 
```css
/* x */
article{
    margin-top:10px;
    margin-bottom:10px;
} 
/* o */
article{
    margin:10px 0px; 
} 
```

#### 3. CSS SPRITE이미지를 쓰자
서버요청을 줄이기 위해 반복되는 이미지는 한장의 이미지를 요청하고 background속성을 이용해서 이미지를 나타낸다.  

#### 4. 하위 선택자는 좀 더 깔끔하게 한다.  
`library book article`보다는 `library article`이 좋습니다. 

#### 5. repaint 와 reflow를 최소화 한다 
애니메이션을 할 때는  transform, filter, opacity를 사용해야 합니다. 
그냥 top, left가 움직이게끔 한다면 repaint와 reflow가 일어나는데 저 속성을 걸게 되면 GPU에 업로드되어 
repaint와 reflow가 일어나지 않습니다. 

 > 화면이 구성될 때 랜더링레이어와 그래픽레이어로 분리되며 구성이 되는데 렌더링레이어에 포함이 되면 reflow, repaint가 일어나며 그래픽레이어에 포함된다면 그것들이 안일어나며 GPU하드웨어 가속이 적용됩니다.  

예를 들어, 
```css
@keyframes swim {
  from {
    top:0px;
  }
  to {
    top:200px;
  }
}
```
이것 보다는 `transform`을이용해서 y축을 움직여야 합니다. 
또한 이걸 응용해서 어떠한 요소를 `style="transform:translateZ(0);"`를 통해 스타일에 CSS 3D속성인 translateZ를 걸게 되면 해당요소는 하드웨어 가속대상이 되게 되며 그 대상이 움직이거나 그럴 때 repaint와 reflow가 일어나지 않아 효율적이게 됩니다. 

 > 그러나 이렇게 GPU 하드웨어 가속에 걸게 되면 감빡거릴 수도 있으며, 성능이 낮은 기기에서는 성능저하를 가져올 수 있습니다.따라서 하드웨어 가속을 적용하는 요소의 크기를 줄이고 화면에서 몇개 단위로 구성하는 것이 좋으며 기기에 따라 선별적인 하드웨어 가속을 하게끔 해야 합니다.

#### 6. 스타일을 재사용한다. 
제일 중요합니다. 많은 컴포넌트들 사이에서 재사용할 클래스를 미리 지정해 놓고 사용하는 것이 중요합니다. 예를 들어 A컴포넌트에서 `display : flex`를 사용하는데 B 컴포넌트에서도 `display : flex`를 사용한다면 좋지 않습니다. 부모 컴포넌트에서  `display : flex`를 정의한 후 재사용하는 것이 좋습니다. 

이렇게 함수형프로그래밍 패러다임부터 시작해서 어떻게 코드를 짜는지 자바스크립트, css까지 살펴보았습니다. 이제는 실전입니다! 이제 실시간 데이터 시각화 프로그램을 만들고 미술작가소개플랫폼을 만들 것입니다.
  

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_4장.jpg)
## 4. 실시간 데이터시각화사이트제작  
이제 드디어 실시간 데이터시각화사이트를 제작할 것입니다. 데이터를 시각화를 하기 위해서는 시각화 라이브러리가 필요합니다. D3.js, chart.js 등 많은 라이브러리를 비교하교 장점과 단점을 비교할 것입니다. 그 후 D3.js로 간단하게 사용법을 알아보고 지도, 증가하는 숫자모듈을 만들고 실시간통신과 차트모듈을 만들어보겠습니다.  

실시간통신을 위해서는 websocket사용은 필수입니다. 하지만 오래된 브라우저에서는 웹소켓자체가 구동되지 않습니다. 이를 위한 polling이라는 기법또한 알아볼 것입니다. 그 후 실제로 구현해보고 차트컴포넌트와 전에 만든 증가하는 숫자 모듈을 활용해 하드웨어 모니터링 시스템까지 완벽하게 알아보겠습니다.

### 4.1 시각화 라이브러리 D3.js
어떠한 데이터를 시각화하는 것은 중요한 일입니다. 같은 데이타라도 다르게 보여줄 수 있으며 효과적으로 내가 주장하는 바를 강하게 나타낼 수 있습니다.  
![콜레라지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2375B83653D9EED42D.jpeg)   
실제로 데이타 시각화는 사람을 살리는 일도 합니다. 

빅토리아 여왕 시대의 의사인 존스노우는 콜레라가 수인성 전염병이라는 것을 파악하기 위해 펌프가 있는 지역들을 위처럼 시각화 했고 이를 통해 콜레라가 펌프와 상관관계여부를 파악하고 규칙성을 찾아내었습니다.  

이러한 시각화를 도와주는 좋은 도구인 시각화라이브러리중 하나인 D3.js를 소개합니다.
D3를 사용하면 임의의 데이터를 DOM (Document Object Model)에 바인딩 한 다음 문서에 데이터 기반 변환을 적용 할 수 있습니다. 예를 들어 D3을 사용하여 숫자로 이루어진 배열에서 HTML 테이블을 생성 할 수있고 바차트, 선차트 등을 만들 수 있습니다.  이외에도 지도, flow, treemap, pie chart, 상호작용, 애니메이션 등 무궁무진하게 정말 많은 시각화적인 요소들을 만들 수 있습니다.
매우 작은 용량의 라이브러리로 정말 작은 부분 하나하나 세세하게 커스터마이징이 가능한 장점을 가지고 있습니다. 

#### 4.1.1 D3와 다른 시각화라이브러리 비교
무언가 프로젝트를 하기 위해 Stack을 설정할 때 다른 라이브러리와의 비교는 필수입니다. 그렇다면 현존하는 라이브러리와 D3.js를 비교해보겠습니다. 

2019년 7월 28일 기준입니다. 각 라이브러리의 최신버전을 통해 비교했습니다.

| 라이브러리 | 용량(min기준) | 러닝커브 | 활용도 |
|:--------|:--------| 
| chart.js	| 153kb | 쉬움 | 보통 |
| echarts.js | 729kb | 매우쉬움 | 보통 |
| three.js	| 562kb | 보통 | 높음 | 
| D3.js	| 237kb | 보통 | 매우높음 |

#### chart.js 버전 : 2.8.0
chart.js는 영역차트, 바차트, pie차트 등 차트에 국한 되어있습니다. 단순히 차트만 구현한다면 chart.js는 좋은 선택입니다. 

라인차트를 구현하는데 이정도의 코드만 있으면 됩니다.
```js
var ctx = document.getElementById('myChart').getContext('2d');
var chart = new Chart(ctx, { 
    type: 'line', 
    data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [{
            label: 'category', 
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }]
    }, 
    options: {}
}); 
```
#### echarts.js 버전 : 4.2.1
echarts.js는 사용하기가 매우 쉽습니다. 
라인차트를 구현하는데 이정도의 코드만 있으면 됩니다. 또한, geomap, Radar Chart, Heatmap, Graph, Treemap, flow 등 여러가지를 구현할 수 있습니다. 필자도 토이 프로젝트를 할 때 빠르게 차트를 구현하기 위해 echarts를 구현할 정도로 정말 쉽고 빠르게 만들 수 있습니다. 써보면 아시겠지만 chart.js보다 쉽습니다. 하지만 용량이 상당히 거대하기 때문에 큰 프로젝트에서는 추천하지 않습니다.
```js
option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};  
var myChart = echarts.init(document.getElementById("container"));
myChart.setOption(option, true);  
```

#### three.js 버전 : 0.106.2
three.js는 가장 유명한 자바스크립트 3D 라이브러리 중 하나입니다. 무겁기도 하고 하드웨어의 성능을 많이 잡아 먹기 때문에 모바일에서 이를 활용한 앱을 켰을 때 버벅거리는 증상이 나타나기도 합니다. 정말 많은 3D 차트 등을 구현할 수 있습니다. 자바스크리브로 3D를 구현하자면 필수적인 라이브러리입니다. 

#### D3.js 버전 : 5.9.7
D3.js는 3D는 아니지만 2D로 구현이 가능한 모든 시각화적인 것들을 구현할 수 있습니다. 차트, 맵은 기본이며 중력도 구현이 가능하며 워드클라우드, 플로우, 못하는 것이 없습니다. 하지만 D3.js를 이용하기 위해서는 데이타가 어떻게 그려지는지 원리부터 차근차근 알아가야 잘 쓸 수 있습니다. chart.js나 echart.js와는 달리 간단히 데이타만 넣으면 알아서 차트가 그려지지는 것과는 다르죠.  

원리를 알아가는 점은 번거러울 수도 있습니다. 하지만 조금만 노력을 기울인다면 D3.js는 최고의 선택일 것입니다. 237kb라는 작은 용량으로 정말 다양한 시각화적인 요소를 표현할 수 있다는 점과 매우 작은 부분 까지 커스터마이징하기가 쉽기 때문입니다. 그리고 만든사람이 무려 json의 창시자, 마이클 보스톡입니다. 최신 리액티브 프로그래밍을 반영하는 점이나 빠르게 업데이트하는 면도 눈여겨볼만한 부분입니다.

아래의 예제를 보시면서 [D3API주소](https://github.com/d3/d3/blob/master/API.md)를 보고 진행을 하셔도 좋고 도통 모르겠다 하시는 분들은 부록E로 넘어가서 D3.js의 기본적인 예제를 공부하시면 됩니다. 

### 4.2 D3.js : 지도매핑모듈
D3.js로는 많은 것을 만들 수 있습니다. 그 중에 하나가 바로 지도입니다. 

#### 4.2.1 topojson과 geojson비교
지도를 그리기 앞서 topojson과 geojson에 대해 알아봅니다. topojson이나 geojson 모두 지도를 그리기 위한 재료이자 지리적 정보들을 담고 있는 데이타 입니다. 다양한 지리적 데이터 구조를 표현하기 위해 인코딩된 json입니다.

좀 더 자세히 설명하자면, 그림을 그리는데 있어 레스터 방식과 벡터 방식이 있습니다. 레스터 방식은 이미지를 확대하면 깨지는 픽셀단위의 그림이며 벡터 방식은 픽셀데이터가 아닌 점,선,면 등 기하학적인 모양을 저장하며 확대하더라도 "깨지지 않는" 데이터 방식인 수학적 함수관계에 의해 만들어진 이미지방식을 말합니다. 이 벡터 방식을 가지고 있는 지리데이타 포맷중에는 geoJSON, topoJSON 등이 있으며 이번에 topojson을 쓸 것입니다.  

topojson은 각 구역들이 좌표들로 구성된 line으로 이루어져 경계들이 중복되는 geojson과는 달리 경계정보를 arc속성으로 이루어져 중복되지 않는 위상(topology)정보에 따라 인코딩 됩니다. 그렇기 때문에 geojson 보다 파일 사이즈가 작은 장점을 가지고 있습니다.(데이타의 범위마다 다르지만 약 80% 정도 가볍다고 합니다.) topology를 더 자세히 알고싶다면 [topology구현방법](https://bost.ocks.org/mike/topology/)을 참고 하면 됩니다. 

 * 하지만 데이타에 기하학적인 조정을 가한다면 geojson을 써야 합니다. 
 
 

#### 4.2.2 D3.js를 이용한 지도그리기 및 줌이벤트
이제 실제 코드로 넘어가서 하나하나 살펴보도록 하겠습니다. 코드가 약간 길기 때문에 차근차근 살펴보겠습니다. 4장에 미리 만들어 놓은 코드가 있습니다. 2장과는 다른 부분이 있어 다운받아서 진행하는 것을 추천드립니다.  

`npm install --save d3` 와 `npm install --save topojson`를 통해 우리가 필요한 도구, 외부 라이브러리들을 미리 준비합니다. 

#### 전체코드 : MEVN/4장/sensor/src/views/Map.vue 
```html
    
<template>
  <div class="Map"> 
    <div class="d3"></div>
  </div>
</template>
<script>
  import * as d3 from 'd3';
  import * as topojson from 'topojson'; 
  export default {
    name: 'Map', 
    mounted() {
      this.draw();
    },
    methods: {
      draw() { 
        const koreaMap = require('../assets/skorea-provinces-2018-topo-simple.json');
        const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_provinces_2018_geo);  

        const width = 600;
        const height = 1000;
        const svg = d3
          .select('.d3')
          .append('svg')
          .attr('width', width).attr('height', height);

        const projection = d3.geoMercator()
          .scale(1)
          .translate([0, 0]);

        const path = d3.geoPath().projection(projection);
        const bounds = path.bounds(_map);

        const widthScale = (bounds[1][0] - bounds[0][0]) / width;
        const heightScale = (bounds[1][1] - bounds[0][1]) / height;
        const scale = 1 / Math.max(widthScale, heightScale);

        const xoffset = width / 2 - scale * (bounds[1][0] + bounds[0][0]) / 2 + 10;
        const yoffset = height / 2 - scale * (bounds[1][1] + bounds[0][1]) / 2 + 80;
        const offset = [xoffset, yoffset];
        projection.scale(scale).translate(offset);

        const map = svg.append('g')
          .selectAll('path').data(_map.features)
          .enter().append('path')
          .attr('d', path);
          
        const mapInfo = [{
            "name": "서울",
            "lat": "37.532600",
            "lon": "127.024612"
          },
          {
            "name": "대전",
            "lat": "36.3730178",
            "lon": "127.2483736"
          }
        ]

        const icons = svg.append('g').selectAll('svg')
          .data(mapInfo)
          .enter()
          .append("svg:image")
          .attr("width", 50)
          .attr("height", 50)
          .attr('x', d => projection([d.lon, d.lat])[0])
          .attr('y', d => projection([d.lon, d.lat])[1])
          .attr('opacity', 1)
          .attr("xlink:href", require("../assets/grapefruit.svg"))

        const zoomed = () => {
          map.attr('transform', d3.event.transform)
          icons.attr('transform', d3.event.transform);
        }
        const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
        svg.call(zoom)
      }
    }
  }
</script>
<style>
  .hello {
    width: 100%;
  }

  .d3 {
    background: #eee;
    width: 618px;
    height: 1000px;
    margin: 0 auto;
  }

  path {
    fill: #ed8b70;
    stroke: #de6a6c;
  }
</style>
```

하나하나 차근차근 알아보도록 하겠습니다. 
```js
import * as d3 from 'd3';
import * as topojson from 'topojson';
```
D3와 topojson을 `import` 시킵니다. 
이 불러오는 방법은 ES6모듈 포맷방식입니다.  

 > 참고 : 자바스크립트 모듈문법

자바스크립트 모듈문법 중 CommonJS모듈과 ES6모듈 포맷이 있습니다.
 * UMD와 AMD, System.register 모듈 포맷 방식은 여기서 설명하지 않습니다.

CommonJS 포맷은 Node.js에서 사용되며 `require`와 module.exports를 사용해서 의존성과 모듈을 정의합니다. 
```js
const a1 = require('./a1.js')
const a2 = require('./a2.js')

module.exports = function (){

}
```
위와 같은 형식입니다.

ES6 모듈 포맷은 import와 export를 사용합니다. 
```js
//특정 함수인 mapC만을 가져올 수 있으며
import { mapC } from 'fxjs';
//전체를 다 불러서 d3란 네임스페이스를 지정할 수 있습니다.
import * as d3 from 'd3';

export default curry(function mapC(f, iter) {
  return takeAllC(mapLazy(f, iter));
}); 
```

#### 1) topojson을 이용한 지도정보 설정
```js
const koreaMap = require('../map/skorea_municipalities_topo_simple.json');
const _map = topojson.feature(koreaMap, koreaMap.objects.skorea_municipalities_geo); 
```
우리나라 topojson파일을 로드하고 `topojson.feature`을 통해 _map이라는 변수에 맵에 관련된 정보를 할당합니다.  

#### 2) 그림을 그릴 영역설정
```js 
const width = 600;
const height = 1000;
const svg = d3
.select('.d3')
.append('svg')
.attr('width', width).attr('height', height); 
```
기본 셋팅입니다. 우리가 그릴 캔버스를 설정해 놓읍시다. `class="d3"`를 가지고 있는 DOM에 `svg`태그를 `append`시키고 그 영역에 width의 값과 height의 값을 설정합니다. 그리고 그 svg에 우리가 map을 만들것이기 때문에 많은 요소들이 들어갑니다. 그러므로 group으로 감싸줘야 하므로 g태그를 붙입니다. 

이것이 D3로 시각화하는 첫단계입니다. 
1. 재료를 선택하고(topojson) 
2. 그 재료를 쓸 캔버스를 설정합니다(select, append, attr)

#### 3) projection 설정
```js
const projection = d3.geoMercator()
.scale(1)
.translate([0, 0]); 
```
이 지도의 투사법은 메르카토르 투사법을 씁니다. 지구는 동그라한 구형태이기 때문에 이를 평면에 펼쳐서 보기 위해서는 투사법이 존재하며 그 중 메르카토르 투사법을 쓸 것입니다. 메르카토르투사법, 초기 스케일, 처음에 이 투사법을 가진 프로젝터를 얼마나 이동시킬 것인가를 정하고 projection 이라는 변수에 객체를 셋팅합니다. 지구를 어떤 프로젝터로 멀리서 켜서 비친 지점들을 지도로 나타낸다고 상상하면 쉽습니다. 

 > 이외에도 Orthographic이라는 투사법도 있습니다. 
 
#### 4) bounds
```js
const path = d3.geoPath().projection(projection);
const bounds = path.bounds(geojson); 
```
`projection`을 통해 그리는 지도인 path 객체를 만들고 bounds를 통해 y축 끝값, x축 끝값을 걸정합니다. 이를 통해 그 path의 중앙설정을 할 수 있습니다. 이는 우리나라 지도의 중앙이겠죠?

bounds의 1차원배열은 path의  xmax와 xmin을 가리킵니다. bounds[0][x].. 의 0에서 0, 1을 통해 xmax와 xmin을 나타낼 수 있습니다.  즉, 최소경도, 최대경도(longitude)를 가리키게 됩니다. 
bounds의 2차원배열은  ymax와 ymin을 가리킵니다. bounds[x][0]..의 0에서 0, 1을 통해 ymax와 ymin을 가리킵니다. 즉, 최소위도, 취대 위도를 가리킵니다. (latitude)

 > bounds 그림 추가 (수정예정)

#### 5) scale
 
```js
const widthScale = (bounds[1][0] - bounds[0][0]) / width; 
const heightScale = (bounds[1][1] - bounds[0][1]) / height;  
const scale = 1 /Math.max(widthScale, heightScale); 
```
그 다음 스케일을 정의해줍니다. 이 스케일은 지도에서 축척을 의미합니다. 넓은 우리나라 땅덩어리를 우리는 작은 화면에 표시해야 합니다.  일단 우리가 구한것은 path의 가장자리를 구한 것입니다. 
이것중에서 가장 최대값을 구하고 이를 이용해서 축척을 만들어줍니다. 5만배의 축소율을 가진 지도를 표시할 때 1 : 50000이라고 나타내며 이는 1 / 50000이라고도 합니다. 똑같이 우리는 축척을 1 / maxScale로 나타낸 것입니다.    

#### 6) translate
```css
.center {
  position: absolute;
  left: 50%;
  top: 50%; 
  transform: translate(-50%, -50%); 
}
```
어떠한 물건을 중앙에 놓으려면 어떻게 해야 할까요? 우리는 위의 코드처럼 left와 top을 50%씩 설정하고 자신의 크기만큼 translate를 -50%씩 주면 됩니다. 우리가 흔히 css로 어떠한 영역을 가로, 세로 중앙 정렬할 때 쓰는 방법이죠. 
```js
const xoffset = width/2 - scale * (bounds[1][0] + bounds[0][0]) /2 + 10; 
const yoffset = height/2 - scale * (bounds[1][1] + bounds[0][1])/2 + 80; 
const offset = [xoffset, yoffset];
projection.scale(scale).translate(offset);
``` 
지도도 또똑같습니다.  
 
위의 코드처럼 translate로 일단 사물을 옮기고 그 사물의 "크기의 50%" 만큼 또 옮깁니다. 똑같이 우리가 보여주는 크기의 반인 bounds의 반을 xoffset, yoffset으로 지정하고 translate를 통해 **중앙**으로 옮기면 됩니다. 

#### 7) selectAll
```js
map
.selectAll('path').data(_map.features)
.enter().append('path') 
.attr('d', path);  
``` 
D3.js에서 가장 중요한 구조가 뭐냐고 묻는다면 단연코 `.selectAll(요소).data(데이타).enter().append(요소)` 일 것입니다. 데이타 만큼의 가상 DOM을 생성 후 selectAll, 그 DOM에 데이타의 개수만큼(data) 특정 요소들을 붙이는 (enter & append)것을 이 4가지의 메소드 체인으로 구성할 수 있습니다. _map.features라는 지역적정보를 바탕으로 path를 만들 수 있습니다.

#### 8) 자몽을 놓을 위도 경도에 따라 매핑하기 
```js 
  const mapInfo = [
    {
      "name":"서울",
      "lat" : "37.532600",
      "lon" : "127.024612"
    },
    {
      "name":"대전",
      "lat" : "36.3730178",
      "lon" : "127.2483736"
    }
  ] 
```
우리는 자몽이라는 아이콘을 놓을 것입니다. 자몽에 해당하는 lat(위도), lon(경도)를 설정합니다.  
```js
const icons = svg.append('g').selectAll('svg')
.data(mapInfo)
.enter()
.append("svg:image")
.attr("width", 50)
.attr("height", 50)
.attr('x', d => projection([d.lon, d.lat])[0])
.attr('y', d => projection([d.lon, d.lat])[1])
.attr('opacity', 1)
.attr("xlink:href", require("../assets/grapefruit.svg"))
```  
이렇게 매핑을 하면 됩니다. 우리가 만들어 놓은 위경도 자료 만큼 svg를 붙이는(append) 하는 것입니다. 저렇게 attr을 이용해서 가로 세로, x좌표, y좌표, 투명도를 설정해주면 됩니다.  
 
#### projection 
```js
  function projection(point) {
    point = projectRotate(point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
    return [point[0] * k + dx, dy - point[1] * k];
  }
```
 * v5에서 달라진 부분존재 추후 수정예정

projection 메소드가 궁금할 것같아서 준비했습니다.  위경도에 해당하는 값을 배열로 받아서 첫번째에 그 투사법으로 추출되는 x, 경도를 반환하고 y, 위도를 반환합니다.  

​ 
#### 줌이벤트 
```js
const zoomed = () =>{
  map.attr('transform', d3.event.transform)
  icons.attr('transform', d3.event.transform)
}
const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed)
svg.call(zoom)
```
줌이벤트는 간단합니다. 이렇게 줌을 걸어주고자 하는 group에 transform 특성에 해당 event를 추가하고 zoom이 큰 svg에서 발동할 때마다 미리 설정해 놓은 이벤트들이 작동하게끔 설정해주면 됩니다. call은 자바스크립트의 call을 생각하면 됩니다.

#### call
```js
const 큰돌 = {
    "이름": "큰돌"
}

function editmyresume(능력, 힘) {
    this.능력 = 능력
    this.힘 = 힘
} 
editmyresume.call(큰돌, "Vue.js", "팔굽혀펴기") 
console.log(큰돌)
```
어떠한 함수를 실행하는데 객체를 넣어서 기본값을 설정할 수 있습니다. 

이제 다 만들었습니다.  결과물은 다음과 같습니다. 

![자몽지도](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_지도.gif)  


이렇게 D3.js를 이용해서 가벼운 지도예제를 만들어 보았습니다. 그 외에도 많은 것들을 D3.js로 구현할 수 있습니다. 다양한 예제들은 https://bl.ocks.org/mbostock 를 통해 볼 수 있습니다.
 
### 4.3 D3.js : 증가하는 숫자
좀 더 재밌는 예제를 만들어보도록 하겠습니다. 보통 게이지가 차면서 숫자가 증가하는 애니메이션 많이들 보죠? 그러한 것을 구현해보겠습니다.  

#### 전체코드 : MEVN/4장/sensor/src/views/Number.vue 
필수적인 코드만 차근차근 살펴보겠습니다. 
```html
<template>
  <div class="hello">
    <h2>커져가는 원속의 숫자 + 게이지</h2>
    <svg></svg> 
  </div>
</template>

<script>
  import * as d3 from 'd3';   
  export default {
    name: 'HelloWorld3',
    data() {
      return { 
      }
    },
    mounted() {
      this.showCircle();
    },
    methods: {
      showCircle() {  
        const width = window.innerWidth - 20;
        const height = window.innerHeight - 20; 
        const radius = Math.min(width, height) / 3;    
        const format = d3.format(".0%");  
        const group = d3.select("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
        const textDOM = group.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", ".3em");
          
        const arc = d3.arc()
          .innerRadius(radius * 0.7)
          .outerRadius(radius); 
        const pieGenerator = d3.pie().sort(null)
        const background = group.append("path")
          .data(pieGenerator([1])) 
          .attr("class", (d, i) =>"backColor") 
          .attr("d", arc)

        const foreground = group.append("path")
          .data(pieGenerator([0, 100])) 
          .attr("class", (d, i) =>`frontColor${i}`) 
          .attr("d", arc)
 

        function arcTween(pie){
          return function(d){ 
            const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
            const interpolateText  = d3.interpolate(0,pie[0].value); 
            return function(t){
              d.endAngle = interpolate(t);
              textDOM.text(format(interpolateText(t) / 100));
              return arc(d);
            }
          } 
        }   
        foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
      }
    }
  }

</script> 
<style>
  path.backColor {
    fill: #ff9c00;
  }
  path.frontColor0 {
    fill: #545f73;
  }
  path.frontColor1 {
    fill: #ff9c00;
  }  

  text {
    font-size: 7em;
    font-weight: 400;
    line-height: 16em;
    fill: black;
    font-family:오버워치;
  }
  @font-face {
    font-family: 오버워치;
    src: url(../assets/koverwatch.woff2);
  } 

</style>

```
#### 4.3.1 화면 설정 및 반지름설정
```js
const width = window.innerWidth - 20;
const height = window.innerHeight - 20; 
const radius = Math.min(width, height) / 3;  
```
현재 위도우의 width와 height에 맞춰 width, height를 잡고 그에 따라 반지름을 잡습니다.
#### 4.3.2 format설정 
```js
const format = d3.format(".0%"); 
``` 
d3.format을 이용하면 쉽게 어떠한 숫자에 포맷을 설정할 수 있습니다. 예를 들어 `1f`는 소수점1자리까지, `.0%`는 퍼센트 단위로도 가능합니다.  
#### 4.3.3 영역설정
```js
const group = d3.select("svg")
.attr("width", width)
.attr("height", height)
.append("g")
.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");     

const textDOM = group.append("text")
.attr("text-anchor", "middle")
.attr("dy", ".3em");
```
전과 똑같이 svg를 선택(select)를 하고 attr-width, height로 영역을 설정하고 transform 으로 중앙정렬합니다.  그리고 증가하는 숫자를 담을 text라는 요소를 설정합니다. 

#### 4.3.4 파이 제너레이터
```js
const arc = d3.arc()
.innerRadius(radius * 0.7)
.outerRadius(radius); 
const pieGenerator = d3.pie().sort(null)
const background = group.append("path")
.data(pieGenerator([1])) 
.attr("class", (d, i) =>"backColor") 
.attr("d", arc)

const foreground = group.append("path")
.data(pieGenerator([0, 100])) 
.attr("class", (d, i) =>`frontColor${i}`) 
.attr("d", arc)
``` 
숫자를 중심으로 증가하는 원을 만들기 전에 설정을 해야 합니다.`d3.arc().innerRadius(radius * 0.7).outerRadius(radius)` pie를 설정할 때 안쪽반지름(inner), 바깥쪽의 영역(outer)를 설정합니다. 안쪽을 0.7로 설정을 했으므로 안이 좀 비어있는 파이를 만들 수 있습니다.  그리고 `pieGenerator`를 이용해서 특정 배열을 통해 pie 제너레이터를 만듭니다. 그 제너레이터로 정확한 도넛형태의 모양을 그릴 수 있습니다.  

#### 4.3.5 애니메이션
```js
function arcTween(pie){
  return function(d){ 
    const interpolate  = d3.interpolate(pie[0].startAngle,pie[0].endAngle);
    const interpolateText  = d3.interpolate(0,pie[0].value); 
    return function(t){
      d.endAngle = interpolate(t);
      textDOM.text(format(interpolateText(t) / 100));
      return arc(d);
    }
  } 
}   
foreground.transition().duration(1500).attrTween("d", arcTween(pieGenerator([80, 20]))).delay(1000)
```
대망의 애니메이션입니다. 
interpolate는 2가지의 값을 이용해서 0부터 1까지의 값에 매핑을 합니다. 예제를 보면 쉽습니다.  
```js
var i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20
```
보간하다라는 뜻을 가진 이 interpolate는 주어진 2개의 값을 이용해서 그 사잇값들을 만듭니다.
이를 이용해서 우리는 애니메이션을 만들 수 있습니다. `pieGenerator([0, 100])`에서 부터 `pieGenerator([80, 20])`까지의 애니메이션을 하기 위해 `arcTween`이라는 것을 만들었습니다. 애니메이션을 사용하려면 매 순간순간마다 프레임이 있어야 하며 `arcTween`을 이용하면 매 순간 원에 해당한 정확한 path를 만들 수 있기 때문이죠

![증가하는 숫자](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_number.gif) 
  
### 4.4  실시간 센서시각화사이트 : 설계
이제부터 실시간 센서시각화사이트를 본격적으로 만들어 볼 것입니다. 
#### 4.4.1 아키텍처 구축
아키텍처를 구축해야 합니다. 어떻게 만들 것인지 그림으로 그려보는 것이 중요합니다. 
![아키텍처](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처.png) 

아주 간단한 아키텍처입니다. 센서를 내보내는 REST API를 통해 JSON형태의 센서를 받아 MongoDB에 저장한 후 그 값을 뽑아 내어 상태저장소인 Vuex를 통해 상태를 변이시키고 이를 통해 Chart로 표출하는 아키텍처입니다.

 > 참고

사실 아키텍처는 회사에서 정해주거나 팀원들끼리 정한 약속에 의한 양식에 맞춰 작성하는 것이 일반적입니다. 하지만 혼자 만들 때는 이렇게 아무렇게나 그려보면 됩니다. 아무렇게나 그려도 프로젝트를 설계할 때 그리는 것은 매우 중요하며 습관이 되어야 합니다.
보통 아키텍처를 그릴 때 아마존에서 사용하는 아이콘을 자주 사용합니다. 
![아키텍처_아마존](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_아키텍처_아마존.png)
이 아이콘은 [아이콘링크](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/아마존아이콘.ppt) 를 통해 바로 다운 받을 수 있습니다. 참고하시길 바랍니다. 
 
#### 4.4.2 실시간 통신 : websocket방식과 polling 방식 비교  
실시간 통신이란 보통 Websocket으로 통신한다는 것은 HTTP를 기반으로 설정된 **ws프로토콜**을 통해 양방향통신을 하는 것을 말합니다.WebSocket 객체를 통해 양방향통신을 하는데 이 객체는 서버와의 WebSocket 연결을 생성하고 관리할 수 있는 API 들을 제공하며 가장 유명한 라이브러리로는 Socket.io가 있습니다. 하지만 오래된 브라우저의 경우(IE9이하) [caniuse-websocket](https://caniuse.com/#search=websocket)미지원되므로 이 때는 websocket이 아닌 polling 방식, 주기적인 요청 또는 long polling, RESPONSE 받게 되면 REQUEST를 다시 요청(무한 재귀함수)로 구현해야 합니다. 

 > Q : Ajax랑 다른점이 뭔가요? 
 
클라이언트에서 요청하지 않아도 서버에서 클라이언트에게 원하는 시간대에 원하는 데이타를 줄 수 있다는 점입니다. 

#### 4.4.3 센서생성 서버 구축
센서데이타서버를 구축하는 방법은 크게 3가지가 있습니다. 첫번째는 정말 센서를 사서 구축하는 것이며 두번째는 기상청 Open API를 받는 것이며 세번째는 방재기상포털의 있는 파일을 통해 구축하는 방법입니다. 우리는 세번째 방법으로 해보겠습니다. 날짜는 2019년 8월2일 기준으로 했으며 지역은 제가 사는 강동구를 중심으로 했습니다. 방재기상포털은 https://data.kma.go.kr 에 가면 정말 쉽게 자료들을 다운받을 수 있으며 여기서 구축하는 예제의 파일은  MEVN/4장/sensor/RESTAPI/data/20190802_강동구.csv 에 저장해 두었습니다.  

```js
id,time,temp,wv,humi
402,2019-08-02 00:01,26.2,.4,85.7
...
```
데이타입니다. 한국말로 되어있는 것을 영어 key값으로 수정했습니다. 이를 mongoDB에 저장할텐데 MongoDB에 저장할 때 key값의 용량도 함께 들어가기 때문에 키값을 축소시키는 것이 중요합니다. windvelocity는 wv로 수정했고 humidity는 humi를 썼습니다. 

센서를 만드는 로직은 이렇게 cnt라는 전역변수를 통해 구현할 수도 있으며 제너레이터를 이용해서도 구현할 수 있습니다. 
먼저 cnt를 이용한 예제입니다. 

일단 먼저 유저를 추가합니다. 
```shell
 > db.createUser({  
 user:"dabin",
 pwd:"dabin12010",
 roles:[  
  {  
     role:"readWrite",
     db:"sensor"
  }
 ],
 mechanisms:[  
  "SCRAM-SHA-1"
 ]
})
```
다빈, dabin이라는 이름을 가진 user를 추가했습니다. 이 때 sensor라는 DB를 만들지 않았다면 test라는 DB에 자동적으로 user가 추가가 됩니다.  

 > 참고 : sensor DB 생성하기
 
 ---- 

1. mongo shell을 구동합니다.
2. sensor데이타베이스로 이동 `use sensor` 
3. 데이타베이스확인 : `show dbs` 아직 sensor가 생성되지 않았습니다.
4. 데이타베이스 생성, db.sensor.insert({"kundol" : 1})
5. 데이타베이스확인 : `show dbs` sensor DB가 생성되었습니다!

 ---- 

이제 앞서 설명한 createUser을 하면 sensor에 다빈이가 추가된 것을 볼 수 있습니다. `db.getUsers()`로 유저를 확인할 수 있습니다.

자 이제 본격적으로 센서 서버를 만들어보겠습니다.  
#### MEVN/4장/sensor/서버/server.js
```js
const express = require('express')
const app     = express()
const cors    = require('cors')
const http    = require("http").createServer(app)
const io      = require('socket.io')(http)
const util    = require('./util')()
const sensorController = require('./controller/sensor')
const path    = require('path')  
const _path   = path.join(__dirname, '..', './dist')  
const PORT    = 12010 
const mongoose = require('mongoose') 
const USER = 'dabin'
const PWD = 'dabin12010'
const HOST = 'localhost:27017'
const DB = 'sensor'
const mongodbURL = `mongodb://${USER}:${PWD}@${HOST}/${DB}`  // -- (1)
let userList = [];
const main = async()=>{
  //app 객체 설정 
  app.use('/', express.static(_path))  
  app.use(cors()) 
  // MongoDB connect 설정
  mongoose.connect(mongodbURL, {useNewUrlParser: true}) 
  .then(() =>  console.log('connection succesful'))
  .catch((err) => console.error(err)) 
  mongoose.set('useFindAndModify', false);
  let toIdx = 10; 
  //io 객체 설정 
  const jsonArray = await util.readCSV();   // -- (2)
  io.on('connection', async (socket) =>{  
    console.log(`User connected :: ${util._date()} ID : ${socket.id}`)   
    userList.push(socket.id)  // -- (3)
    socket.on('disconnect', () => {  
      console.log(`User disconnected :: ${util._date()} ID : ${socket.id}`)  
      userList.splice(userList.indexOf(socket.id),1); 
    });       
    const sensor_first = await sensorController.emitSensorAndSaveStart(io, jsonArray, toIdx);  // -- (4)
    console.log(`Send to user Current Sensor And Save DB in first :: ${util._date()} ${sensor_first}`)    
  });   
  //센서데이타는 항상 받자 마자 emit을 해줘야 한다. 그 부분을 재현 
  const sensor = await sensorController.emitSensorAndSave(io, jsonArray);   // -- (5)
  toIdx = sensor.idx; 
  setInterval(async () => {    
    const sensor = await sensorController.emitSensorAndSave(io, jsonArray);  
    toIdx = sensor.idx;  
    console.log(`Send to user Current Sensor And Save DB :: ${util._date()} ${JSON.stringify(sensor)}`) 
  }, 1 * 1000); 
  http.listen(PORT, ()=> console.log(`센서서버가 시작됩니다. http://127.0.0.1:${PORT} :: ${util._date()}`)); // -- (6)
}
main();   
``` 
server.js입니다. 고작 50줄밖에 되지 않습니다. 이렇게 main서버는 항상 작게 만들고 모듈화를 시키는 것이 중요합니다. 이 서버는 단순한 센서 서버라서 sensorController라는 컨트롤러밖에 없지만 컨트롤러가 많아진다면 이 모듈화 방법은 정말 효율적이게 될 것입니다. 각각의 역할을 지닌 로직 별로 모듈화를 시키는 것은 항상 중요합니다. 또한, 주석을 달 때 첫번째 문자는 반드시 대문자로 해주어야 합니다. 


각각의 코드 설명입니다. 
1) 아까 만들었던 계정을 통해 mongoDB에 연결 합니다. DB는 sensor를 씁니다. 
2) 센서서버 자료를 읽어 옵니다. 자료는 2019년 8월 2일 여름의 강동구 기상 센서 자료입니다. 
3) connection되었을 때의 이벤트입니다. 단말기(유저)가 연결되었을 때 userList에 넣어서 관리를 합니다. class로도 할 수 있습니다. 간단하게 배열로 구축했습니다.
4) 처음에 connection되었을 때 지금의 toIdx까지 센서자료를 전달합니다. 예를 들어 지금 센서생성서버가 13의 idx를 가진 센서를 생성한다면 3부터 13까지의 10개의 센서 자료를 보내서 기본 차트를 그리도록 합니다. 
5) 센서생성서버는 항상 코든 유저에게 io.emit 이벤트를 통해 센서를 보내는 부분입니다. 
6) 서버를 생성하는 부분입니다. 보통 socket.io 와 실시간 통신을 하는 http 서버를 만들 때 이렇게 서버를 구축합니다.

```js
const http    = require("http").createServer(app)
const io      = require('socket.io')(http)
...
http.listen(PORT, ()=> console.log(`센서서버가 시작됩니다. http://127.0.0.1:${PORT} :: ${util._date()}`));

``` 


![toIdx설명](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4장_toIdx.png)
4번에 대한 설명을 하기 위한 그림입니다. 
센서는 1초마다 생성이 되는데 그 때 유저가 들어왔을 때 toIdx까지 보내기만 하면 쉽게 그 이전의 초기 센서값들을 보낼 수 있습니다. 
  
#### MEVN/4장/sensor/서버/models/senser.js
```js
const Sensor = require('../models/sensor.js'); 
const _ = require("fxjs/Strict");  
const start_CNT= 10; 
const save = async(data)=> { // --- (1)
    const ret = await Sensor.findOneAndUpdate({
        "cnt" : {
            $eq : data.cnt
        }}, {
            $set : data
        }, {
            upsert: true, 
            multi: true, 
            new : true, 
            setDefaultsOnInsert: true
        }
    ).lean()
    return ret;  
};

const setType = data =>{ 
    for(let key in data){ // --- (2)
        if(key == 'time')data[key] = new Date(data[key])
        else data[key] = Number(data[key])
    } 
    return data; 
}

// 전역변수로 증가시키는 setNextData
let cnt = start_CNT;   
const setNextData = (jsonArray) =>{ 
    const l = jsonArray.length;    
    let data = jsonArray[cnt];  
    data = {cnt : cnt, ...setType(data)} 
    cnt = (cnt + 1) % l; 
    return data;    
}  

// 이터레이터로 만드는 cnt
function *setCntIterator() {  
    let cnt = start_CNT;   
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
}  
const iterator = setCntIterator(); 
const setNextDataIterator = (jsonArray) =>{
    const l = jsonArray.length;      
    const cnt = iterator.next().value;   
    const idx = cnt % l; 
    let data = jsonArray[idx];   
    data = {idx : idx, ...setType(data)};
    return data;    
}

//slice를 이용한 take from to
const takeFromTo = (from, to, a) =>{
    if(to < from)return [...a.slice(from), ...a.slice(0, to + 1)] 
    else return a.slice(from, to + 1)
}  

//이터레이터를 이용한 take from to
function *setFromIterator(from) {  
    let cnt = from;  
    while (true) {
        yield cnt;
        cnt = (cnt + 1);  
    }
}    
const takeFromToIterator = (from, to, sensors)=>{ 
    const l = sensors.length;   
    const cnt = to < from ? l - (from - to - 1) :  to - from  + 1
    return _.go( // --- (3)
        setFromIterator(from), 
        _.take(cnt), 
        _.map(e => sensors[e % l])
    )
} 

exports.emitSensorAndSave = (io, jsonArray)=>{
    return new Promise((resolve, reject) =>{
        //const data = setNextData(jsonArray) 
        const data = setNextDataIterator(jsonArray)    // --- (4)
        io.emit("sensor", data); 
        save(data); 
        resolve(data)
    }) 
} 
exports.emitSensorAndSaveStart = (io, jsonArray, toIdx)=>{
    const l = jsonArray.length
    const from = toIdx - start_CNT < 0 ? (toIdx - start_CNT + l) % l : toIdx - start_CNT
    const to = toIdx  
    return new Promise((resolve, reject) =>{  
        let data = takeFromToIterator(from, to, jsonArray)  
        io.emit("sensor", data); 
        save(data); 
        resolve(data)
    }) 
} 
```
센서 생성서버의 중심이 되는 sensor.js입니다. 코드별로 설명하겠습니다. 
1) save입니다. 데이타를 받아서  "cnt" :{ $eq : data.cnt} cnt에 맞는 것을 찾아서  $set : data, data를 udpate 시킵니다..
2) for in을 객체에다 쓰면 객체의 모든 key와 value들에 대한 로직을 구현할 수 있습니다. MongoDB에 넣기 전 스키마에 맞는 형식으로 변환해줍니다. 
3) 배열의 요소중 from부터 to까지 끄집어내는 모듈입니다. from 부터 시작해 ` setFromIterator(from)`이 from부터 시작하는 이터레이터를 만들어서 그 from부터 `_.take(cnt)` cnt까지의 배열 idx를 뽑아냅니다. 그 후 `_.map(e => sensors[e % l])`그 idx에 맞는 센서데이타를 할당해서 그 만큼의 센서데이터들을 뽑아냅니다.  
4) 가장 중심이 되는 `emitSensorAndSave`입니다. idx에 해당하는 센서 데이타를 뽑아 내서 `io.emit("sensor", data);` 모든 단말기에 `sensor`이벤트로 data를 보내고 `save`, MongoDB에 저장을 합니다. 그 후 `resolve(data)`를 통해 Promise문을 탈출합니다. 

#### MEVN/4장/sensor/서버/util/index.js
```js
const csvFilePath = '../data/20190802_강동구.csv' 
const csv         = require('csvtojson') 
const path        = require('path')  
const _path       = path.join(__dirname, csvFilePath)  
 
const _form = date => ("00" + date).slice(-2)   
module.exports = () => {
    return {
        async readCSV() {
            //const jsonArray = await csv().fromFile(csvFilePath);
            return await csv().fromFile(_path);
        }, 
        _date(){
            const d = new Date(); 
            return `${d.getFullYear()}-${_form(d.getMonth() + 1)}.${_form(d.getDate())} ${_form(d.getHours())}:${_form(d.getMinutes())}:${_form(d.getSeconds())}`
        }
    };
} 
```
서버에 전체적으로 필요한 도구들이 담겨있는 util입니다. csv 파일을 읽는 readCSV는 `csvtojson`이라는 npm 모듈이 await / async를 지원하기 때문에 await로 쉽게 구축할 수 있습니다. `const _form = date => ("00" + date).slice(-2)`을 통해 8을 08로 바꾸고 12는 그대로 12로 내버려두게 하여 아름답게 로그를 08-08 06:30 이런식으로 구축할 수 있게 했습니다. 
 

 > 참고 : socket, broadcast, io.emit 차이

 ----

 실시간 통신은 아래의 표로 구분됩니다. 
  
| 이름 | 설명 | 사용법(socketio) | 
|:--------|:--------|:--------|
| public	| 1 : n - 1 통신, 보내는 유저 제외 모든 유저에게 메세지전달 | socket.broadcast.emit('이벤트이름', message) 	|
| private	|1 : 1 통신, 특정 유저에게 메세지가 전달	|  io.to(소켓아이디).emit('이벤트이름' message) |
| private	| 1 : 1 통신, 연결되었을 때의 socket을 통해 그 유저에게만 메세지가 전달 	| socket.emit('이벤트이름', message)	|
| broadcast	| 1 : n 통신, 모든 유저에게 메세지가 전달 	| io.emit('이벤트이름', message)	|  

 ----

### 4.5  실시간 센서시각화사이트 : 실시간통신과 디자인 
백엔드를 구축했으니 이제 프론트엔드를 구축할 것입니다. 

#### 4.5.1 Vuex 및 프로젝트 뼈대 구축
Vuex를 써야 하는 이유는 간단합니다. 컴포넌트끼리 데이터를 주고 받으려면 props, emit으로 주고 받게 되는데 프로젝트가 커진다면 데이터를 전달하고 받는 컴포넌트간의 갯수가 많아지고 체크하기도 어렵기 때문입니다. 
중앙집중화된 어떠한 데이타들의 관리 / 어떠한 데이타들이 변환되는 것을 감시(watch)하고 싶다면 쓰는 것입니다. Vuex를 쓸 때는 비동기적인 것은 actions에 그 외 동기적인 것은 mutations에 넣어야 합니다. 그리고 state의 상태변이에 있어서는 꼭 mutations를 써야 합니다. 즉, actions에서 직접적으로 state를 수정하면 안됩니다. actions에서 mutation으로 commit을 통해 넘겨줘야 하며 mutations에서 state를 수정해야 합니다. 또한 반드시 모듈화를 해야 합니다. 

store에 actions.js, mutations-type.js, mutations.js, state.js를 만듭니다. 

#### MEVN/4장/sensor/src/store/actions.js
```js
export default {
    initGetSensor({commit}, socket) { 
        socket.on("sensor", data => commit("CHANGE_SENSOR_CHART", data)) 
    }
};
```
actions에는 비동기이벤트를 받아 commit을 통해 mutations에다가 payload를 넘기는 일을 넣으면 됩니다. 

#### MEVN/4장/sensor/src/store/mutations.js
```js
import * as types from './mutations-type'; 
  export default {
    [types.CHANGE_SENSOR_CHART](state, payload) {    
        if(!state.sensors.length){ 
          state.sensors = payload; 
        }else {
          state.sensors.shift(); 
          state.sensors.push(payload);
        } 
    }
} 
```
mutations입니다. type에 해당하는 mutation이 담겨있습니다. 우리는 처음 10개의 센서데이타 배열을 받은 후 10개를 유지하며 새로운 데이타는 `push` 그 이전의 데이타는 shift를 통해 뺄 것입니다. 

#### MEVN/4장/sensor/src/store/mutations-type.js
```js
export const CHANGE_SENSOR_CHART = 'CHANGE_SENSOR_CHART' 
```
mutations에는 수많은 mutation 함수들이 들어갑니다. 저는 actions와 mutation을 구분할 수 있게 actions의 경우는 대문자 + types를 쓰지않습니다. 
 * 취향에 따라 actions-type를 만드는 사람들도 있습니다. 


#### MEVN/4장/sensor/src/store/state.js 
```js
export default {
    sensors : []
}
```
자 state는 sensors 하나만 넣으면 끝이 납니다.   

#### MEVN/4장/sensor/src/store.js  
```js
import Vue from 'vue'
import Vuex from 'vuex'
import actions from './store/actions.js'
import mutations from './store/mutations.js'
import state from './store/state.js'
Vue.use(Vuex)

export default new Vuex.Store({
  state,
  mutations,
  actions
})

```
그 이후 store에 이렇게 설정해 놓으면 끝입니다. 자 이렇게 vuex - store에 관한 모듈화가 끝이 났습니다. 

이제부터는 config 설정입니다. 

#### MEVN/4장/sensor/src/config/index.js  
```js
export default{
    host : "http://127.0.0.1", 
    port : 12010, 
    margin : {top: 50, right: 50, bottom: 50, left: 50}, 
    chartWidth : 300,
    chartHeight : 400
}
```
우리는 센서 차트라는 그림을 그릴 것인데 그것에 해당하는 width와 height를 config에 설정해주면 나중에 유지보수하는데 굉장히 좋습니다. 또한 센서데이타를 받아올 서버의 정보, host, port를 적어 놓습니다. 

### 4.6  실시간 센서시각화사이트 : 차트 컴포넌트 
이제 차트를 구현해보겠습니다.    

#### MEVN/4장/sensor/src/components/Chart.vue
```html
<template>
  <div :class="'Chart Chart-' + _key">
  </div>
</template>

<script>
  import config from '../config' // - (1)
  import * as d3 from 'd3' // - (2)
  const margin_value = 1;

  import {
    mapState
  } from 'vuex'
  export default {
    name: 'Chart',
    props: { // - (3)
      _key: String,
      color: String
    },
    data() {
      return {
        svg: "",
        xScale: "",
        yScale: "",
        xAxis: "",
        yAxis: "",
        line: ""
      }
    },
    mounted() {
      this.setAreaAndScale(this._key); // - (4)
      let cnt = 0;
      this.$store.subscribe((mutation, state) => {// - (5)
        if (mutation.type === "CHANGE_SENSOR_CHART") {  
          if (!cnt) this.initDraw(this.sensors, this._key);
          else this.draw(this.sensors, this._key);
          cnt = 1; 
        }

      })
    },
    methods: {
      setAreaAndScale(key) {
        this.svg = d3.select(`.Chart-${key}`).append("svg")
          .attr("width", config.chartWidth + config.margin.left + config.margin.right)
          .attr("height", config.chartHeight + config.margin.top + config.margin.bottom)
          .append("g")
          .attr("transform", `translate(${config.margin.left},${config.margin.top})`)
        this.xScale = d3.scaleTime().range([0, config.chartWidth])
        this.yScale = d3.scaleLinear().range([config.chartHeight, 0])

        const timeFormat = d3.timeFormat("%H:%M")
        this.xAxis = d3.axisBottom(this.xScale).tickFormat(timeFormat)
        this.yAxis = d3.axisLeft(this.yScale)
        this.line = d3.line().x(d => this.xScale(d.time)).y(d => this.yScale(d[key])).curve(d3.curveMonotoneX)

      },
      initDraw(data, key) { 
        //data는 string형태로 오기 때문에 여기서 new Date 객체로 바꿔주어야 한다. 
        data.forEach(function (d) {
          d.time = new Date(d.time)
        });
        //scale에는 extent또는 0부터 max까지 할 수있다. 
        this.xScale.domain(d3.extent(data, d => d.time))
        //yScale.domain([0, d3.max(data, d => d.temp)])  
        const _min = d3.min(data, d => d[key])
        const _max = d3.max(data, d => d[key])
        this.yScale.domain([_min - margin_value, _max + margin_value])

        //data를 통해 path를 그리는데 3가지 방법이 있다. 
        // svg.append("path").datum(data).attr("d", line)
        // svg.append("path").data([data]).attr("d", line) 
        this.svg.append("path")
          .attr("d", this.line(data))
          .attr("class", "line")
        this.svg.append("g")
          .attr("class", "x axis")
          .attr("transform", `translate(0,${config.chartHeight})`)
          .call(this.xAxis);

        this.svg.append("g")
          .attr("class", "y axis")
          .call(this.yAxis);
      },
      //draw에서는 데이터 처리가 아닌 data를 통해서 차트틀 그리는 것에 대해 집중해야 한다. 
      draw(data, key) {   
        data.forEach(function (d) { // - (6)
          d.time = new Date(d.time)
        });

        this.xScale.domain(d3.extent(data, d => d.time)) // - (7) 
        const _min = d3.min(data, d => d[key])
        const _max = d3.max(data, d => d[key])
        this.yScale.domain([_min - margin_value, _max + margin_value])
 
        var svg = d3.select(`.Chart-${key} svg`).transition();
        svg.select(".line")  
          .duration(750)
          .attr("d", this.line(data));// - (8) 
        svg.select(".x.axis")  
          .duration(750)
          .call(this.xAxis);
        svg.select(".y.axis")  
          .duration(750)
          .call(this.yAxis);
      }
    },
    computed: {
      ...mapState([
        'sensors'
      ])
    }
  }
</script>

<style>
  .Chart .line {
    fill: none;
    stroke: #f89e35;
    stroke-width: 2px;
  }
  .Chart-humi .line{ 
    stroke: #42b983; 
  } 
  .Chart-wv .line{ 
    stroke: #262d3d; 
  } 
  div.tooltip {
    position: absolute;
    text-align: center;
    padding: 5px;
    font-size: 12px;
    font-weight: bold;
    background: #f99e1a;
    border: 0px;
    border-radius: 8px;
  }

  .tooltip p {
    margin: 0;
    padding: 0;
  }

  circle {
    fill: rgba(40, 53, 79, .95);
  }
</style>
```
 > toolip은 추후 수정예정

코드를 보면서 각각 설명하겠습니다
1)`import config from '../config'`를 통해 아까 설명했던 config를 가져와 width, height 등을 설정합니다. 
2)`import * as d3 from 'd3'` D3는 common모듈방식과 ES6방식을 모두 지원합니다. ES6방식을 사용하여 D3를 가져옵니다.
3)` props: { ` D3는 특정한 DOM에 svg나 다른 것들을 **붙여서** 그림을 만들어 냅니다. 이 Chart.vue는 재사용되기 때문에 예를 들어 똑같은 클래스에 붙이게 되면 그림이 겹쳐지게 됩니다. 그렇기 때문에 각각의 컴포넌트를 구분할 _key가 필요하며 각각의 컴포넌트마다 다른 색깔을 넣기 위해 color를 props로 받아옵니다. 
4)`this.setAreaAndScale(this._key); `먼저 그림을 그릴 영역을 설정합니다. 이 때 전역변수로 설정할 수 있지만 `this.line`등으로 vue 인스턴스에 거는 이유가 있습니다. 바로 같은 화면에 component를 3개를 놓는다고 했을 때 그 컴포넌트에 전역변수를 걸어버리면 한번밖에 선언을 안하고 그 메소드가 동작할 때 line함수에 다른 값이 할당이 되게 됩니다. 즉, 컴포넌트마다 각기 다른 변수를 할당하지 못하기 때문에 각기 다른 효과를 원한다면 vue인스턴스에 할당을 해야 합니다. 
5)`this.$store.subscribe((mutation, state) `를 통해 mutation을 감지할 수 있습니다. 감지해서 처음에는 initDraw, 그 다음에는 draw로 그림을 그립니다. 
6) 이 처리를 하는 이유는 뭘까요? 우리가 받는 데이타는 string입니다. 서버로 부터 객체를 받는 것이 아니죠. 그렇기 때문에 string화 된 데이타를 new Date를 통해 객체로 만들어 주어야 합니다. 
7) 그림을 그리기 앞서 새로운 데이터에 따라 범위 설정을 다시 해줍니다. 그 후 
8) this.line에 data 인자를 넣어 새로운 그림을 만듭니다. 


 > 참고 : line 그리기

D3.js는 유연하므로 path를 이용한 라인은 3가지의 방법으로 그릴 수 있습니다. 
 
 ----

1)svg.append("path").datum(data).attr("d", line)
2)svg.append("path").data([data]).attr("d", line) 
3)svg.append("path").attr("d", this.line(data)).attr("class", "line")

 ----
 
#### MEVN/4장/sensor/src/views/SensorChart.js  
위의 완성된 Chart.vue를 쓸 부모 컴포넌트입니다. 
```html
<template>
  <div> 
    <div v-for="c in charList" class="chartWrap card">
      <h2>{{c.text}}</h2> 
      <Chart :_key="c.value" :color = "c.value" :key="c.value"></Chart>
    </div> 
  </div>
</template>

<script>
// @ is an alias to /src
import Chart from '@/components/Chart.vue'

export default {
  name: 'SensorChart',
  components: {
    Chart
  }, 
    data() {
      return { 
        charList : [ 
           {"color" : "red", "value": "temp", "text" : "온도"}, 
           {"color" : "green", "value": "wv", "text" : "풍속"}, 
           {"color" : "blue", "value": "humi", "text" : "습도"}, 
        ]
      }
    },
    mounted() { 
    },
    methods: { 
    }  
}
</script>
<style>
.chartWrap{
  display:inline-block;
}
.chartWrap h2{
    border-bottom: 2px solid #aaa;
    padding-bottom: 10px;
    margin: 0;


} 
</style>
```

### 4.7  실시간 센서시각화사이트 : 소켓플러그인제작 

#### MEVN/4장/sensor/src/plugins/socketPlug.js 
우리는 실시간 통신을 합니다. 그러기 위해선 socket.io-client를 client에 설정을 해놔야죠. 그러기 위한 플러그인을 제작합니다. 
```js
import Vue from 'vue';
import io from 'socket.io-client';
export default {
    install(Vue, {
        host,
        port
    }) {
        const socketClient = io(`${host}:${port}`);
        Vue.prototype.$socket = socketClient;
        console.log("complete")
    }
}
```
#### MEVN/4장/sensor/src/main.js 
```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import socketPlugin from './plugins/socketPlug.js'
import config from './config' 
Vue.config.productionTip = false

Vue.use(socketPlugin, {host : config.host, port : config.port}) 
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```
그 이후 위의 예처럼 Vue.use로 socketPlugin을 vue 인스턴스에 할당하면 됩니다. 

#### MEVN/4장/sensor/src/router.js 
```js
import Vue from 'vue'
import Router from 'vue-router'
import SensorChart from './views/SensorChart.vue'  
Vue.use(Router)

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [
    {
      path: '/',
      name: 'SensorChart',
      component: SensorChart
    },
    {
      path: '/map',
      name: 'map', 
      component: () => import('./views/Map.vue')
    },{
      path: '/number',
      name: 'number', 
      component: () => import('./views/Number.vue')
    },{ 
      path: '*',
      name: '404', 
      component: () => import('./views/Lost.vue')

    }
  ]
})

```
참고로 router 구성은 위와 같습니다. 먼저 우리가 할당한 라우터 말고 다른 곳을 들어가면 lost페이지가 뜨게끔 마지막에 *으로 404로 할당한 것을 주의깊게 보시면 됩니다. 

완성된 모습입니다. sensor에 관한 차트가 아름답게 animation화 되어 움직이는 것을 볼 수 있습니다. 

![센서차트](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/4_센서.gif) 
 
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_5장.jpg)  

## 5. 미술작가소개플랫폼 제작
### 5.1 아키텍처
### 5.1.1 아키텍처 설계
### 5.1.2 REST API 설계 - 전시회정보 API
### 5.1.3 CORS 및 주의사항
API를 개발할 때는 CORS를 해제시키고 해야 쉽습니다. 지금 현재 개발 서버는 8080 포트를 쓰고 REST API인 12010이란 포트를 쓴다고 했을 때 CORS를 쓰지 않는다면 그 API 서버의 자원에 대해 접근이 불가능합니다. 따라서 개발할 때는 CORS를 해제하고 개발을 하고 개발이 끝난 후에는 **인증IP및포트**에 한해서 API를 열어주는 것이 필요합니다. 추후 코드를 통해 살펴보겠습니다.
     
### 5.1.4 요청 제한 및 IP 설정 
네이버 [MapAPI](https://www.ncloud.com/product/applicationService/maps)를 보면 월 요청을 제한하고 요청한 갯수에 따라 요금을 부과합니다. 많고 많은 API요청은 서버에 부담과 종료를 가져다 줄 수 있기 때문입니다. 우리도 이번에 네이버 Map API와 비슷한 설정을 가진 API를 만들어 볼 것입니다.
### 5.1.5 MongoDB 스키마 구축
### 5.1.6 디렉토리 설계
### 5.1.7 이벤트 설계 

 > REST API란

----- 

API는 Application Programming Interface의 약어로 다른 어플리케이션에서 현재 프로그램의 기능을 이용할 수 있도록 하는 어떠한 프로그램이자 자원을 가져올 수 있는 하나의 문입니다. 이 API를 통해 어떤 정보를 모두 제공하거나 제한해서 제공할 수도 있습니다. 그 중 REST한 규칙을 지킨 API를 REST API라고 합니다. 

#### REST의 정의
웹에 있는 자원들을 HTTP를 활용하여 효율적으로 얻기위한 아키텍처스타일의 집합을 말합니다. 
기본적으로 웹에 있는 자원들은 URI라는 규칙에 따라 정의되어있고 정한 방법에 따라 그 자원들을 얻거나 수정할 수 있는데 이렇게 얻거나 수정하는 방법들을 좀 더 효율적으로 구현할 수는 없을까 고민이 담긴 집합이며 이를 잘 지킨 아키텍처를 **RESTful하다**라고 합니다.
 
#### 아키텍처 규칙
그럼 어떠한 아키텍처 스타일의 집합일까요? 일단 아래의 6가지 규칙은 지켜야 합니다. 

#### 1. Uniform-Interface : Self-descriptive messages
독립적으로 자원들이 각각 인터페이스를 가져야 한다는 것입니다. 
왜 독립적이야 하는가? 
 - 웹 페이지를 변경했다고 웹 브라우저를 업데이트할 필요는 없다.
 - 웹 브라우저를 업데이트했다고 웹 페이지를 변경할 필요도 없다.
 - HTTP 명세가 변경되어도 웹은 잘 동작한다.
 - HTML 명세가 변경되어도 웹은 잘 동작한다.

즉, 시간이 지나서 클라이언트와 서버가 변경되더라도 언제나 해석 가능하게끔 하는 것입니다. 
Self-descriptive messages이란 각 자원들의 타입에 대하여 **media 타입**을 이용하고 그 타입에 대해서 IANA에 등록해야 합니다. 또한 HTTP Header에 타입을 명시해주어야 합니다. 

 > 하지만 IANA에 일일이 등록하는 것은 힘듭니다. 등록하는 것말고 다른 것들을 거의 다 지켜주면 RESTful 하다라고 할 수 있습니다.

각 메시지(자원)들은 **MIME types**에 맞춰 표현되며 스스로를 표현해야 합니다. 또한 이 데이타가 무엇을 나타내는지 path를 통해 나타내주어야 합니다. 
```js
{
  "path" : "/kundol"
}
```
링크 : [MIME타입이란](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 

#### 1. Uniform-Interface : HATEOAS 구조 
URL 에 따라 다른 페이지를 보여줘야 하는 것은 물론이며, 서버는 클라이언트 요청에 따른 URL RESPONSE를 보내야 합니다.  
애플리케이션은 하이퍼링크에 따라 전이가 되어야합니다. 
```js 
res.json(personObject, [
    { rel: "self", method: "GET", href: 'http://127.0.0.1' },
    { rel: "create", method: "POST", title: 'Create Person', href: 'http://127.0.0.1/person' }
]);
```
이렇게 하거나 data위에 링크를 써야 합니다. 
```js
{
  "link":"http://kundol.net/todos/{id}"
  "data":[]
}
```

#### 2. Stateless
이건 HTTP 자체가 Stateless이기 때문에 HTTP를 이용하는 것만으로도 충족이 됩니다. API를 제공해주는 서버는 세션(session)을 그 서버 쪽에 유지하지 않는다는 의미입니다. 

#### 3. Cacheable 
HTTP 는 본디 캐싱이 됩니다. 새로고침을 하면 304가 뜨면서 원래 있던 js와 css 이미지등을 불러오는 것을 볼 수 있습니다.
이러한 캐싱은 네트워크 요청을 줄여주며 이는 UX향상에 도움이 됩니다. 네트워크 요청시 해당되는 자원들을 복사해서 메모리에 저장해두었다가 또 같은 요청시 네트워크요청을 하지 않고 브라우저메모리에 있던 자원을 다시 반환합니다. HTTP 메서드 중 GET에 한정되어있으며(post요청은 캐싱이 되지 않습니다.) `Cache-Control:max-age=100`이런식으로 한정된 시간을 정할 수가 있으며 이 캐싱된 데이타가 유효한지를 판단하기 위해 `Last-modifed` 그리고 `Etag`를 씁니다.   
`Etag`는 전달되는 값에 태그를 붙여서 캐싱되는 자원인지를 확인해주는 것입니다. 예를 들어 `Cache-Control:max-age=100`으로 형성된 자료는 100초가 지나면 응답이 완료 되었기 때문에 다시 똑같은 자료를 가져올 수 있습니다. 이 때 Etag, 디지털 지문을 사용한다면 똑같은 자원은 캐싱되서 요청을 줄일 수 있습니다 Etag까지 해줘야 완벽한 캐싱이라고 할 수 있습니다. 

 > node.js에서는 npm을 다운받아 `res.setHeader('ETag', etag(body))`이렇게 사용됩니다. 

쿠키는 `public` 또는 `private`로 설정이 가능합니다. 

응답이 `public`으로 표시되면 이와 관련된 HTTP 인증이 구성되어 있고 응답 상태 코드가 정상적으로 캐시할 수 없는 경우에도 캐시가 가능합니다. 대부분의 경우, 명시적 캐싱 정보(예: `max-age`)가 응답이 어떠한 경우든지 캐시가 가능하다고 나타내므로 `public`이 필요하지 않습니다.

반대로, `private` 응답은 브라우저가 캐싱할 수 있습니다. 그러나 일반적으로 이 응답은 단일 사용자를 대상으로 하므로 중간 캐시가 이 응답을 캐시하는 것은 허용되지 않습니다. 예를 들어, 비공개 사용자 정보가 포함된 HTML 페이지는 사용자의 브라우저가 캐시할 수 있지만, CDN은 이 페이지를 캐시할 수 없습니다.
 * 추가 수정예정(조금 더 구체적인 예 추가 CDN) 

#### 4. Client-Server 구조  
클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론 이는 HTTP 를 통해 가능한 구조입니다. 서버에서 HTTP 표준만 지킨다면 웹에서는 그에 따른 화면이 잘 나타나게 됩니다. 서버는 그저 API를 제공하고 그 API에 맞는 비즈니스 로직을 처리하면 됩니다. 마찬가지로 클라이언트에서는 HTTP 로 받는 로직만 잘 처리하면 되는 것입니다.
  
#### 5. Layered System
계층구조로 아키텍처를 만들 수 있다는 것을 뜻합니다. HTTP자체가 계층구조이므로 HTTP를 사용해서 이 특징을 지킬 수 있습니다. 

-------

### URI 규칙
이렇게 규칙을 지켰으면 이제 자원을 표기하는 URI에 아래의 6가지 규칙을 지켜야 합니다.  
1. 동작은 HTTP 메소드로 해야 합니다. 수정 = put, 삭제 = DELETE, 추가 = post, 조회 = get을 이용해야 합니다. 
예를 들어 `/books/delete/1` 이렇게 표기하면 안된다는 것입니다. 
2. 확장자는 표기하지 말아야 합니다.
3. 동사가 아닌 명사로만 표기해야 합니다. **유저가 책을 소유한다**라고 한다면 이런식으로 구성되어야 합니다. `유저/유저아이디/inclusion/책/책아이디`
4. URI는 계층적인 내용을 담고 있습니다.  `/집/아파트/전세` 이런식으로 내려가야 합니다. 
5. 소문자로 쓰며 너무 길경우에는 **-**를 씁니다. 
6. HTTP 응답 상태 코드를 활용합니다.

|  상태코드   | 설명 | 
|:--------|:--------| 
| 200 OK   | 요청이 성공적으로 되었습니다. | 
| 201 Created | 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다 | 
| 400 Bad Request | 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다. | 
| 301 Moved Permanently |  이 응답 코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 새로운 URI가 응답에서 아마도 주어질 수 있습니다. | 
| 401 Unauthorized |  "비인증(unauthenticated)"을 의미합니다. 클라이언트는 요청한 응답을 받기 위해서는 반드시 스스로를 인증해야 합니다. |  
| 500 Internal Server Error |  서버에 오류가 있음을 나타냅니다. | 


### 도서관 REST API 예 
도서관의 REST API를 만들 때의 예제를 들고 마무리 하겠습니다.

node.js express 예입니다.
```js
app.get('/books/') 
// 모든 책을 조회합니다.
app.post('/books/booksid') 
// 책을 생성합니다. 
app.put('/books/booksid') 
// 책을 수정합니다.
app.get('/books/booksid') 
// 특정 책을 조회합니다. 
app.put('/users/userid/books/booksid') 
// 어떤 유저가 특정 책을 빌립니다. 
app.patch('/users/userid/books/booksid') 
// 어떤 유저가 특정 책을 빌립니다. 
```
참고로 `put`과 `patch`의 차이점은 결과값에 있습니다. `put`은 수정된 자원의 전체 결과값 `patch`는 수정된 자원의 그 수정된 부분의 결과값만을 뜻합니다.  

예를 들어 `{"a" : 1, "b" : 2}`가 있을 때 b의 키값에 해당하는 값을 3으로 바꾼다고 합시다. `put`의 경우 `{"a" : 1, "b" : 3}`으로 리턴이 되고 `patch` 는 `{"b" : 3}`이런식으로 바꾼 값만이 리턴되는 것이 특징입니다.  
 
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_부록A.jpg) 

## 부록 A. 안정적인 서버를 위한 구축과정

### A.1 로그시스템
### A.1.1 실시간 로그시스템
### A.1.2 로그 자료조회

### A.2 오류처리 
### A.2.1 모나드이용 예제 
### A.2.2 uncaughtException 처리방법

### A.3 메시지큐 
지금까지 우리는 WebSocket과 polling, long-polling을 통해 실시간통신을 통해 웹 애플리케이션을 구축했습니다. 이 때 우리가 좀 더 고려할 사항은 뭐가 있을까요? 
바로 시스템 장애입니다. 이를 메시지큐를 이용하면 해결할 수 있습니다.  
![메시지큐](/img/20190509_MQ.png)  
서버가 갑자기 죽거나 서버 점검 등으로 다운타임이 발생하는 동안에는 요청을 보낼 수가 없기 때문에 메세지큐, MQ를 이용해야 합니다. 
이외에도 너무 많은 처리를 위해 MQ는 필요합니다. 그저 Client와 동기방식으로 많은 데이터 통신을 하게 되면 병목현상이 생기게되고 서버의 성능이 저하되므로 하나의 메시지큐를 위임하여 순차적으로 처리하게끔 해야 합니다.

 > 다운타임 : 시스템을 이용할 수 없는 시간

### 메시지큐 라이브러리 rabbitMQ 
AMQP(Advanced Message Queueing Protocol)를 활용해 좀 더 쉽게 메세지-큐를 이용해 메세지를 전송/저장/관리하거나 받을 수 있는 기능을 제공하는 메세지 브로커(message broker or queue manager)라는 이름으로 불리는 오픈소스 소프트웨어

### A.3.1 AMQP(Advanced Message Queueing Protocol)를 활용한 메시지큐로 서버불안정화 대비
### A.3.2 메시지큐 만들어보기 
 
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_부록B.jpg)  

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_부록C.jpg) 

![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo_부록D.jpg) 