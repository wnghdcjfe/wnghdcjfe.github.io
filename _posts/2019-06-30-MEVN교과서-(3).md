---
layout: post
title: 'MEVN교과서 (3)'
author: kundol
comments: true
date: 2019-06-30 10:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (3)

---    
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo.jpg)

# 2. MEVN
MEVN은 MongoDB, Express.js, Vue.js 그리고 Node.js를 이용해서 만드는 웹 어플리케이션입니다. MEVN스택이라고 불립니다. 

## 2.1 Node.js
### 2.1.1 Node.js의 기본
Node.js는 Chrome V8 Javascript 엔진으로 빌드 된 비동기 이벤트 주도 Javascript 런타임, 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되며 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적인 서버사이드 플랫폼이자 코드를 실행할 수 있는 Javascript 런타임을 뜻합니다.

자바스크립트 프로그램이 실행되고 있을 때 그 프로그램이 존재하는 공간을 말합니다. 
Node.js를 이용해서 자바스크립트란 언어로 코드를 짜고 프로그램을 동작시켜 간단한 알고리즘이나 게임을 만들 수 있으며 Electron을 통해 데스크톱애플리케이션도 만들 수 있습니다. 

우리는 이 많은 것들을 제공하는 node.js라는 좋은 도구의 특징 중에서 서버사이드 플랫폼이라는 특징을 쓸 것입니다. 

기본적으로 node.js를 이용해 서버를 만들자면 node.js 의 내장 객체 중 하나인 `http`를 이용해야 합니다. 

Node.js가 제공하는 내장객체들의 정보들은 [node.js API](https://nodejs.org/api/) 를 참고하면 됩니다. 

http API는 다음과 같습니다. 첫번째 인자로는 options를 받고 두번째 인자로는 requestlistener를 받습니다. `options`는 넣어도 되고 안넣어도 됩니다. 
보통 `requestlistener` 인자만을 넣습니다. 
```js
http.createServer([options][, requestlistener])
```

브라우저 URL에 http://127.0.0.1:12010/ 을 치면 **안녕하세요 MEVN프로젝트입니다.** 라는 문자열을 반환하는 서버를 만들었습니다.  

##### MEVN/1장/simple_http.js
```js
const http = require('http');    
const PORT = 12010; 
const server = http.createServer((req, res) => {  
  res.setHeader('Content-Type', 'text/plain; charset=utf-8'); 
  res.end('안녕하세요 MEVN프로젝트입니다.'); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

이 책에서 만드는 프로젝트에서는 JSON이라는 형식의 데이타를 주고 받습니다. http://127.0.0.1:12010/ 라는 요청이 들어오면 JSON을 반환하는 서버를 만들어봅시다. 
이름이라는 key를 가지고 큰돌이라는 value를 가지는 `JSON객체`를 반환하는 서버를 만들었습니다.  
##### MEVN/1장/simple_http2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

 > 참고 : json이란

json이란 JavaScript Object notation으로써 경량 데이타 교환방식을 뜻합니다. 읽고 쓰기 쉽고 파싱하며 생성하기 쉬운 장점이 있습니다. 
`{"이름" : "큰돌"}` 이러한 구조를 가진 json을 json object라고 하며`[{"이름":"큰돌"},{"이름":"큰돌2"}]`의 구조를 가진 JSON을 JSON Array라고 합니다.
JSONObject로 만들어야 key를 통해 value를 참조할 수 있으며 JSON.parse(obj)라는 메소드를 이용합니다. 반대로 문자열을 만들 때는 `JSON.stringify(obj)`라는 메소드를 사용합니다. 

JSON에는 주석이 들어갈 수는 있지만 주석이 들어가지 않는 것을 권장합니다. 
기본 자료형은 다음과 같습니다. Number, String, Boleanm, Array, Object, null 입니다. 

이 기본 자료형이 아닌 것들은 **직렬화**가 되지 않습니다. 직렬화란 외부의 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술을 말합니다. JSON직렬화는 JSON.stringify(obj)를 통해 문자열로 만들어 구현할 수 있습니다. 

예를 들어 `JSON.stringify({ "이름": undefined })` 이 객체는 직렬화가 되지 않습니다. 
확장성을 위해 undefined로 초기화하는 것을 권장하지 않습니다. 아래의 예처럼 `obj['나이2']`로 `undefined` 값으로 초기화 된 것을 참조 할 수 있지만 권장하지 않습니다. null이나 0, -999, 프로젝트에서 약속된 초기값으로 초기화하는 것을 권장합니다.

.을 통해 해당 value에 접근이 가능합니다. 변수를 통해 value에 접근하는 것은 []를 씁니다. 변수를 쓰지 않는 것은 .을 쓰며 변수를 통해 쓰는 것은 [name]을 통해 참조하는 것을 권장합니다.

 > 이렇게 코드를 짤 때 규칙을 정하는 것은 매우 중요합니다!
 
##### MEVN/1장/simple_json.js
```js
const obj = {
  "이름" : "큰돌", 
  "나이" : 27,
  "나이2" : undefined
}
console.log(obj.이름) //큰돌
const _name = "이름"
console.log(obj[_name]) //큰돌
console.log(obj['이름']) //큰돌
console.log(obj['나이2'])  
```  

### 2.1.2 Pm2 라이브러리 설정
만약 node.js로 만든 서버가 죽는다면 어떻게 해야할까요? 

다시 서버에 접속해 node 서버.js를 하면서 킬 수도 있지만 너무나도 수동적입니다. node.js로 만든 서버를 관리하기 위한 process관리자 라이브러리인 Pm2를 사용하면 쉽고도 아름답게 관리할 수 있습니다.

 > 참고 : forever도 있지 않나요? 

서버가 죽으면 다시 켜주는 forever이라는 라이브러리도 있지만 pm2가 멈춘 프로세스관리, 좀 더 깔끔한 UI, CPU클러스터 모드, 모니터링측면에서 더 좋습니다.


일단 먼저 죽는 서버를 만듭니다. 실무에서는 잘못된 데이타가 들어왔을 때 필터를 안해주거나 예상치 못한 데이터에 관한 로직을 짜지 않았을 경우 애러가 발생되며 그 애러는 서버를 죽게 만듭니다. 아래의 코드는 `JSON.parse`를통해 이상한 문자열을 JSON object로 만들다가 서버가 **죽는 코드**입니다. 

##### MEVN/1장/simple_pm2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
}); 

setTimeout(()=>{ 
  //애러를 발생시켜서 1초마다 서버가 죽게 만듭니다.
  JSON.parse("{Z")
}, 1000)
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
실행을 시키면 1초만에 서버가 죽는 것을 볼 수 있습니다. 하지만 **pm2**로 구동을 시키면 서버가 죽어도 자동으로 살아나는 것을 볼 수 있습니다. 서버가 죽으면 자동으로 서버를 무한으로 키는 프로그램입니다. 
살리는 것을 볼 수 있습니다. 
그렇다면 PM2를 설치해보도록 하겠습니다.  

`npm install -g`의 -g는 global로 전역으로 설치한다는 뜻입니다. 이렇게 전역으로 설치한 후애는 `pm2`라는 명령어를 쓸 수 있습니다. 

```
npm install pm2 -g
```

pm2를 이용해 전에 만든 simple_http를 구동시켜봅시다.  이렇게 구동하면 절대 죽지 않습니다. 정확히 말하면 죽지만 좀비처럼 다시 되살아나기를 반복합니다. 우리가 해야 할 일은 이렇게 임시조치로 살아나는 서버로 긴급상황을 막고 추후 오류를 해결하면 되는 겁니다.
```
pm2 start simple_pm2.js
```

구동이 된 후 `pm2 list` 를 통해 깔끔한 UI로 어떠한 앱이 실행되었나 보여주며 cpu, 메모리 사용량 등을 볼 수 있습니다. 
![pm2 list화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_list.PNG) 

한 앱에 대한 실시간 모니터링은  `pm2 monit`를 치면 다음과 같은 화면이 나오면서 할 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monit.PNG) 

종료나 pm2 관리하는 list에서 삭제는 다음과 같은 명령어로 할 수 있습니다. 
```js 
// 서버중단
// pm2를 이용한 서버 중단 Name, 또는 ID로 중단할 수 있습니다. 
pm2 stop simple_pm2
pm2 stop 0

// 삭제
pm2 delte simple_pm2
pm2 delte 0 
```

이외에도 `pm2 monitoring` 이라는 명령어를 사용하고 회원가입, 로그인을 하면 특정 웹애플리케이션이 띄워지고 그 안에서 CPU사용량, 메모리, HTTP로그, 이벤트 루프, 사용되는 Heap Size 등을 더 아름답게 확인할 수 있습니다. 하지만 이는 Free-trial버전으로 2주간 무료이며 그 이후에는 유료로 쓸 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monitoringUI.PNG) 

단순히 자동적으로 서버 재시작이 가능하고 `pm2 monit`을 통해 왠만한 모니터링을 할 수 있으며 클러스터링또한 가능하다는 점에서 pm2는 안전한 서버구동에 있어 좋은 선택입니다. 또한 애러가 생기면 등록된 이메일로 애러가 생겼다. 서버가 죽었다. 알림메세지까지 주니 관리측면에서 아주 좋습니다.

 > 물론 서버가 안 죽게 만들어야 하는 것은 필수입니다.  


## 2.2. Express
node.js 에서 동작하는 웹개발 프레임 워크 중 많이 쓰이는 유연한 프레임워크입니다.  
핵심기술로는 이 3가지가 핵심기술입니다.  

1. HTTP 요청에 응답하는 **미들웨어** 설정가능
2. HTTP 메소드, URL 기반으로 하는 라우팅설정  
3. 쉬운 서버구동

이 있습니다. 이외에도 Jade란 템플릿을 통해 쉽게 웹페이지를 생성할 수 있지만 이 책에서는 사용하지 않으므로 설명을 하지 않습니다.

 > 라우팅 : 클라이언트가 요청 및 요청 예정되는 경로를 설정하는 작업


 > 미들웨어 : 중간에 껴놓은 소프트웨어, 부가적인 처리, 기능을 담당합니다. 여기서는 네트워크요청처리시에 해당되는 처리기능 담당 소프트웨어를 말합니다.

## 2.2.1. HTTP 요청에 응답하는 미들웨어 설정가능
```js
const app = express();

// --- 1번로직

app.use((req, res, next)=>{  
  console.log('Time:', Date.now());
  next();
});

// --- 2번 로직
``` 
이렇게 1번과 2번 로직 사이에 끼어놓는 로직을 미들웨어라고 합니다. `use`를 통해 미들웨어가 모든 요청에 대해 미들웨어를 추가했습니다. `app.get` 등을 이용해 특정한 HTTP 요청을 다루는 것이 아닌 use를 통해 모든 요청을 처리할 수 있습니다. 

모든 요청에 대해 중간에 거는 미들웨어를 추가하는 것입니다. 이를 이용하면 이런게 가능합니다. 

```js
var logger = require('morgan');
app.use(logger('tiny'));
```

이렇게 morgan이라는 로그 시스템 라이브러리를 놓게 되면 모든 요청에 대한 로그를 쉽게 파악할 수 있습니다. 


## 2.2.2. HTTP 메소드, URL 기반으로 하는 라우팅설정  
말그대로 라우팅설정입니다. URL인 users/dad/books/dad의 요청을 req.params로 받아서 쉽게 처리할 수 있습니다. get이라는 요청을 처리했는데  
예를 들어 `users/love/books/something`라는 get 요청시  `req.params`에는 `{"userId":"love","bookId":"something"}`라는 값이 담기게 됩니다. 이를 통해 우리는 JSON객체로 받아서 로직을 구현하면 됩니다.

또한 get요청 말고 post, put 등 다른 HTTP 메소드의 요청 또한 처리할 수 있습니다.
```js
app.get('/users/:userId/books/:bookId', (req, res)=>{
  res.send(req.params)
})
// users/dad/books/dad 요청시
//{"userId":"dad","bookId":"dad"}
```

예2) /book이라는 url의 get, post, put 요청을 처리하는 함수
```js
app.route('/book')
  .get((req, res)=> {
    res.send('Get a random book')
  })
  .post((req, res)=> {
    res.send('Add a book')
  })
  .put((req, res)=> {
    res.send('Update the book')
  })
```

## 2.2.3. 쉬운 서버구동
`app.listen(12010)` 만으로 쉽게 서버를 구축할 수 있습니다. 예제 코드입니다. 

 > 항상 이렇게 app이라는 객체에 담아서 로직을 짜는 것이 중요합니다. 


### 2장 simple_express.js
```js
const express = require('express');
const path = require('path')
const app = express();
const _path = path.join(__dirname, './dist')
console.log(_path)
app.use('/dist', express.static(_path))  
app.listen(12010, ()=> {
  console.log('너의 서버는? 12010!');
});
``` 
/dist라는 요청을 받았을 때 dist폴더의 index.html을 보여주는 서버를 만들었습니다.
`__dirname`은 JS가 실행되는 현재 위치를 가리키는 Node.js의 전역 변수입니다. `path.join`을 사용해서 현재 서버를 구동한 위치로부터의 dist폴더를 제공한다라는 것을 아름답게 만들수 있습니다.

여기서 `express.static`은 정적 컨텐츠를 사용자에게 제공할 때 사용되는 메서드입니다. 특정 path에 해당하는 자료들을 사용자가 접근가능하게끔합니다.

node.js의 path라는 모듈은 파일, 디렉토리의 관한 path들을 조작할 수 있는 좋은 모듈입니다. 
path를 다루는 메서드 중 많이 쓰이는 메서드는 join과 resolve입니다. 

| 메서드 | 설명 | 
|:--------|:--------|
| resolve	| 받은 인자들을 통해 절대 경로를 반환합니다.	|
| join	| 받은 인자들을 연결합니다.	| 

```js
const path = require('path')
const _resolve = path.resolve('.', 'dist', 'css')
const _join = path.join(__dirname, 'dist', 'css')
console.log(_resolve)
console.log(_join)
// C:\Users\LUCID\Desktop\개발\dist\css
// C:\Users\LUCID\Desktop\개발\dist\css

```

이렇게 서버를 구동한 후, http://127.0.0.1:12010/dist 에 가보면 아름다운 제 처음 서버가 완성됩니다. 

#### Q : 그렇다면 /test서버에 제 index.html을 보기 위해서는 어떤 코드를 수정해야 할까요? 

![2_simple_server](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_simple_server.PNG) 

## 2.3. Vue.js
### 2.3.1 SPA와 Vue.js  
Vue.js는 자바스크립트 프레임워크 중 인기있는 프레임워크 중 하나입니다. 재사용가능한 컴포넌트, 정말 쉬운 문법,  React보다 빠르며, 중앙 집중식 상태관리 저장소인 vuex, Angular의 장점만 뽑은 점 등이 장점입니다. 저는 Vue.js가 React.js보다 반드시 더 커질 것이라고 믿는 개발자 중 한명입니다. 쉽고 빠르고 좋습니다. 일부 개발자들은  Vue.js가 큰 프로젝트에서는 맞지 않는다고 하지만 저는 Vue.js가 나온 초창기부터 도전적으로 2년짜리 큰 프로젝트에 Vue.js를 썼으며 정말 안전하고 성능도 좋은 결과물을 만들어냈습니다.  

 - [기본가이드](https://vuejs.org/v2/guide/)
 - [DEEPDIVE](https://medium.com/@oneminutejs/a-deep-dive-in-the-vue-js-source-code-0-table-of-contents-170dcc3c8ec)

이 책에서는 Vue.js의 기본가이드를 설명해주지는 않습니다. 
위의 기본가이드를 보시면 마스터할 수 있습니다.  
 
Vue.js는 기본적으로 단일 페이지 애플리케이션(Single Page Application, SPA)이란 특징을 가지고 있습니다. 
SPA는 기본적으로 단일 페이지로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다는 장점이 있습니다.

link tag를 사용하는 전통적인 웹 방식은 새로운 페이지 요청 시마다 정적 리소스가 다운로드되고 전체 페이지를 다시 렌더링하는 방식을 사용하므로 새로고침이 발생되어 사용성이 좋지 않습니다. 그리고 변경이 필요없는 부분를 포함하여 전체 페이지를 갱신하므로 비효율적입니다. 

### 2.3.2 SPA의 장점 
SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하고 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 반응속도 등 UX가 향상되어 네이티브 앱과 유사한 사용자 경험을 제공할 수 있습니다. 

### 2.3.3 SPA의 단점, 1. 초기구동속도
초기 구동 속도, SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느릴 수 밖에 없습니다. 

### 2.3.3 SPA의 단점, 2. SEO문제
SPA는 서버 렌더링 방식이 아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이기 때문에 자바스크립트를 구동하지 않은 웹크롤러에 대해서는 크롤링이 되지 않습니다. 

 > SEO와 초기구동속도를 고려한다면 개발할 당시에는 SPA로 개발을 하고 배포할 때는 서버사이드 렌더링처럼하는 프레임워크인 NUXT 등을 사용하면 됩니다. 

### 2.3.4 Vue-cli 설정
자 이제 Vue.js를 이용한 프로젝트를 구축해보도록 하겠습니다.  
먼저 Vue-cli를 설치합니다.`npm install -g @vue/cli-init`

`vue create sensor` 을 통해 프로젝트를 생성합니다. 
![vuecli셋팅](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_vuecli.PNG) 
이렇게 셋팅합니다. 

이렇게 설정한 후 sensor폴더에 들어가 README.md를 봅니다. 
`npm install` 로 의존성 라이브러리를 모두 다운받은 후 `npm run serve`로 개발환경을 실행할 수 있고 `npm run build`로 빌드를 할 수 있습니다. 
`npm install` 후 `npm run serve`로 개발환경을 실행시킵니다. 

![시작되는화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_vue-cli-start.PNG) 

자 처음으로 Vue-cli로 만들어진 앱이 탄생했습니다! 이제 이걸로 개발을 하면 됩니다. 

### 2.3.5 Webpack 구조

![webpack](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_webpack.PNG) 
자 이제 들어가기 앞서 우리가 했던 것이 뭔지를 알아보도록 하겠습니다. 우리는 Vue-cli와 Webpack이라는 것을 이용해서 테스트 개발환경을 구축했습니다. 이렇게 하면 Vue로 모듈적으로 개발을 하고 빌드할 때는 html, js, css **정적파일**로 번들이 되어 나오게 됩니다.

Webpack이란 웹에서 사용되는 모든 자원(html, js, css, vue, img) 등을 번들링 해주는 도구입니다. 번들링이란 여러개의 파일들을 하나의 파일로 묶는 포장작업을 의미합니다. 

이를 활용하면 개발할 때는 여러개의 모듈로 개발을 해서 쉽게 개발을 하다가 배포할 때는 하나의 파일로 최적화를 시켜서 배포를 할 수 있습니다. 

Gulp나 Grunt도 이러한 포장작업 도구들이지만 Webpack이 제일 좋습니다.

웹에는 Vue라는 확장자가 있을 수 없습니다. 우리가 볼 수 있는 화면들은 죄다 html, js, css로 이루어져 있습니다. vue라는 확장자는 없죠. 하지만 개발을 할 때는 편리하게 vue라는 도구를 쓰고 그 다음 배포할 때 우리가 볼 수 있는 html, js, css로 확장자를 바꿔서 제공하는 것이죠. 

이를 번들이라고 하는데 하나의 js, css파일을 만들어서 네트워크요청을 최소화하는 것이 특징입니다. 

만약 webpack에서 번들 또는 테스트환경을 설정할 때 커스터마이징이 필요하다면 Vue-cli2를 사용하는 것이 좋습니다. 물론 Vue-cli3에서도 커스터마이징을 제공하지만 완전한 커스터마이징을 제공하지 않습니다. 

어떤 명령에 따라 어떤 파일을 넣고 바꾸고 webpack 을 통해 번들한다면 vue-cli2를 이용하는 것이 좋습니다. 

## 2.4. MongoDB
MongoDB란 NoSQL DBMS의 한 종류이자 NoSQL도큐먼트 지향 데이터베이스 시스템입니다. 

MySQL 처럼 전통적인 테이블-관계 기반의 RDBMS가 아니며 SQL을 사용하지 않습니다. 유연하게 데이타를 저장할 수 있으며 Binary JSON형태인 BSON으로 저장이 되며 데이터 처리를 할 때는 JSON으로 처리를 할 수 있습니다. 

대용량INSERT에 대한 요건이 커지면서 NOSQL DBMS가 도입 시작되었고 방대한 양의 데이터를 충분히 빠른 속도로 처리할 수 있는 데이터베이스이자 먼저 NoSQL, Not Only SQL이며 관계형 DB가 아닌 유동인 DB라는 특징이 있습니다. 

NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것(Scale-out : 수평적 확장)을 목표로 등장하였습니다. NoSQL의 등장으로 작고 값싼 장비 여러 대로 대량의 데이터와 컴퓨팅 부하를 처리하는 것이 가능하게 되었고 유연성, 확장성 등이 RDBMS에 비해 좋습니다.

### 2.4.1 MonogoDB의 구조 
![몽고DB구조](/img/20190509_m.png)
여기서 중요한 부분은 스토리지엔진입니다. 이 엔진은 디스크에서 데이터를 어떻게 가져오고 어떻게 최적으로 저장할 것인지를 결정합니다. 3.2이상은 wiredTiger가 default이며 이외에도 MMAPv1, RocksDB가 있습니다.

서버안에 MongoDB자체가 전체 메모리의 메모리 버퍼를 전체의 50%를 쓰게 됩니다. 때문에 한 서버안에 프라이머리 / 세컨더리 **두개 절대 놓지 않는 것**이 중요합니다.

![MongoDB트랜젝션](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_MongoDBTransaction.png)  
트랜젝션이 일어나게 되면 `Jounal log`에 쌓이고 `Buffer pool`로 들어가 체크포인트, 그리고 `eviction`작업이 일어나게 됩니다.
이 때, 메모리가 부족할 경우 `eviction`이 잘되지 않고 메모리버퍼를 아예 지우는 작업을 하고 심할 경우 데몬이 죽게 됩니다.  
 - eviction : 메모리버퍼에서 필요없는 데이타를 삭제하는 작업
 - 체크포인트 : 메모리 버퍼와 디스크사이의 데이터 불일치를 해소하기 위해 메모리에서 디스크로 data 동기화를 하는 작업

 > 저널링 : 변경이록을 저장해서 롤백을 할 수 있도록하기 위함, 이 롤백은 ACID 중 지속성에 해당하는 것입니다.


### 2.4.2 MonogoDB 특징
MongoDB의 특징은 정말 많지만 크게 10가지만 뽑아 보았습니다.  

1. 그리고 한개의 DATA 구조는 key - value 형태로 이루어져 있으며 _id라는 고유한 아이디를 가집니다. 
2. 스키마 없이 데이터모델을 구현하지 않은채 그냥 유동적으로 데이타를 삽입할 수 있습니다. 
- 스키마 : 데이타베이스를 구성하는 속성, 관계 등 데이타 값들이 갖는 type들을 명시 해놓은 것을 말합니다. 
- 장점 : 다양한 서비스로부터 데이타를 쌓을 때 유동적으로 쌓을 수 있음
- 단점 : RDBMS인 경우에는 `int, char[14]`인 경우에는 18바이트 그러나 몽고디비는 한 도큐먼트로 칼럼이름또한 바이트에 추가가 되기때문에 바이트가 더 커집니다. 즉, 공간적인 소모가 많습니다.
3. `min, max, aggreate, mapReduce` 등 강력한 함수로 데이터를 뽑아내고 조합하는 등의 활동을 할 수 있습니다. `data`들을 모아서 초최대값을 뽑아내거나 최소값 등등의 행위를 할 수 있습니다.  
4. `ReplicaSet`을 이용해 이중화가 가능합니다. 
5. `BJSON(Binary Json)` 형태로 저장합니다. json 형태가 아니며 로직을 구현할 때는 JSON도큐먼트를 인자로 사용합니다.
6. `geoSpartial` 인덱스를 써서 `2Dimension`좌표탐색에 활용이 가능합니다. 이것을 인덱싱이 자유롭다고 합니다.
7. `$lookup`을 통한 `collection join`이 가능합니다.
8. 쿼리정렬시 메모리 관련 애러가 발생할경우 다음과 같이 해결할 수 있습니다.
- 정렬 작업에 인덱스를 활용하고 적절하고 `limit`를 건다.
- 메모리 공간을 크게 놓는다. 
- `find`명령어 대신 `aggregate`명령을 사용하고 `allowDiskUse`옵션을 `true`로 설정하는 것 
9. 도큐먼트에서 _id 라는 필드가 자동으로 그 도큐먼트의 프라이머리 키로 선정됩니다. 나머지의 인덱스는 세컨더리 키로 선정됩니다
10. 인덱스의 기본 정렬은 항상 오름차순으로 구현돼 있지만 이 인덱스를 읽는 방향에 따라서 오름차순 또는 내림차순의 효과를 얻을 수 있으며 인덱스에서 각 필드의 정렬을 오름차순, 내림차순 으로 결정할 수 있으며 대부분의 인덱스는 B-Tree를 적용합니다.(인덱스 정렬은 B-tree에서만 가능) 

 > 이 외 별로 중요하진 않지만 알아두면 좋은 MongoDB 지식들

1. 3.0, 3.2.x 이하 버전에서는 WireTiger 엔진 사용시 문제 발생 3.4 이상버전을 권장합니다.
2. Background Index생성시 DB 자체에 Lock이 걸리며 쿼리지연이 발생되는데 이는 주로 새벽에 생성됩니다.
3. TDE 플러그인을 통해 엔터프라이즈버전에서 제공하는 보안적용이 가능합니다. 이 보안적용은 응용프로그램으로 보안이 가능(`bcrypt`로 암호화 하는 것)하지만 범위검색의 경우 수행이 불가한 것을 해결해줍니다.
4. 3.2이상 wired Tiger엔진이 default로 사용됩니다.
- LSM_Tree(로그 기반 병합트리)를 이용 읽기 성능을 포기하고 그만큼의 저장 성능을 향상시킨 솔루션 / 느린 읽기 성능을 보완하기 위해 블룸 필터를 사용 
5. 샤딩환경에서 index 설정시 각 샤딩환경안에서만 유니크합니다. 
6. Mongoose는 빠르지가 않아서 성능에 민감하다면 권장하지 않으며 Node.js 2.x 드라이버를 권장합니다. (3.x는 커넥션 문제가 발생됩니다.) 하지만 Mongoose를 많은 기업이 사용합니다.
 > 참고 : 같은 NoSQL인 Hbase와 비교

조회조건에 따라서 세컨더리 인덱싱이 필요하는데 Hbase는 그걸 하지 못하며 하둡에 올라가서 물리적으로 분리가 되어있으나 MongoDB는 샤드 단위로 논리적으로 분리가 되어있으며 wired tiger로 높은 수준의 ACID를 할 수 있다. 또한 REST API를 사용하니까 편리하게 JSON을 제공할 플랫폼이 필요한데 이를 위해 MongoDB가 적합합니다. **JSON 타입의 데이타를 주고받는다**면 MongoDB는 좋은 선택입니다.  

 > 참고 : MongoDB의 ObjectId

각 document는 _id라는 고유한 키를 갖는게 특징입니다. 각 document를 생성하면 _id라는 primary key가 생성됩니다. 이외에 저장이 되는 키값은 secondary key로 저장됩니다.  
이 키는 12byte로 아래로 구성이 됩니다. 
 1. 4-byte의 초단위의 시간
 2. 5-byte의 랜덤value
 3. 3-byte의 random value로 부터 순차적인 값 
  
### 2.4.3 MongoDB의 한계
1. BSON document로 저장이 되는데 **최대 16mb의 크기**를 가지며 이 이상일 경우에는 GridFS API를 통해 저장을 해야 합니다. 또한 **리턴되는 result또한 16mb 이하**여야 합니다. 
2. 또한 BSON document **깊이의 최대는 100level 까지**입니다. 
3. db의 **name은 64자**보다 작아야 합니다. 
4. index의 **사이즈는 1024byte보다 작아야** 합니다. 
 
## 2.4.4 Mongoose와 MongoDB node.js 드라이버 성능비교
node.js를 이용해 mongoDB를 쓰려면 라이브러리가 필요합니다. 대표적으로 mongoose와 mongoDB node.js 드라이버가 있습니다. 드라이버가 더 빠르고 쓰기에는 mongoose가 더 쉽습니다. 또한 드라이버의 경우 3.x는 커넥션 부분의 버그가 있다고 알려져있어서 production모드에서 2.x를 많이 쓴다고 알려져있습니다. mongoose를 쓰는 기업들도 많지만 성능에 민감하다면 mongoDB node.js 드라이버를 써야 합니다. 

그렇다면 어느정도 성능차이가 나는 것일까요? 한번 해보겠습니다. 


## 2.4.5 MongoDB node.js 드라이버를 이용한 CRUD

## 2.4.6 aggregate와 mapReduce 성능비교 
MongoDB에서의 집적된 결과물을 내기 위한 방법은 크게 2가지입니다.
 - aggregate
 - mapReduce 

이외에 수작업으로 map, filter, reduce를 이용해서 만들 수도 있지만 성능상 좋지 않은 선택입니다. 예를 들어 어떠한 값을 추출한다고 했을 때 그 document들을 모두 메모리상에 올리고 그 다음에 작업하는 것보다는 아예 monogoDB에서 주어지는 API를 사용하는 것이 더 빠를 것입니다. 

### 1. aggregate
pipeline기반의 프레임워크입니다. 여러단계의 파이프라인을 통해서 직접된 결과물을 낼 수 있습니다. 또한 mapReduce 대신 쓰일 수 있습니다. 

#### aggregate와 mapReduce의 차이
 - mapReduce가 더 유연하다 : aggregate는 컴파일된 C++코드를 실행하고 mapReduce는 javascript해석기로 실행되므로 mapReduce가 더 유연하고 더 복잡한 것을 구현해낼 수 있습니다.
 - aggregate가 더 빠르다 : mapReduce작업은 BSON이 지원하는 32, 64비트 정수에 대해 자바스크립트 정수타입인 64bit IEEE754방식으로 변환해서 JSON직렬화 과정을 수행해서 로직을 수행하고 그 다음 다시 BSON으로 변환해야 하기 때문에 느립니다. 하지만 aggregate는 BSON에 이러한 변환작업을 가하지 않고 쿼리를 수행합니다. 그래서 약 10배정도 빠르다고 합니다. (다른 분들의 테스트결과를 보면 약 3 ~ 5배정도 빠릅니다.)
 - 상황에 맞게 쓰자 : 더 복잡한 상황의 경우 mapReduce를 쓰는 게 좋고 그렇지 않을 경우는 aggregate를 쓰는 것이 좋습니다. 예를 들어 매시간마다 최대, 최소치를 뽑고 십다면 mapReduce를, 전체시간 중 1분간격의 데이타로 어떠한 결과물을 만들어내는 경우 aggregate를 쓰는 것이 좋습니다. 물론 test를 해서 결정을 해야 합니다.
 
두개 다 공통적으로 `console.log`가 먹히지 않습니다. MongoDB 내부에서 동작하기 때문입니다. 하지만 `print()` 또는 `--logpath D:\path\to\log.txt`로 디버깅할 수 있으며 MongoDB Shell을 통해 디버깅을 합니다. 

 * 필자는 Shell을 통해 디버깅을 합니다.

예제
```js
//status라는 키가 a라는 것만 찾아서 total이라는 amount라는 키를 가진 값을 모두 더한 도큐먼트를 생성한다.
db.orders.aggregate([
	{$match : {status : "a"}}, 
	{$group : { _id : "$cust_id", total : {$sum : "$amount"}}}
])

{ "_id" : ObjectId("512bc95fe835e68f199c8686"), "author" : "dave", "score" : 80, "views" : 100, "time" :new Date(2019, 5, 9, 9, 43, 10)}
{ "_id" : ObjectId("512bc962e835e68f199c8687"), "author" : "dave", "score" : 85, "views" : 521, "time" :new Date(2019, 5, 9, 9, 44, 10)}
{ "_id" : ObjectId("55f5a192d4bede9ac365b257"), "author" : "ahn", "score" : 60, "views" : 1000, "time" :new Date(2019, 5, 9, 9, 45, 10)}
{ "_id" : ObjectId("55f5a192d4bede9ac365b258"), "author" : "li", "score" : 55, "views" : 5000, "time" :new Date(2019, 5, 9, 9, 46, 10) }
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b259"), "author" : "annT", "score" : 60, "views" : 50,"time" :new Date(2019, 5, 9, 9, 47, 10)}
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25a"), "author" : "li", "score" : 94, "views" : 999, "time" :new Date(2019, 5, 9, 9, 48, 10)}
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25b"), "author" : "ty", "score" : 95, "views" : 1000,"time" :new Date(2019, 5, 9, 9, 49, 10) }

//group을 통해 하나의 값으로 만들 수 있다. 
db.articles.aggregate( [
  { $match: { $or: [ { score: { $gt: 70, $lt: 90 } }, { views: { $gte: 1000 } } ] } },
  { $group: { _id: null, count: { $sum: 1 } } }
]);

//group을 하지 않으면 좀 더 복잡한 쿼리를 만들 수 있다.
db.companies.aggregate([
  {$match: {author: "dave"}},
  {$sort: {author: 1}},
  {$skip: 10},
  {$limit: 5},
  {$project: {
    _id: 0,
    author: 1}}, 
])

//이렇게 좀 더 복잡하게 할 수 있다. time의 값을 분단위로 뽑아내서 minute라는 것을 만들고 0초마다의 데이타를 뽑아낸다.
db.companies.aggregate([
  {$match: {score: {$gte : 1, $lte : 100}}},
  {$sort: {author: 1}},
  {$skip: 10},
  {$limit: 5},
  {$project: {
    _id: 0,
    time : 1, 
    author: 1, 
    minutes : {$minute : "$time"} 
 }}, 
 {
     $match : {$minutes : {$eq : 0}}
 }
])

```

### 2. mapReduce  
좀 더 복잡한 쿼리를 구현할 수 있습니다.
```js
db.orders.mapReduce(
	function() {emit(this.cust_id, this.amount); }, 
	function(key, values){ return Array.sum(values)}, 
	{
		query : {status : "a"}, 
		out : "order_totals"
	}
) 
```

자 그렇다면 aggregate와 mapReduce 성능비교는 어느정도 나는 것일까요?

앞서서 aggregate와 mapReduce의 예제들을 조금씩 살펴보았습니다. 그렇다면 좀 더 자세히 살펴보도록 하겠습니다. 

## 2.4.7 aggregate와 mapReduce 예제와 성능비교



> 참고 : DB에 필요한 지식들

#### 샤딩
데이터베이스 서버를 확장하려면 데이터베이스의 데이터가 여러 서버로 분산될 수 있게 미리 응용 프로그램을 설계하고 개발하는 것을 말합니다.
 - 스케일 업 : 단일서버 증가
 - 스케일 아웃 : 여러대의 서버로 확장  

#### ACID
ACID(원자성,일관성,독립성,지속성)는 데이터베이스 트랜젝션이 안전하게 수행되는 것을 보장하는 특성의 집합입니다. 데이터베이스에서 데이터에 대한 하나의 논리적 실행단계를 트랜잭션이라고 합니다.

 - 원자성(Atomicity): 트래잭션과 관련 된 일들이 모두 수행되었는지 아니면 모두 실행이 안되었는지를 보장하는 능력 
 - 일관성(Consistency) : 시스템이 가지고 있는 고정요소는 트랜잭션 전과 후가 동일해야 함
 - 독립성(Isolation) : 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음(참조를 하지 못한다)
 - 지속성(Durability) : 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있음

#### DR
Disaster Recovery 서비스는 재해 복구 시스템입니다. 

IDC별, 전산실별, 지점별 등 지역적으로 분리된 서버들에 대해 무정지 서비스 가능하게 하며 데이터의 이중화 구성이 가능합니다. 갑작스런 네트워크의 단절, 네트워크 노드의 불안정, 장비의 다운, 정전 등으로 인한 문제를 해결합니다. auto failover도 같은 뜻입니다. 

 > IDC : 인터넷 데이터 센터(Internet data center)
 
#### 쿼리튜닝 
쿼리를 튜닝한다는 것은 처리에 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말합니다.
인덱스 선택을 얼마나 많이 하느냐 / 필요한 것 대비 얼마나 많은 도큐먼트를 읽느냐에 따라 **잘하느냐를 판단**할 수 있습니다. 