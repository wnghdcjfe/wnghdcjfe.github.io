---
layout: post
title: 'MEVN교과서 (3)'
author: kundol
comments: true
date: 2019-06-30 10:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (3)

---    
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo.jpg)

# 2. MEVN
MEVN은 MongoDB, Express.js, Vue.js 그리고 Node.js를 이용해서 만드는 웹 어플리케이션입니다. MEVN스택이라고 불립니다. 

## 2.1 Node.js
### 2.1.1 Node.js의 기본
Node.js는 Chrome V8 Javascript 엔진으로 빌드 된 비동기 이벤트 주도 Javascript 런타임, 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되며 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적인 "서버사이드 플랫폼, 코드를 실행할 수 있는 Javascript 런타임"즉, 자바스크립트 프로그램이 실행되고 있을 때 그 프로그램이 존재하는 공간을 말합니다. 
Node.js를 이용해서 자바스크립트로 코드를 짜 프로그램을 동작시켜 간단한 알고리즘이나 게임을 만들 수 있으며 Electron을 통해 데스크톱애플리케이션 등 정말 많은 것을 만들어 낼 수 있습니다. 

많은 것들을 제공하는 node.js중에서 node.js 의 내장 객체를 이용해서 웹서버를 만들어 볼 것입니다. 바로 `http` 내장객체입니다. 
Node.js가 제공하는 내장객체들의 정보들은 https://nodejs.org/api/ 를 참고하면 됩니다. 

http API는 다음과 같습니다. 첫번째 인자로는 options를 받고 두번째 인자로는 requestlistener를 받습니다. `options`는 넣어도 되고 안넣어도 됩니다. 
보통 `requestlistener` 인자만을 넣습니다. 
```js
http.createServer([options][, requestlistener])
```

브라우저 URL에 http://127.0.0.1:12010/ 을 치면 **안녕하세요 MEVN프로젝트입니다.** 라는 문자열을 반환하는 서버를 만들었습니다.  

##### MEVN/1장/simple_http.js
```js
const http = require('http');    
const PORT = 12010; 
const server = http.createServer((req, res) => {  
  res.setHeader('Content-Type', 'text/plain; charset=utf-8'); 
  res.end('안녕하세요 MEVN프로젝트입니다.'); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

이 책에서 만드는 프로젝트에서는 JSON이라는 형식의 데이타를 주고 받습니다. http://127.0.0.1:12010/ 라는 요청이 들어오면 JSON을 반환하는 서버를 만들어봅시다. 
이름이라는 key를 가지고 큰돌이라는 value를 가지는 `JSON객체`를 반환하는 서버를 만들었습니다.  
##### MEVN/1장/simple_http2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

 > 참고 : json이란

json이란 JavaScript Object notation으로써 경량 데이타 교환방식을 뜻합니다. 읽기 쓰기 쉽고 파싱하며 생성하기 쉬운 장점이 있습니다. 
`{"이름" : "큰돌"}` 이러한 구조를 가진 json을 json object라고 하며`[{"이름":"큰돌"},{"이름":"큰돌2"}]`의 구조를 가진 JSON을 JSON Array라고 합니다.
JSONObject로 만들어야 key를 통해 value를 참조할 수 있으며 JSON.parse(obj)라는 메소드를 이용합니다. 반대로 문자열을 만들 때는 `JSON.stringify(obj)`라는 메소드를 사용합니다. 

JSON에는 주석이 들어갈 수는 있지만 주석이 들어가지 않는 것을 권장합니다. 
기본 자료형은 다음과 같습니다. Number, String, Boleanm, Array, Object, null 입니다. 

이 기본 자료형이 아닌 것들은 "직렬화"가 되지 않습니다. 직렬화란 외부의 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술을 말합니다. JSON직렬화는 JSON.stringify(obj)를 통해 문자열로 만들어 구현할 수 있습니다. 

예를 들어 `JSON.stringify({ "이름": undefined })` 이 객체는 직렬화가 되지 않습니다. 

.을 통해 해당 value에 접근이 가능합니다. 변수를 통해 value에 접근하는 것은 []를 씁니다. 변수를 쓰지 않는 것은 .을 쓰며 변수를 통해 쓰는 것은 [name]을 통해 참조하는 것을 권장합니다.

##### MEVN/1장/simple_json.js
```js
const obj = {
  "이름" : "큰돌", 
  "나이" : 27,
  "나이2" : undefined
}
console.log(obj.이름) //큰돌
const _name = "이름"
console.log(obj[_name]) //큰돌
console.log(obj['이름']) //큰돌
console.log(obj['나이2']) // undefined 직렬화가 되지 않으므로 권장하지 않습니다.
console.log(Object.keys(obj)) // key값을 뽑아 낼 수 있습니다.
``` 

### 2.1.2 Pm2 라이브러리 설정
만약 node.js로 만든 서버가 죽는다면 어떻게 해야 할까? 다시 node 서버.js를 하면서 킬 수도 있지만 너무나도 수동적입니다. node.js로 만든 서버를 관리하기 위한 process관리자 라이브러리인 Pm2를 사용하면 쉽고도 아름답게 관리할 수 있습니다.

 > 참고 : forever도 있지 않나요? 

서버가 죽으면 다시 켜주는 forever이라는 라이브러리도 있지만 pm2가 멈춘 프로세스관리, 좀 더 깔끔한 UI, CPU클러스터 모드, 모니터링측면에서 더 좋습니다.

일단 먼저 죽는 서버를 만듭니다. 실무에서는 잘못된 데이타가 들어왔을 때 필터를 안해주거나 예상치 못한 데이터에 관한 로직을 짜지 않았을 경우 애러가 발생되며 그 애러는 서버를 죽게 만듭니다. 아래의 코드는 JSON.parse를통해 이상한 문자열을 JSON object로 만들다가 서버가 **죽는 코드**입니다. 

##### MEVN/1장/simple_pm2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
}); 

setTimeout(()=>{ 
  //애러를 발생시켜서 1초마다 서버가 죽게 만듭니다.
  JSON.parse("{Z")
}, 1000)
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
실행을 시키면 1초만에 서버가 죽는 것을 볼 수 있습니다. 하지만 **pm2**로 구동을 시키면 서버가 죽어도 자동으로 되살리는 것을 볼 수 있습니다. 
그렇다면 PM2를 설치해보도록 하겠습니다.  

npm install -g는 전역으로 설치한다는 뜻입니다. 이렇게 전역으로 설치한 후 pm2라는 명령어를 쓸 수 있습니다. 
```js
npm install pm2 -g
```

pm2를 이용해 전에 만든 simple_http를 구동시켜봅시다.  
```
pm2 start simple_pm2.js
```

구동이 된 후 `pm2 list` 를 통해 깔끔한 UI로 어떠한 앱이 실행되었나 보여주며 cpu, 메모리 사용량 등을 볼 수 있습니다. 
![pm2 list화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_list.PNG) 

한 앱에 대한 실시간 모니터링은  `pm2 monit`를 치면 다음과 같은 화면이 나오면서 할 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monit.PNG) 

종료나 pm2 관리하는 list에서 삭제는 다음과 같은 명령어로 할 수 있습니다. 
```js 
// 서버중단
// pm2를 이용한 서버 중단 Name, 또는 ID로 중단할 수 있습니다. 
pm2 stop simple_pm2
pm2 stop 0

// 삭제
pm2 delte simple_pm2
pm2 delte 0 
```

이외에도 pm2 monitoring 이라는 명령어를 사용하고 회원가입, 로그인을 하면 특정 웹애플리케이션이 띄워지고 그 안에서 CPU사용량, 메모리, HTTP로그, 이벤트 루프, 사용되는 Heap Size 등을 더 아름답게 확인할 수 있습니다. 하지만 이는 Free-trial버전으로 2주간 무료이며 그 이후에는 유료로 쓸 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monitoringUI.PNG) 

단순히 자동적으로 서버 재시작이 가능하고 `pm2 monit`을 통해 왠만한 모니터링을 할 수 있으며 클러스터링또한 가능하다는 점에서 pm2는 안전한 서버구동에 있어 좋은 선택입니다. 

물론 서버가 안 죽게 만들어야 하는 것은 필수입니다.  

 

## 2.2. Express
- Express의 구조
- Express로 만드는 미들웨어 

## 2.3. Vue.js
- SPA와 Vue.js 
- Vue-cli 설정
- Webpack 구조

## 2.4. MongoDB
- MongoDB의 구조
- 서버 구축시 주의사항
- Mongoose와 MongoDB node.js 드라이버 성능비교
- CRUD 테스트 
- aggregate와 mapReduce 성능비교
- aggregate 예제, mapReduce 예제 