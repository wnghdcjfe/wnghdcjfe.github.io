---
layout: post
title: 'MEVN교과서 (3)'
author: kundol
comments: true
date: 2019-06-30 10:00
tags: [MEVN교과서]
sitemap: yes
excerpt: MEVN교과서 (3)

---    
![MEVN교과서](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/mevnlogo.jpg)

# 2. MEVN
MEVN은 MongoDB, Express.js, Vue.js 그리고 Node.js를 이용해서 만드는 웹 어플리케이션입니다. MEVN스택이라고 불립니다. 

## 2.1 Node.js
### 2.1.1 Node.js의 기본
Node.js는 Chrome V8 Javascript 엔진으로 빌드 된 비동기 이벤트 주도 Javascript 런타임, 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되며 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적인 서버사이드 플랫폼이자 코드를 실행할 수 있는 Javascript 런타임을 뜻합니다.

자바스크립트 프로그램이 실행되고 있을 때 그 프로그램이 존재하는 공간을 말합니다. 
Node.js를 이용해서 자바스크립트란 언어로 코드를 짜고 프로그램을 동작시켜 간단한 알고리즘이나 게임을 만들 수 있으며 Electron을 통해 데스크톱애플리케이션도 만들 수 있습니다. 

우리는 이 많은 것들을 제공하는 node.js라는 좋은 도구 중에서 서버사이드 플랫폼이라는 특징을 쓸 것입니다. 

기본적으로 node.js를 이용해 서버를 만들자면 node.js 의 내장 객체 중 하나인 `http`를 이용해야 합니다. 

Node.js가 제공하는 내장객체들의 정보들은 https://nodejs.org/api/ 를 참고하면 됩니다. 

http API는 다음과 같습니다. 첫번째 인자로는 options를 받고 두번째 인자로는 requestlistener를 받습니다. `options`는 넣어도 되고 안넣어도 됩니다. 
보통 `requestlistener` 인자만을 넣습니다. 
```js
http.createServer([options][, requestlistener])
```

브라우저 URL에 http://127.0.0.1:12010/ 을 치면 **안녕하세요 MEVN프로젝트입니다.** 라는 문자열을 반환하는 서버를 만들었습니다.  

##### MEVN/1장/simple_http.js
```js
const http = require('http');    
const PORT = 12010; 
const server = http.createServer((req, res) => {  
  res.setHeader('Content-Type', 'text/plain; charset=utf-8'); 
  res.end('안녕하세요 MEVN프로젝트입니다.'); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

이 책에서 만드는 프로젝트에서는 JSON이라는 형식의 데이타를 주고 받습니다. http://127.0.0.1:12010/ 라는 요청이 들어오면 JSON을 반환하는 서버를 만들어봅시다. 
이름이라는 key를 가지고 큰돌이라는 value를 가지는 `JSON객체`를 반환하는 서버를 만들었습니다.  
##### MEVN/1장/simple_http2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
});
 
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```

 > 참고 : json이란

json이란 JavaScript Object notation으로써 경량 데이타 교환방식을 뜻합니다. 읽기 쓰기 쉽고 파싱하며 생성하기 쉬운 장점이 있습니다. 
`{"이름" : "큰돌"}` 이러한 구조를 가진 json을 json object라고 하며`[{"이름":"큰돌"},{"이름":"큰돌2"}]`의 구조를 가진 JSON을 JSON Array라고 합니다.
JSONObject로 만들어야 key를 통해 value를 참조할 수 있으며 JSON.parse(obj)라는 메소드를 이용합니다. 반대로 문자열을 만들 때는 `JSON.stringify(obj)`라는 메소드를 사용합니다. 

JSON에는 주석이 들어갈 수는 있지만 주석이 들어가지 않는 것을 권장합니다. 
기본 자료형은 다음과 같습니다. Number, String, Boleanm, Array, Object, null 입니다. 

이 기본 자료형이 아닌 것들은 "직렬화"가 되지 않습니다. 직렬화란 외부의 시스템에서도 사용할 수 있도록 byte형태로 데이터를 변환하는 기술을 말합니다. JSON직렬화는 JSON.stringify(obj)를 통해 문자열로 만들어 구현할 수 있습니다. 

예를 들어 `JSON.stringify({ "이름": undefined })` 이 객체는 직렬화가 되지 않습니다. 
확장성을 위해 undefined로 초기화하는 것을 권장하지 않습니다. 아래의 예처럼 obj['나이2']로 `undefined` 값으로 초기화 된 것을 참조 할 수 있지만 권장하지 않습니다. null이나 0, -999, 프로젝트에서 약속된 초기값으로 초기화하는 것을 권장합니다.

.을 통해 해당 value에 접근이 가능합니다. 변수를 통해 value에 접근하는 것은 []를 씁니다. 변수를 쓰지 않는 것은 .을 쓰며 변수를 통해 쓰는 것은 [name]을 통해 참조하는 것을 권장합니다.
 
##### MEVN/1장/simple_json.js
```js
const obj = {
  "이름" : "큰돌", 
  "나이" : 27,
  "나이2" : undefined
}
console.log(obj.이름) //큰돌
const _name = "이름"
console.log(obj[_name]) //큰돌
console.log(obj['이름']) //큰돌
console.log(obj['나이2'])  
```  

### 2.1.2 Pm2 라이브러리 설정
만약 node.js로 만든 서버가 죽는다면 어떻게 해야 할까? 다시 node 서버.js를 하면서 킬 수도 있지만 너무나도 수동적입니다. node.js로 만든 서버를 관리하기 위한 process관리자 라이브러리인 Pm2를 사용하면 쉽고도 아름답게 관리할 수 있습니다.

 > 참고 : forever도 있지 않나요? 

서버가 죽으면 다시 켜주는 forever이라는 라이브러리도 있지만 pm2가 멈춘 프로세스관리, 좀 더 깔끔한 UI, CPU클러스터 모드, 모니터링측면에서 더 좋습니다.

일단 먼저 죽는 서버를 만듭니다. 실무에서는 잘못된 데이타가 들어왔을 때 필터를 안해주거나 예상치 못한 데이터에 관한 로직을 짜지 않았을 경우 애러가 발생되며 그 애러는 서버를 죽게 만듭니다. 아래의 코드는 `JSON.parse`를통해 이상한 문자열을 JSON object로 만들다가 서버가 **죽는 코드**입니다. 

##### MEVN/1장/simple_pm2.js
```js
const http = require('http');    
const PORT = 12010;
const server = http.createServer((req, res) => {   
  res.setHeader('Content-Type', 'application/json; charset=utf-8'); 
  const obj = {
    "이름" : "큰돌"
  }
  res.end(JSON.stringify(obj)); 
}); 

setTimeout(()=>{ 
  //애러를 발생시켜서 1초마다 서버가 죽게 만듭니다.
  JSON.parse("{Z")
}, 1000)
server.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}/`);
});
```
실행을 시키면 1초만에 서버가 죽는 것을 볼 수 있습니다. 하지만 **pm2**로 구동을 시키면 서버가 죽어도 자동으로 되살리는 것을 볼 수 있습니다. 
그렇다면 PM2를 설치해보도록 하겠습니다.  

npm install -g는 전역으로 설치한다는 뜻입니다. 이렇게 전역으로 설치한 후 pm2라는 명령어를 쓸 수 있습니다. 
```js
npm install pm2 -g
```

pm2를 이용해 전에 만든 simple_http를 구동시켜봅시다.  
```
pm2 start simple_pm2.js
```

구동이 된 후 `pm2 list` 를 통해 깔끔한 UI로 어떠한 앱이 실행되었나 보여주며 cpu, 메모리 사용량 등을 볼 수 있습니다. 
![pm2 list화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_list.PNG) 

한 앱에 대한 실시간 모니터링은  `pm2 monit`를 치면 다음과 같은 화면이 나오면서 할 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monit.PNG) 

종료나 pm2 관리하는 list에서 삭제는 다음과 같은 명령어로 할 수 있습니다. 
```js 
// 서버중단
// pm2를 이용한 서버 중단 Name, 또는 ID로 중단할 수 있습니다. 
pm2 stop simple_pm2
pm2 stop 0

// 삭제
pm2 delte simple_pm2
pm2 delte 0 
```

이외에도 pm2 monitoring 이라는 명령어를 사용하고 회원가입, 로그인을 하면 특정 웹애플리케이션이 띄워지고 그 안에서 CPU사용량, 메모리, HTTP로그, 이벤트 루프, 사용되는 Heap Size 등을 더 아름답게 확인할 수 있습니다. 하지만 이는 Free-trial버전으로 2주간 무료이며 그 이후에는 유료로 쓸 수 있습니다. 
![pm2 monit화면](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/pm2_monitoringUI.PNG) 

단순히 자동적으로 서버 재시작이 가능하고 `pm2 monit`을 통해 왠만한 모니터링을 할 수 있으며 클러스터링또한 가능하다는 점에서 pm2는 안전한 서버구동에 있어 좋은 선택입니다. 또한 애러가 생기면 등록된 이메일로 애러가 생겼다. 서버가 죽었다. 알림메세지까지 주니 관리측면에서 아주 좋습니다.

 > 물론 서버가 안 죽게 만들어야 하는 것은 필수입니다.  


## 2.2. Express
node.js 에서 동작하는 웹개발 프레임 워크 중 많이 쓰이는 유연한 프레임워크입니다.  
핵심기술로는 이 3가지가 핵심기술입니다.  

1. HTTP 요청에 응답하는 **미들웨어** 설정가능
2. HTTP 메소드, URL 기반으로 하는 라우팅설정  
3. 쉬운 서버구동

이 있습니다. 이외에도 Jade란 템플릿을 통해 쉽게 웹페이지를 생성할 수 있지만 이 책에서는 사용하지 않으므로 설명을 하지 않습니다.

 > 라우팅 : 클라이언트가 요청 및 요청 예정되는 경로를 설정하는 작업
 > 미들웨어 : 중간에 껴놓은 소프트웨어, 부가적인 처리, 기능 을 담당

## 2.2.1. HTTP 요청에 응답하는 미들웨어 설정가능
```js
const app = express();

// --- 1번로직

app.use((req, res, next)=>{ // -- use를 통해 중간에 미들웨어를 설정할 수 있습니다 .
  console.log('Time:', Date.now());
  next();
});

// --- 2번 로직
```
이렇게 1번과 2번 로직 사이에 끼어놓는 로직을 미들웨어라고 합니다. `use`를 통해 미들웨어가 모든 요청에 대해 미들웨어를 추가했습니다. `app.get` 등을 이용해 특정한 HTTP 요청을 다루는 것이 아닌 use를 통해 모든 요청을 처리할 수 있습니다. 

모든 요청에 대해 중간에 거는 미들웨어를 추가하는 것입니다. 이를 이용하면 이런게 가능합니다. 
```JS
var logger = require('morgan');
app.use(logger('tiny'));
```
이렇게 morgan이라는 로그 시스템 라이브러리를 놓게 되면 모든 요청에 대한 로그를 쉽게 파악할 수 있습니다. 


## 2.2.2. HTTP 메소드, URL 기반으로 하는 라우팅설정  
말그대로 라우팅설정입니다. URL인 users/dad/books/dad의 요청을 req.params로 받아서 쉽게 처리할 수 있습니다. get이라는 요청을 처리했는데 이와 동시로 다른 요청또한 처리할 수 있습니다. 
```js
app.get('/users/:userId/books/:bookId', function (req, res) {
  res.send(req.params)
})
// users/dad/books/dad 요청시
//{"userId":"dad","bookId":"dad"}
```
/book이라는 url의 get, post, put 요청을 처리하는 함수
```js
app.route('/book')
  .get(function (req, res) {
    res.send('Get a random book')
  })
  .post(function (req, res) {
    res.send('Add a book')
  })
  .put(function (req, res) {
    res.send('Update the book')
  })
```

## 2.2.3. 쉬운 서버구동
`app.listen(12010)` 만으로 쉽게 서버를 구축할 수 있습니다. 예제 코드입니다. 

 > 항상 이렇게 app이라는 객체에 담아서 로직을 짜는 것이 중요합니다. 


### 2장 simple_express.js
```js
const express = require('express');
const path = require('path')
const app = express();
const _path = path.join(__dirname, './dist')
console.log(_path)
app.use('/dist', express.static(_path)) // 정적 컨텐츠를 사용자에게 제공할 때 사용되는 메서드입니다. 특정 path에 해당하는 자료들을 사용자가 접근가능하게끔합니다.
app.listen(12010, ()=> {
  console.log('너의 서버는? 12010!');
});
``` 
/dist라는 요청을 받았을 때 dist폴더의 index.html을 보여주는 서버를 만들었습니다.
`__dirname`은 JS가 실행되는 현재 위치를 가리키는 Node.js의 전역 변수입니다. `path.join`을 사용해서 현재 서버를 구동한 위치로부터의 dist폴더를 제공한다라는 것을 아름답게 만들수 있습니다.

node.js의 path라는 모듈은 파일, 디렉토리의 관한 path들을 조작할 수 있는 좋은 모듈입니다. 
path를 다루는 메서드 중 많이 쓰이는 메서드는 join과 resolve입니다. 

| 메서드 | 설명 | 
|:--------|:--------|
| resolve	| 받은 인자들을 통해 절대 경로를 반환한다.	|
| join	| 받은 인자들을 연결한다.	| 

```JS
const path = require('path')
const _resolve = path.resolve('.', 'dist', 'css')
const _join = path.join(__dirname, 'dist', 'css')
console.log(_resolve)
console.log(_join)
// C:\Users\LUCID\Desktop\개발\dist\css
// C:\Users\LUCID\Desktop\개발\dist\css

```

이렇게 서버를 구동한 후, http://127.0.0.1:12010/dist 에 가보면 아름다운 제 처음 서버가 완성됩니다. 

#### Q : 그렇다면 /test서버에 제 index.html을 보기 위해서는 어떤 코드를 수정해야 할까요? 

![2_simple_server](https://raw.githubusercontent.com/wnghdcjfe/wnghdcjfe.github.io/master/MEVN/2_simple_server.PNG) 

## 2.3. Vue.js
### 2.3.1 SPA와 Vue.js  
Vue.js는 자바스크립트 프레임워크 중 인기있는 프레임워크 중 하나입니다. 재사용가능한 컴포넌트, 정말 쉬운 문법,  React보다 빠르며, 중앙 집중식 상태관리 저장소인 vuex, Angular의 장점만 뽑은 점 등이 장점입니다. 저는 Vue.js가 React.js보다 반드시 더 커질 것이라고 믿는 개발자 중 한명입니다. 쉽고 빠르고 좋습니다. 일부 개발자들은  Vue.js가 큰 프로젝트에서는 맞지 않는다고 하지만 저는 Vue.js가 나온 초창기부터 도전적으로 2년짜리 큰 프로젝트에 Vue.js를 썼으며 정말 안전하고 성능도 좋은 결과물을 만들어냈습니다.  

 - [기본가이드](https://vuejs.org/v2/guide/)
 - [DEEPDIVE](https://medium.com/@oneminutejs/a-deep-dive-in-the-vue-js-source-code-0-table-of-contents-170dcc3c8ec)

이 책에서는 Vue.js의 기본가이드를 설명해주지는 않습니다. 
위의 기본가이드를 보시면 마스터할 수 있습니다.  
 
Vue.js는 기본적으로 단일 페이지 애플리케이션(Single Page Application, SPA)이란 특징을 가지고 있습니다. 
SPA는 기본적으로 단일 페이지로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다는 장점이 있습니다.

link tag를 사용하는 전통적인 웹 방식은 새로운 페이지 요청 시마다 정적 리소스가 다운로드되고 전체 페이지를 다시 렌더링하는 방식을 사용하므로 새로고침이 발생되어 사용성이 좋지 않습니다. 그리고 변경이 필요없는 부분를 포함하여 전체 페이지를 갱신하므로 비효율적입니다. 

### 2.3.2 SPA의 장점 
SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하고 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 반응속도 등 UX가 향상되어 네이티브 앱과 유사한 사용자 경험을 제공할 수 있습니다. 

### 2.3.3 SPA의 단점, 1. 초기구동속도
초기 구동 속도, SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느릴 수 밖에 없습니다. 

### 2.3.3 SPA의 단점, 2. SEO문제
SPA는 서버 렌더링 방식이 아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이기 때문에 자바스크립트를 구동하지 않은 웹크롤러에 대해서는 크롤링이 되지 않습니다. 

 > SEO와 초기구동속도를 고려한다면 개발할 당시에는 SPA로 개발을 하고 배포할 때는 서버사이드 렌더링처럼하는 프레임워크인 NUXT 등을 사용하면 됩니다. 

### 2.3.4 Vue-cli 설정
자 이제 Vue.js를 이용한 프로젝트를 구축해보도록 하겠습니다.  

- Vue-cli 설정
- Webpack 구조

## 2.4. MongoDB
- MongoDB의 구조
- 서버 구축시 주의사항
- Mongoose와 MongoDB node.js 드라이버 성능비교
- CRUD 테스트 
- aggregate와 mapReduce 성능비교
- aggregate 예제, mapReduce 예제 