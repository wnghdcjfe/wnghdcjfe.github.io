7. 모나드  
모나드는 컨텍스트 레벨을 값 레벨로 끌어들여 추상화를 한 후 이를 통해 로직 구성의 유연성에 도움을 주고 함수합성을 안전하게 하는데 도움을 줄 수 있습니다.   컨텍스트란 어떤 루틴의 실행에 영향을 줄 수 있는 레지스터, 콜스택, 객체의 현재 상황 등에 해당하는 상태를 말하는데 이를 값으로 추상화시키는 것을 모나드라고 합니다.  

또한 개념적으로 함수형프로그래밍에서는 반드시 참조투명성, 입력과 출력이 동일하게 1 : 1 매칭이 되어야 하므로 모나드를 씁니다.  예를 들어 특정값을 예상했는데 애러가 나타난다면 1 : 다수의 매칭이 되므로 이 특성을 유지하기 위해 안전하게 모나드를 쓰는 것입니다.  
 
모나드는 함수합성에 많이 쓰이는데 예를 들어 f라는 함수가 있고 g라는 함수가 있고 f(g())  이런식으로 합성을 한다고 했을 때 예상치 못한 값을 집어넣게 되면 오류가 발생하거나 예상치 못한 결과가 나올 수 있습니다. 이를 방지하고 안전하게 컨테이너 박스안에서 연산을 실행할 수 있게 도와주는 개념이 바로 모나드입니다. 모나드는  아이덴티티 모나드, 퓨처 모나드 등이 있으며 이 중 여기서 퓨처모나드인 Promise를 중점으로 알아봅니다. 이 퓨처모나드로 null, undefined 애러처리, I/O 관련 불완전한 상태로 일어나는 로직들을 안전하게 처리할 수 있씁니다. 

퓨처모나드, Promise
퓨처모나드인 Promise 모나드는 래핑하기 위해 쓰입니다. 비동기를 처리하거나 null값이 발생할 수 있는 로직에 대해서 어떠한 값의 결과가 불확실하게 2가지형태 이상으로 나타날 수 있습니다. 이럴 때 컨테이너로 래핑하여 안전하게 연산을 하는 것을 말합니다. 또한 함수형프로그래밍의 특징을 지키기 위해서도 존재합니다.

Promise는 퓨처모나드이며 미래의 값을 담을 수 있다는 뜻을 가지고 있습니다. 
그렇다면, 미래의 값은 뭘까요? 바로 I/O모델적인 상황입니다. 데이타베이스에서 값을 가져오거나 네트워크를 통해서 어떠한 API서버로부터 값을 가져온다고 했을 때 그 값은 미래의 값이 됩니다. 지금상황으로써는 그 값이 어떠한 결과인지 모르고 단지 우리가 짜놓은 스키마 등에 따른 예상만 가능하기 때문이죠. 
이러한 미래의 값을 기다리는 비동기적 상황에서 성공과 실패라는 두가지의 값으로 놓고 미래를 다루는 하나의 컨테이너 박스가 Promise입니다. 뭔가 멋져 보이죠? 2장에서 설명했듯이 Promise를 통해 불완전한 비동기의 결과값을 콜백, 컨텍스트가 아닌 하나의 값으로 로직을 수행하는 것을 볼 수 있었습니다.  
이 Promise는 아래의 모나드 조건을 모두 충족시킵니다.
1.	순수한 값을 Promise로 래핑해서 반환할 수 있습니다. 프로미스로 감싸서 리턴하면 Promise<pending>이라고 나오게 되는 것처럼 말이죠.
2.	Promise.resolve(value)를 통해 순수한 값을 끄집어 낼 수 있습니다. 
3.	Promise가 중복되더라도 순수한 값을 끄집어 낼 수 있습니다. 프로미스를 아무리 중복시켜도 resolve를 통해 순수한 값을 끄집어낼 수 있습니다. 


▶ 용어 : 콜백 : 어떤 함수가 어떠한 시점에서 다시 호출 되는 것

7.1 Promise로 애러처리 - 파싱하려던 값에 문제가 있다면?
const g = JSON.parse;
const f = k => k.temp; 
const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f)
const log = x => console.log(x)

fg('{"temp":36.5}').catch(_ => 'JSON PARSE is not working').then(log)
함수 g와 함수 f를 준비합니다. {"temp":36.5}라는 문자열을 g를 이용해서 JSON Object로 변환합니다. 이 때 Promise를 이용해서 오류가 있다면 then(f)가 아닌 catch로 넘어가서 애러를 처리하게 합니다.   

7.2 Promise로 애러처리 - 예상되었던 객체가 없다면?
const log = console.log
const users = [{name : ‘큰돌’}, {name : ‘제호’}, {name : ‘우람’}, {name : ‘다빈’}] 
const getUserByName = (name) => users.find(u => u.name === name) || Promise.reject(“객체에 없습니다.”)
const g = getUserByName;
const f = ({name}) => ${name}이가 춤을 춥니다.
Const fg = x => new Promise((resolve, reject)=> resolve(x)).then(g).then(f) 
fg(“큰돌1”).catch(_ => _).then(log)
//객체에 없습니다.
fg(“큰돌”).catch(_ => _).then(log)
// 큰돌이가 춤을 춥니다.
/*
큰돌이가 춤을 춥니다.
객체에 없습니다.
*/ 